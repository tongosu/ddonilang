# 또니랑 언어 개발 구조

> 또니랑(Ddonirang)은 한국어 네이티브 프로그래밍 언어로,
> **결정성(재현)을 "엔진 옵션"이 아니라 "문법"으로 확보**하는 것을 핵심 목표로 합니다.

---

## 1. 설계 철학

### 1-1. 결정성 = 문법

일반적인 언어에서 결정성은 런타임 옵션이나 라이브러리 차원에서 제공됩니다.
또니랑은 이를 **문법 자체에서 강제**합니다.

| 문법 장치 | 역할 |
|-----------|------|
| 조사 경계 `~` | 한국어 조사(을/를, 로/으로…)의 경계를 명시해 파싱 모호성 제거 |
| 단일 대입 `<-` | 상태 변경 표기를 하나로 통일 |
| 실행 꼬리 `~기/~하기` | 정의와 호출을 문법적으로 분리 |
| 단일 연결 `해서` | 파이프/체인 방식을 하나로 수렴 |
| 평가 표지 `}인것/}한것/}해서` | 블록의 실행 시점을 명시적으로 표기 |
| 계약 `바탕으로/다짐하고` | 조건 위반을 무시 대신 진단/기록 |

### 1-2. 6원소 계약

또니랑은 "세계"를 6개 원소로 분리해 역할과 책임을 명확히 합니다.

| 원소 | 이름 | 역할 |
|------|------|------|
| 입력 | **샘** | 모든 행동의 시작점. 입력 스냅샷으로 동결 |
| 상태 | **누리** | 게임/시뮬레이션의 세계 상태 |
| 규칙 | **이야기** | 왜 바뀌는지 설명하는 층 |
| 표현 | **보개** | 화면·소리 — 보이는 개(界) |
| 기록 | **거울** | 되감기/감사/재현 |
| 지능 | **슬기** | AI가 돕고, 때로는 지킴 |

### 1-3. AI 협업 전제

또니랑은 "AI가 코드를 생성할 수 있다"를 전제로 설계합니다.
코어를 비결정화하지 않으면서 **검증 가능한 흐름**을 만듭니다.

- **사람**: 의도/설명/기준 설정
- **AI**: 코드 생성 + 아이디어 제안
- **팩 테스트**: 예제가 정본(골든)을 계속 통과하는지 자동 확인
- **정본화(캐논)**: 표기가 흔들려도 결과가 한 형태로 모이게 함
- **리플레이/트레이스**: 문제 상황을 그대로 재현

---

## 2. 아키텍처 — 3계층 구조

```
┌──────────────────────────────────────────────┐
│                   tool/                       │
│  ddn 인터프리터, CLI, LSP, 테스트 하니스       │
│  (ddn_runtime.rs, main.rs, lsp/, proof/)      │
├──────────────────────────────────────────────┤
│                   lang/                       │
│  문법 파싱(AST), 정본화 출력, 런타임 값 정의    │
│  (lexer → parser → ast → canonicalizer)       │
├──────────────────────────────────────────────┤
│                   core/                       │
│  결정성 엔진(Fixed64, state_hash, NuriWorld)   │
│  입력 스냅샷, 자원 저장소, Patch 적용           │
└──────────────────────────────────────────────┘
```

### 2-1. core/ — 결정성 엔진

결정적 실행의 기반 계층입니다.

| 모듈 | 파일 | 역할 |
|------|------|------|
| 엔진 루프 | `engine.rs` | 틱 기반 실행 루프 |
| 고정소수점 | `fixed64.rs` | Fixed64(Q32.32) — 부동소수점 대신 결정적 산술 |
| 입력 | `input.rs` | 키 비트 변환, 입력 매핑 |
| 자원 저장소 | `resource.rs` | NuriWorld, Patch 적용, 결정적 자원값 |
| 상태 해시 | (engine 내부) | DetBin → BLAKE3 해시로 상태 결정성 검증 |
| 자원핸들 | `resource.rs` | ResourceHandle(64-bit, xxh3_64) |
| 단위 | `units.rs` | UnitDim 기반 단위 차원 검증 |
| 신호 | `signals.rs` | Signal(Diag 포함) 전달 |
| 플랫폼 | `platform.rs` | 플랫폼 추상화 |
| 영역 | `realms.rs` | 자원 영역 구분 |
| 알림 | `alrim.rs` | 진단/경고 메시지 |
| 보개 | `gogae3.rs` | 렌더 커맨드, BDL2 디코딩 |
| 슬기 | `seulgi/` | AI 훅/이벤트 |
| 샘 | `sam/` | 입력 스냅샷 관리 |
| NuriGym | `nurigym/` | 강화학습 환경 인터페이스 |
| 워프 | `warp.rs` | 시뮬레이션 워프 |

### 2-2. lang/ — 문법·파싱·정본화

소스 코드를 AST로 변환하고, 정본화하는 계층입니다.

| 모듈 | 파일 | 역할 |
|------|------|------|
| 어휘 분석 | `lexer.rs` | 토큰 분리 (조사 `~`, 종결 `./?/!` 등) |
| 파서 | `parser.rs` | 토큰 → AST 변환 |
| AST | `ast.rs` | 구문 트리 정의 |
| 정본화기 | `canonicalizer.rs` | AST → 정본(canonical) 텍스트 출력 |
| 정규화 | `normalizer.rs` | 별칭 통일, 표기 정규화 |
| 런타임 값 | `runtime.rs` | Value 타입 정의 (수/글/참거짓/차림/묶음 등) |
| 표준 라이브러리 | `stdlib.rs` | 내장 함수 정의 |
| 표면 문법 | `surface.rs` | 사용자 입력 표면 형태 처리 |
| 용어 매핑 | `term_map.rs` | 한국어 ↔ 정본 용어 매핑 |

### 2-3. tool/ — 인터프리터·CLI·테스트

실행과 검증을 담당하는 계층입니다.

| 모듈 | 파일 | 역할 |
|------|------|------|
| DDN 런타임 | `ddn_runtime.rs` | 인터프리터 실행 엔진 |
| 진입점 | `main.rs` | CLI 명령 라우팅 |
| LSP | `lsp/` | 언어 서버 프로토콜 (QuickFix 포함) |
| 증명 | `proof/` | 결정성 증명 하니스 |
| 스키마 | `schema.rs` | 출력 스키마 정의 |
| AI 프롬프트 | `ai_prompt.rs` | AI 생성 프롬프트 관리 |
| Gate 레지스트리 | `gate0_registry.rs` | 관문 0 기능 등록 |
| 전처리 | `preprocess.rs` | 소스 전처리 |
| 프로젝트 메타 | `project_meta.rs` | 프로젝트 설정 |
| DetMath 에셋 | `detmath_assets.rs` | CORDIC sin/cos 등 결정적 수학 |

---

## 3. 데이터 흐름

```
소스(.ddn) → [lang] 파서 → AST
                ↓
         [lang] 정본화(N1) → 정본 텍스트(선택)
                ↓
         [tool] 런타임 → [core] Patch 생성
                ↓
         [core] NuriWorld에 Patch 적용
                ↓
         [core] state_hash 기록 → [tool] 골든/리플레이 비교
```

### 결정성 경계

| 경계 | 구현 |
|------|------|
| 숫자 | Fixed64(Q32.32)만 사용 — 부동소수점 배제 |
| 입력 | Sam이 InputSnapshot으로 동결 |
| 해시 | NuriWorld DetBin → BLAKE3 |
| 자원 | ResourceHandle(64-bit, xxh3_64)로 고정 |

---

## 4. 문법 — 구현 현황

### 4-1. 기본 구문

| 기능 | 구문 | 설명 |
|------|------|------|
| 문장 종결 | `.` `?` `!` | 어미 접미 기반 어조 추정 포함 |
| 대입 | `변수 <- 표현식` | 상태 변경 통일 표기 |
| 복합 갱신 | `+<-` / `-<-` | `a <- a ± b`로 전개 (`+=`/`-=`는 거부) |
| 선언 | `그릇채비:` / `붙박이마련:` | 변수/상수 블록 선언 |
| 필드 접근 | `대상.필드` | 묶음에서만 허용 |

### 4-2. 씨앗(함수) 정의·호출

```ddn
-- 정의 (꼬리 금지)
(주문:말~로) 문~을_열기:움직씨 = {
    바탕.문_상태 <- "열림".
    (주문) 보여주기.
}.

-- 호출 (꼬리 필수)
("열려라!")~로 문~을_열기 하기.
```

- **씨앗 종류**: `셈씨` (순수 계산), `움직씨` (세계에 변화)
- **호출 형태**: `(인자) 이름 하기/기` — prefix `이름(인자)` 호출은 금지
- **이름 인자**: `핀=값` 정본 (접미 `:핀`, `~조사`, `@단위`/`@"자원"` 지원)
- **씨앗 리터럴**: `{인자 | 표현식}` (1급 씨앗값)
- **돌려줘**: 반환값 반환

### 4-3. 제어 흐름

| 구문 | 형태 |
|------|------|
| 조건 | `(조건) 일때 { ... } 아니고 (조건) 일때 { ... } 아니면 { ... }` |
| 조건 (블록) | `{ ... }인것 일때 { ... }` / `{ ... }아닌것 일때 { ... }` |
| 반복 | `반복:` (무한) / `{ ... }인것 동안:` / `(항목) 대상에 대해:` |
| 멈추기 | `멈추기.` |
| 순회 설탕 | `(임자) 대상 모두 { ... }.` |
| 분기 | `~해보고:` + `고르기:` (`아니면:` 필수) |

### 4-4. 블록과 평가 표지

`{ ... }` 블록(토막)은 **평가 표지**로 실행 시점을 명시합니다.

| 표지 | 의미 | 제약 |
|------|------|------|
| `}인것` | 조건 평가 (참/거짓) | `<-`/`}하고`/RNG 금지 |
| `}아닌것` | 부정 조건 | `}인것`과 동일 제약 |
| `}한것` | 표현식 평가 (값 반환) | `<-` 금지 |
| `}하고` | 부수효과 실행 | |
| `}해서` | 파이프 연결 | |

### 4-5. 파이프·연결

```ddn
(데이터)~로 변환하기 해서 (결과)~를 출력하기.
```

- `~기/하기 해서` 체인 — 단계 호출식만 허용
- 흐름값 자동 주입
- `-서` 단독 사용은 FATAL

### 4-6. 계약

```ddn
{잔액 > 0}인것 바탕으로 {
    -- 잔액이 양수일 때만 실행
} 아니면 {
    "잔액 부족" 보여주기.
}.
```

| 형태 | 동작 |
|------|------|
| `바탕으로` (전제) | 사전 조건 검증 |
| `다짐하고` (보장) | 사후 조건 검증 |
| `바탕으로(알림)` | 위반 시 진단만 남기고 계속 |
| `다짐하고(알림)` | 위반 시 진단만 남기고 계속 |
| `맞으면` | 선택적 성공 분기 |

- 위반 시 거울(진단)에 DR-069 표준 필드로 기록
- 슬기 훅 이벤트 발생

### 4-7. 훅

| 훅 | 형태 | 시점 |
|----|------|------|
| 불변 | `(조건) 늘지켜보고 { ... }` | 매 틱 조건 감시 |
| 시작 | `(시작)할때 { ... }` | 실행 시작 시 1회 |
| 틱 | `(매마디)마다 { ... }` | 매 틱 실행 |

### 4-8. 템플릿·수식

| 기능 | 구문 | 설명 |
|------|------|------|
| 글무늬 | `글무늬{...}` | 포맷 지원 (@W/@0W/@.D/@.DU) |
| 글무늬 주입 | `(<키=값>) 글무늬{...}` | 즉시 렌더 |
| 수식 | `수식{...}` | #ascii/#ascii1/#latex 태그 |
| 수식 풀기 | `(값) 풀기` | #ascii/#ascii1만 평가 가능 |
| 미분/적분 | `미분하기`/`적분하기` | #ascii 방언만 지원 |

### 4-9. 자료구조

| 타입 | 리터럴 | 설명 |
|------|--------|------|
| 차림(배열) | `[v1, v2, ...]` | 정본 전개: `(…) 차림` |
| 모음(집합) | `(...요소) 모음` | |
| 짝맞춤(맵) | `(열쇠, 값, ...) 짝맞춤` | 순회 시 `차림[열쇠, 값]` |
| 묶음(팩) | `(키=값, ...)` | 필드 접근 `.필드` |
| 텐서 | `[[...],[...]]` | 중첩 차림 → 텐서 설탕 전개 |

- 차림 인덱싱: `a[i]` → `차림.값`, `a[i] <- v` → `차림.바꾼값`
- 텐서: `형상/자료/배치/값/바꾼값` 접근
- 차림/모음/짝맞춤은 자원에 저장 가능 (결정적 자원값 경로)

### 4-10. 논리·비교·산술

| 종류 | 연산자 |
|------|--------|
| 산술 | `+`, `-`, `*`, `/`, `^` |
| 비교 | `==`, `!=`, `<`, `<=`, `>`, `>=` |
| 논리 | `&&`/`그리고`, `\|\|`/`또는`, `아님` |

- 논리 연산자는 **좌→우 모두 평가** (단락 평가 없음)

---

## 5. 값·타입 시스템

| 타입 | 설명 |
|------|------|
| 수 | Fixed64(고정소수점 Q32.32) |
| 단위값 | UnitValue(Fixed64 + UnitDim, 런타임 차원 검증) |
| 글 | 문자열 |
| 참거짓 | Bool |
| 차림 | 배열(List) |
| 모음 | 집합(Set) |
| 짝맞춤 | 맵(Map) |
| 묶음 | 팩(Pack) |
| 없음 | None (자원 저장 불가) |
| 자원핸들 | ResourceHandle (`@"경로"` 또는 `("경로") 자원`) |
| 글무늬값 | Template |
| 수식값 | Formula |
| 원자 | `#태그` (문자열로 평가) |

### 단위 시스템

`@단위` 접미 표기로 단위를 부여합니다.

- 예: `x@m`, `t@s`, `v@mps`
- 레지스트리: `@m`, `@s`, `@평`, `@inch`, `@ft`, `@kmh`, `@mps`, `@KRW`, `@USD`
- 단위 불일치 시: 대입 무효화 / 차원고장 신호

### PinSpec 타입검사

핀(파라미터)에 타입 표기가 있으면 런타임에서 타입을 검사하고,
불일치 시 `E_RUNTIME_TYPE_MISMATCH` 오류를 발생시킵니다.

---

## 6. 내장 함수 (표준 라이브러리)

### 6-1. 글(문자열)

`길이`, `대문자로바꾸기`, `소문자로바꾸기`, `다듬기`, `되풀이하기`, `합치기`, `포함하나`, `시작하나`, `끝나나`, `자르기`, `붙이기`, `글자뽑기`, `찾기`, `바꾸기`, `숫자로`, `글로`

### 6-2. 차림(배열)

`차림`, `차림.값`, `차림.바꾼값`, `토막내기`, `들어있나`, `찾아보기`, `길이`, `첫번째`, `마지막`, `뒤집기`, `추가`, `제거`, `붙이기`, `펼치기`, `정렬`, `거르기`, `변환`, `각각돌며`, `합치기`

### 6-3. 텐서

`텐서.형상`, `텐서.자료`, `텐서.배치`, `텐서.값`, `텐서.바꾼값`

### 6-4. 수학

`바닥`, `천장`, `반올림`, `합계`, `평균`, `abs`, `sin`, `cos`, `min`, `max`, `clamp`, `sqrt`, `powi`

- sin/cos: CORDIC 기반 결정적 고정소수점 구현

### 6-5. 입력·RNG·자원

| 분류 | 함수 |
|------|------|
| 입력 | `눌렸나`, `막눌렸나` |
| RNG | `무작위`, `무작위정수`, `무작위선택` |
| 자원 | `자원` (글 → 자원핸들) |

### 6-6. 묶음·모음·짝맞춤

| 분류 | 함수 |
|------|------|
| 묶음 | `묶음값`, `키목록`, `값목록`, `쌍목록`, `합치기` |
| 모음/짝맞춤 | `모음`, `짝맞춤` |
| 템플릿 | `채우기`, `맞추기` (글무늬 매칭) |
| 수식 | `풀기`, `미분하기`, `적분하기` |

---

## 7. 도구 체계 — teul-cli

### 7-1. teul-cli 개요

`tools/teul-cli/`에 위치한 Rust 기반 CLI 도구입니다.
Cargo로 빌드되며, 40개 이상의 서브커맨드를 제공합니다.

```
teul-cli
├── src/
│   ├── main.rs          # 진입점, Commands enum
│   ├── canon.rs         # 정본화 엔진
│   ├── file_meta.rs     # DDN 파일 메타 헤더 파싱
│   ├── core/            # 코어 바인딩
│   ├── lang/            # 언어 바인딩
│   ├── runtime/         # 런타임 엔진
│   └── cli/             # 서브커맨드 구현 (40+ 모듈)
│       ├── run.rs       # DDN 실행
│       ├── repl.rs      # 대화형 REPL
│       ├── canon.rs     # 정본화 명령
│       ├── test.rs      # 테스트 실행
│       ├── replay.rs    # 리플레이
│       ├── bogae.rs     # 보개(렌더) 관련
│       ├── eval.rs      # 식 평가
│       ├── lint.rs      # 코드 검사
│       ├── geoul.rs     # 거울(기록) 관련
│       ├── train.rs     # NuriGym 학습
│       └── ...          # 기타 40+ 서브커맨드
```

### 7-2. 주요 서브커맨드 분류

| 분류 | 명령 | 설명 |
|------|------|------|
| 실행 | `run` | DDN 파일 실행 |
| 실행 | `repl` | 대화형 REPL (State 유지) |
| 실행 | `eval` | 단일 식 평가 |
| 정본화 | `canon` | DDN → 정본 텍스트 변환 |
| 검증 | `test` | 팩 테스트 실행 |
| 검증 | `check` | 프로젝트 검증 |
| 검증 | `lint` | 코드 검사 |
| 기록 | `replay` | 리플레이 실행 |
| 기록 | `replay-diff` | 리플레이 차이 비교 |
| 기록 | `geoul` | 거울(기록) 관리 |
| 기록 | `trace-tier` | 트레이스 계층 |
| 보개 | `bogae` | 보개 번들/편집/재생 |
| 보개 | `bogae-bundle` | 보개 에셋 번들링 |
| 보개 | `view` | 뷰어 |
| AI | `ai` | AI 프롬프트 관리 |
| AI | `train` | NuriGym 학습 |
| AI | `imitation` | 모방 학습 |
| AI | `infer` | 추론 |
| 에셋 | `asset` | 에셋 관리 |
| 교과 | `edu` | 교과 팩 관리 |
| 기타 | `scan`, `gateway`, `story`, `swarm` 등 | 확장 기능 |

### 7-3. 실행 옵션

```
teul-cli run <file.ddn>
  --state / --state-file    # 초기 상태 주입 (JSON/Detjson)
  --bogae-out               # 보개 해시 출력
  --bogae-cache-log         # 보개 캐시 hit/miss 로그
  --unsafe-open             # open 차단 우회
```

---

## 8. 검증 시스템

### 8-1. 팩(Pack) 테스트

`pack/` 디렉토리에 **193개** 테스트 팩이 있습니다.
각 팩은 DDN 소스 + 기대 출력(골든)으로 구성됩니다.

팩 분류 예시:

| 접두사 | 내용 | 예시 |
|--------|------|------|
| `age1_*` | AGE1 기능 테스트 | `age1_charim_index`, `age1_container_basics` |
| `bogae_*` | 보개 렌더 테스트 | `bogae_hash_determinism_v1`, `bogae_web_out_determinism` |
| `bdl2_*` | BDL2 패킷 테스트 | `bdl2_path_circle_v1`, `bdl2_subpixel_aa_v1` |
| `diag_*` | 진단 테스트 | `diag_contract_mode_v1`, `diag_contract_seulgi_hook` |
| `decl_*` | 선언 테스트 | `decl_block_runtime` |
| `compound_*` | 복합 연산 테스트 | `compound_update_basics` |
| `edu_*` | 교과 팩 | 교육용 콘텐츠 검증 |
| `key_alias_*` | 키 별칭 테스트 | `key_alias_ko_v1` |
| `tetris_*` | 테트리스 데모 | 게임 데모 검증 |
| `maze_*` | 미로 데모 | 미로 탐색 검증 |

### 8-2. 골든 테스트

`golden/` 디렉토리에 기대 출력이 저장됩니다.

- DDN 실행 결과의 `state_hash`, `trace_hash`, `bogae_hash`를 비교
- 소수 4자리 반올림 + 키 정렬로 결정성 유지
- 해시 불일치 = 결정성 깨짐 → 즉시 감지

### 8-3. 리플레이

- 입력 테이프(`input_tape`) 기반 재현
- `replay-diff`로 두 실행의 차이를 비교
- `replay-branch`로 분기점 탐색

---

## 9. 시각화 — 셈그림(SeamGrim) UI

### 9-1. 개요

`solutions/seamgrim_ui_mvp/` — 교육용 수식/그래프/시뮬레이션 웹 UI입니다.

```
solutions/seamgrim_ui_mvp/
├── ui/
│   ├── index.html     # 4탭 레이아웃 (교과/DDN/실행·시간/도구)
│   ├── styles.css     # 스타일
│   └── app.js         # 앱 로직 (6000+ 줄)
├── tools/
│   ├── bridge_server.py   # DDN 실행 브리지 (HTTP → teul-cli)
│   ├── export_graph.py    # DDN → seamgrim.graph.v0 JSON
│   ├── export_space2d.py  # DDN → seamgrim.space2d.v0 JSON
│   ├── export_text.py     # DDN → seamgrim.text.v0 JSON
│   ├── export_table.py    # DDN → seamgrim.table.v0 JSON
│   ├── bridge_check.py    # 브리지 서버 점검
│   └── lesson_pack_check.py  # 교과 팩 검증
├── samples/               # 샘플 DDN 파일
└── docs/
    └── PLAN.md
```

### 9-2. UI 구조 (4탭)

| 탭 | 내용 |
|----|------|
| **교과** | 교과(lesson) 팩 선택, 주제 브라우징 |
| **DDN** | DDN 편집기 + 실행/내보내기/불러오기 |
| **실행/시간** | 시간 샘플링, 타임라인 뷰, 파라미터 조정 |
| **도구** | 브리지 설정, 프리셋, 비교 모드, 인스펙터, 로그 |

### 9-3. 브리지 서버

브라우저 UI에서 DDN을 실행하기 위한 **로컬 HTTP 서버**(포트 8787)입니다.

```
[브라우저 UI] --POST /api/run--> [bridge_server.py]
                                    ↓
                              [teul-cli run <file.ddn>]
                                    ↓
                              stdout 파싱 (그래프/표/구조)
                                    ↓
[브라우저 UI] <--JSON 응답------
```

### 9-4. 출력 스키마

| 스키마 | 용도 |
|--------|------|
| `seamgrim.graph.v0` | 점열/그래프 데이터 |
| `seamgrim.space2d.v0` | 2D 공간/도형 데이터 |
| `seamgrim.text.v0` | 텍스트/해설 데이터 |
| `seamgrim.table.v0` | 표 데이터 |

---

## 10. 프로젝트 전체 구조

```
codex/
├── core/              # 결정성 엔진 (Rust)
├── lang/              # 문법·파싱·정본화 (Rust)
├── tool/              # 인터프리터·CLI·테스트 (Rust)
├── tools/
│   ├── teul-cli/      # 통합 CLI 도구 (40+ 서브커맨드)
│   ├── vscode-ddn/    # VS Code 확장
│   └── scripts/       # 빌드/배포 스크립트
├── pack/              # 193개 테스트 팩
├── pack_public/       # 공개용 팩
├── golden/            # 골든(기대) 출력
├── gaji/              # 가지(입력 호환) 처리
├── tests/             # 통합 테스트
├── solutions/
│   └── seamgrim_ui_mvp/  # 셈그림 웹 UI
├── docs/
│   ├── ssot/          # SSOT 정본 문서
│   ├── status/        # 구현 상태 문서
│   ├── steps/         # 관문(Gate) 단계별 기록
│   ├── decisions/     # 설계 결정 기록
│   └── guides/        # 가이드 문서
├── publish/           # 발표/공개용 자료
├── prompts/           # AI 프롬프트 관리
├── guides/            # 사용자 가이드
├── scripts/           # 유틸리티 스크립트
├── ddn.project.json   # 프로젝트 설정
├── ddn.units.json     # 단위 레지스트리
├── ddn.asset.json     # 에셋 설정
├── ddn.ai.policy.json # AI 정책 설정
├── Cargo.toml         # Rust 워크스페이스
└── Cargo.lock
```

---

## 11. 정본(SSOT) 문서 체계

또니랑은 "정본(Single Source of Truth)"을 가장 중요하게 봅니다.
모든 구현은 SSOT 문서를 따릅니다.

| 문서 | 역할 |
|------|------|
| `SSOT_INDEX` | 어디서부터 읽는지 안내 |
| `SSOT_LANG` | 언어 문법 정본 |
| `SSOT_PLATFORM` | 실행 모델/결정성 정본 |
| `SSOT_TOOLCHAIN` | 정본화/팩/AI 협업 정본 |
| `GATE0 체크리스트` | 관문 0 구현 통과 기준(DoD) |
| `SSOT_ALL` | 위 문서 올인원 |

---

## 12. 현재 상태와 방향

### 구현 완료

- 문법: 씨앗 정의/호출, 조건, 반복, 파이프, 계약, 훅, 글무늬, 수식, 차림/텐서, 논리 연산
- 타입: 수(Fixed64), 글, 참거짓, 차림, 모음, 짝맞춤, 묶음, 자원핸들, 단위값, 글무늬값, 수식값
- 표준 라이브러리: 글/차림/텐서/수학/입력/RNG/묶음/템플릿/수식 내장 함수
- 도구: teul-cli 40+ 서브커맨드, LSP, 보개 번들, 에셋 매니페스트
- 검증: 193개 팩 테스트, 골든 비교, 리플레이
- 시각화: 셈그림 웹 UI (4탭 구성, 브리지 서버, 4종 출력 스키마)
- 데모: 미로, 테트리스

### 미구현/진행 중

- 계약 확장: 슬기 훅 실행(AGE2) 및 자동화 정책
- 수식 방정식 풀이/정리
- `#latex` 수식 평가 (표시/저장만 가능)
- ddn.math/ext 호출 포함 수식 풀기
- BDL1/BDL2 ↔ graph.v0 역변환 경로
- 셈/거울 정식 스키마 SSOT 반영

### 로드맵

1. **콘솔 기반 선언적 시뮬레이션** — 텍스트로 움직이는 세계 (되감기/리플레이 기본)
2. **웹 기반 2D 창작 도구** — 한국어 블루프린트 + 스크래치 수준의 쉬움
3. **셈그림·물리·경제 실험실 + NuriGym** — 교육 + 강화학습 환경

---

> "또니랑은 한국어 문장 구조를 코드로 쓰되,
> 조사·꼬리·정본화로 모호함을 없애 결정성을 확보합니다."
