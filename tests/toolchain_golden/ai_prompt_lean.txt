[또니랑 코드 생성 규약]
SSOT_VERSION = v20.6.33
AUTHORITY = SSOT (정본)

[근거]
- 너에게 제공된 최신 SSOT 정본(12개 + SSOT_ALL)만 근거로 사용한다.
- diff(`SSOT_PATCH_*.diff`), 과거 버전, 외부 자료는 근거로 사용하지 않는다.

[필수 규칙]
- 시간 단위: 마디. 시스템 훅: (시작)할때 / (매마디)마다 / ("이름")할때.
- 판정(참거짓) 씨앗은 질문형 이름을 그대로 사용한다. (DR-027)
- 특수블록은 “주입 접두”로만 즉시 평가한다. (DR-028)
- 문장 호출은 ~기/~하기로 표기한다. 정의/선언은 ~다/~하다 표면을 사용한다.
- 출력은 또니랑 코드만. 불확실한 점은 주석 `// 미정:` 으로 남긴다.

[출력 형식]
- 파일 1개 분량의 코드로 출력한다.
- 가능하면 데모/예시는 SSOT_DEMOS의 스타일을 따른다.

[컨텍스트]
SSOT_VERSION = v20.6.33
BUNDLE_KIND = dir
PROFILE = lean
BUNDLE_HASH = sha256:5e95a00bd22615db146d954c1f7712cbe9d21add7359dcc4bd988139a4eaf972
FILE_LIST =
- SSOT_INDEX_v20.6.33.md
- SSOT_TERMS_v20.6.33.md
- SSOT_DECISIONS_v20.6.33.md
- SSOT_LANG_v20.6.33.md
- SSOT_DEMOS_v20.6.33.md
- GATE0_IMPLEMENTATION_CHECKLIST_v20.6.33.md
===== BEGIN SSOT_INDEX_v20.6.33.md =====
# 또니랑 SSOT — INDEX (v20.6.33)

> 문서 버전: v20.6.33  
> 작성일: 2026-02-17 (Asia/Seoul)

이 문서는 **SSOT 정본 문서(현재 스냅샷)** 의 읽기 순서와 구성요소를 안내한다.

---

## 0) 폴더 규칙(요약)

- `docs/ssot/ssot/` : **현재 스냅샷 1벌**  
  - 파일명 버전은 모두 `v20.6.33` 로 통일한다.
- `docs/ssot/releases/<version>/` : 과거 스냅샷 보관(아카이브)

---

## 1) 추천 읽기 순서

1. `README_v20.6.33.md`
2. `SSOT_MASTER_v20.6.33.md`
3. `SSOT_TERMS_v20.6.33.md`
4. `SSOT_DECISIONS_v20.6.33.md`
5. `SSOT_LANG_v20.6.33.md`
6. `SSOT_TOOLCHAIN_v20.6.33.md`
7. `SSOT_DEMOS_v20.6.33.md`
8. `SSOT_PLANS_v20.6.33.md`
9. `SSOT_ROADMAP_CATALOG_v20.6.33.md`
10. `SSOT_OPEN_ISSUES_v20.6.33.md`
11. `SSOT_PENDING_v20.6.33.md`

(통합본)
- `SSOT_ALL_v20.6.33.md`

(무결성)
- `SSOT_ALL_MANIFEST_v20.6.33.md`

---

## 2) 말씨(다국어) 레지스트리 데이터(참고)

- 기준표 v4 (로마자 중심, 자연스러움 리뷰 기준)
  - `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v4_20260215.tsv`
  - `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v4_20260215.detjson`
  - (리뷰) `docs/context/notes/dialect/DIALECT_ALIAS_NATURALNESS_REVIEW_20260215.md`

- 개선표 v8 (문법 용어 정합성 + 간소 별칭 병기, 셀의 `/`는 복수 별칭)
  - `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v8_20260215.tsv`
  - `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v8_20260215.detjson`
  - (보기용) `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v8_20260215.md`
  - (변경 로그) `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v8_20260215_CHANGELOG.md`

### 2-1) 동치/보증 검증 팩(참고)
- 기본 동치팩(ko/en/sym3/ja/mn/tr): `docs/ssot/pack/lang/dialect_equiv_v2/`
- ne 전용 동치팩(ko/sym3/ne): `docs/ssot/pack/lang/dialect_equiv_ne_v1/`
  - ne는 **데바나가리 표기 우선**이며, 일부 셀은 `देवनागरी/roman`처럼 `/`로 복수 별칭을 병기한다.

### 2-2) 관련 PROPOSAL(참고)

- ne D-PACK(동일 AST/동일 state_hash) 제안: `docs/context/proposals/PROPOSAL_DIALECT_NE_GOLDEN_DPACK_V1_1_K003_NFC_20260215.md`
- ne 입력 정규화(K003) 티켓: `docs/context/proposals/PROPOSAL_DIALECT_NE_INPUT_NORMALIZATION_K003_V1_20260215.md`
- ne 입력 정규화(K004) 확장 티켓: `docs/context/proposals/PROPOSAL_DIALECT_NE_INPUT_NORMALIZATION_K004_V1_20260215.md`
- 셈그림 V2 WASM 해석기 브릿지(V1): `docs/context/proposals/PROPOSAL_SEAMGRIM_WASM_INTERP_V1_20260215.md`



- 정체성(결정론 수학/시뮬레이션 DSL): `docs/context/proposals/PROPOSAL_IDENTITY_MATH_SIM_DSL_V1_20260216.md`
- 흐름(Stream) 값 타입 + 보임(Boim) 관행: `docs/context/proposals/PROPOSAL_STREAM_AND_BOIM_V2_20260216.md`
- 흐름(Stream) 링버퍼 상세: `docs/context/proposals/PROPOSAL_STREAM_STATEFUL_RINGBUFFER_V1_20260216.md`
- STDLIB 다국어 파이프라인: `docs/context/proposals/PROPOSAL_STDLIB_MULTILANG_PIPELINE_V1_20260215.md`
- 우향 대입 `->` 제안: `docs/context/proposals/PROPOSAL_ASSIGN_ARROW_RIGHT_V1_20260216.md`
- map/접근값 정책 제안: `docs/context/proposals/PROPOSAL_MAP_ACCESS_VALUE_V1_20260216.md`
- 꾸러미 배포/레지스트리(곳간) 제안: `docs/context/proposals/PROPOSAL_PACKAGE_REGISTRY_V1_20260217.md`
- 꾸러미 서버 MVP 제안: `docs/context/proposals/PROPOSAL_PACKAGE_SERVER_MVP_V1_20260217.md`
- 정규식 리터럴 + 호출 오버로드(인자수/타입/조사) 제안: `docs/context/proposals/PROPOSAL_REGEX_LITERAL_AND_CALL_OVERLOAD_V1_20260217.md`
- 결정성 계약 등급(Contract Tiers) 제안: `docs/context/proposals/PROPOSAL_CONTRACT_TIERS_V1_20260217.md`
- DetMath 로드맵 제안: `docs/context/proposals/PROPOSAL_DETMATH_ROADMAP_V1_20260217.md`
- 관측 프로토콜 V0 제안: `docs/context/proposals/PROPOSAL_OBSERVATION_PROTOCOL_V0_20260217.md`
- DDN 아키텍처 종합 재설계(프라그마/가져오기 등) 제안: `docs/context/proposals/PROPOSAL_DDN_ARCHITECTURE_SYNTHESIS_V1_20260217.md`
- 셈그림(Seamgrim) 재기획 V1(보개/이야기 분리) 제안: `docs/context/proposals/PROPOSAL_SEAMGRIM_REPLAN_V1_20260217.md`


---

## 3) 작업 기준(SSOT 관리자 규칙)

- 정본은 항상 **`SSOT_ALL` + workspace patch** 로 본다.
- 문서 변경 시:
  - (MUST) **버전 상승**
  - (MUST) `SSOT_ALL_MANIFEST` 갱신
  - (SHOULD) `docs/ssot/ssot/` 은 “현재 스냅샷 1벌”만 남긴다.
===== END SSOT_INDEX_v20.6.33.md =====
===== BEGIN SSOT_TERMS_v20.6.33.md =====
# 또니랑 SSOT — TERMS (v20.6.33)

이 문서는 **순우리말(정본) ↔ 기존/영문(별칭)**을 일관되게 쓰기 위한 **용어 정본**이다.

- 정본 용어는 **문서/예시/AI 출력의 1순위**다.
- 기존 용어(영문/한자어)는 **별칭**으로만 두고, 처음 등장할 때 `(별칭: …)`처럼 함께 적는다.
- **기계 추출용 TERM-MAP JSON은 `SSOT_LANG_v20.6.33.md`의 `TERM-LINT-01 / TERM-MAP-01`을 정본으로 둔다.**  
  (이 문서는 사람 읽기용 설명/표 중심)

---

> **용어 정본 변경(채택):** `바탕`(정본) ↔ `살림`(레거시 별칭)  
> - 입력에서는 `살림`을 별칭으로 허용할 수 있으나, 문서/정본 출력은 `바탕`을 사용한다.  
> - 관련: DR-112 (v20.4.1)


> **용어 정본 변경(채택, 2026-02-13):**
> - `맞물림씨`(정본) ↔ `관계씨`(별칭/레거시 입력)
> - `되풀이`(정본) ↔ `반복`(별칭/레거시 입력)
> - `되돌림`(정본) ↔ `반환`(별칭/레거시 입력)
> - `톺아보기`(정본) ↔ `감사`(별칭/레거시 입력)
> - `해봄줄`(정본) ↔ `시험줄`(별칭)
> - `겹차림`(정본) ↔ `텐서`(별칭)
> - `바른꼴`(정본) ↔ `정본`, `캐논`(별칭)
> - `차림판`(정본) ↔ `차림표`(별칭)

## 0) 이 SSOT가 “용어 정본”을 따로 두는 이유

1) **어린이/초심자**에게 “용어 하나 = 뜻 하나”가 중요하다.  
2) **AI**는 같은 뜻의 다른 단어를 섞는 순간, 덧댐/검증/재현성이 흔들린다.  
3) 장기적으로 LSP/자동완성/번역기(정본↔별칭)를 만들 때 **기초 데이터**가 된다.

---

## 1) 최상위 개념 3단(글–마디–토막)

| 정본 | 뜻 | 대표 별칭 |
|---|---|---|
| **글** | 하나의 독립된 또니랑 문서/이야기/시뮬레이션 시나리오 *(참고 번역: document)* | program |
| **마디** | 글을 이루는 큰 단위. 이야기의 한 박자이자(=turn), 누리(세계) 시간의 기본 단위 *(렌더 프레임과 구분; 참고 번역: frame/step)* | turn |
| **토막** | 마디 안에서 더 작은 묶음 단위. `{ ... }`로 감싸며 “작은 실행/작은 뜻”을 담는다. *(참고 번역: chunk/thunk)* | block |

### 토막을 두는 이유(요약)
- 글↔마디만으로는 “덜어내기/붙이기/바꿔치기”가 거칠다.  
- `{}` 토막은 **AI 덧댐 단위**로도 좋고, 사람에게도 “여기만 고치자”가 된다.

---

## 2) 이야기(또니×누리) 핵심 용어

| 정본 | 뜻 | 대표 별칭 |
|---|---|---|
| **또니** | 아이(플겹/학습자/주인공) *(참고 번역: agent)* | player |
| **누리** | 세계(환경, 규칙, 상태, 시뮬레이션 공간) *(참고 번역: environment)* | world |
| **또니랑누리** | “또니가 누리와 상호작용하며 배우고 놀고 만든다”는 전체 비전 | DdonirangNuri |

---

## 3) AI‑aware 핵심 용어(요약)

| 정본 | 뜻 | 대표 별칭 |
|---|---|---|
| **정본** | 표준 출력/규범(SSOT가 정하는 유일한 형태) | canonical |
| **별칭** | 입력에서 허용될 수 있는 대체 표기(출력은 정본으로 정규화) | alias |
| **재현묶음** | 같은 실행/사고를 다시 재생할 수 있게 모은 꾸러미 *(참고 번역: repro package)* | repro |
| **지킴이** | 규칙/안전/정확성을 감시하는 역할(사람/AI/도구) *(참고 번역: guardian)* | guard |

---

## 4) 수학/시뮬레이션 지향 용어(최소)
- **차림(배열)**: 순서가 의미인 값들의 줄. `[]`/`[v1, v2, ...]`는 **차림 리터럴(값)**로 사용.
- **값꾸러미(튜플/레코드)**: 고정 길이 값 묶음(좌표/인덱스/필드 기반).
- **텐서**: `형상(shape)+자료(data)+배치(layout)`로 정의되는 n차원 자료.
  - 정본 표현(엄밀/결정성): `형상:차림`, `자료:1차 차림(평탄)`, `배치:"가로먼저"(row-major)` 기본.
  - 중첩 차림 `[[...],[...]]`는 **입력 설탕**이며 canon이 정본 표현으로 전개(불규칙 금지).
- **바탕차림(밀집 버퍼)**: 텐서의 `자료(data)`에 해당하는 연속/고정 길이 저장소(AGE1+ 표준화 대상).

| 정본 | 뜻 | 대표 별칭 |
|---|---|---|
| **셈** | 계산, 수학적 연산 | arithmetic |
| **단위** | 물리량/돈/시간 등의 단위 체계 | units |
| **모의** | 시뮬레이션(미리 돌려보기) | simulation |

---

## 5) 문서에서의 표기 규칙(권장)

- (A) **처음 등장:** `정본(별칭: …)`  
  예) `토막(별칭: block)`  
- (B) **이후:** 정본만 사용  
- (C) 표/코드/키워드에서는 가능하면 정본 사용.  
- (D) 용어 충돌이 생기면 `SSOT_LANG_v20.6.33.md`의 TERM‑LINT/TERM‑MAP을 먼저 갱신하고, 그 다음에 문서들을 정규화한다.
- (E) **별칭은 0~1개만 둔다(권장 → 장기적으로 MUST).**
  - ‘순우리말 정본’ + ‘대표 별칭 1개(일상말 *또는* 영문)’까지만 유지해 혼선을 줄인다.
  - 추가 표기(과거 문서 용어/검색 키워드)는 **레거시 입력**으로만 인정하고, AI/정본 출력에서는 생성하지 않는다.
- (F) **약칭**은 허용한다. 단, 약칭은 ‘별칭’과 달리 **정본의 줄임말**이며, 처음 한 번만 “정본(약칭 …)”로 소개한다.
---

## 6) 이번 반영으로 추가된 용어(정본 ↔ 별칭)

| 정본(권장) | 뜻 | 별칭 |
|---|---|---|
| **빛꼬리표** | 수식/표현을 태그 트리로 표현하는 정형 표기 | Raytag |
| **조사봉인** | 무괄호 호출에서 “조사만으로 인자를 봉인”해 파싱을 결정적으로 만드는 방식 | josa-only mode |
| **말글** | 화자+내용을 갖는 대사/발화 데이터 | dialogue line, speech |
| **가지** | repo의 패키지 단위. `/gaji/<이름>/gaji.toml`로 식별 | package |
| **모듬** | 코드 이름공간/배포 단위(모듬 ID: `<가지ID>/<모듬이름>`) | module |
| **작업터** | 여러 가지/프로젝트가 함께 사는 저장소(워크스페이스) | workspace |
| **배포꾸러미** | 가지를 묶어 배포/설치하는 아카이브(압축) 단위. *(주의: **값꾸러미**(tuple/record)와 다른 말)* | bundle, package distribution |
| **꾸러미.toml** | 배포꾸러미 메타(초안). 기존 `gaji.toml`과의 관계/명칭은 OI-501에서 결정 | bundle manifest |
| **꾸러미.lock** | 프로젝트 의존을 해시로 핀하는 잠금파일(초안) | lockfile |
| **곳간** | 배포꾸러미를 검색/다운로드하는 레지스트리(원격/로컬) | registry |
| **스코프/이름@버전** | 꾸러미 식별 표기 초안(예: `표준/물리@20.6.33`) | scoped id |
| **스코프/이름/모듬** | 모듬(모듈) 경로 표기(예: `표준/물리/역학`) | module path |
| **표준** | (곳간 스코프) 공식 표준 라이브러리(정본) 꾸러미 | std, standard |
| **나눔** | (곳간 스코프) 커뮤니티 기여 꾸러미 | community, contrib |
| **내** | (곳간 스코프) 작업터/프로젝트 내부 전용 꾸러미(게시 금지) | local, private |
| **벌림** | (곳간 스코프) 외부 의존을 로컬에 복사해 둔 꾸러미(vendor) | vendor, third-party |
| **MVS** | Minimum Version Selection. 의존성 해결 규칙 후보 | minimum version selection |
| **산출물** | `build/`·`dist/`에 생성되는 결과물 | artifact |
| **알림 레지스트리** | 병합된 알림목록의 정본 목록(+해시) | event registry |
| **꼬리 없는 호출** | 호출 꼬리 없이 씨앗 이름이 끝난 표현(진단 대상) | tailless call |
| **솔루션** | 하나의 결과물(앱/수업/데모 세트)을 구성하는 상위 작업 단위 | solution |
| **걸음길** | 튜토리얼/고개별 학습 경로 폴더(레포의 `walks/`) | walks |
| **D-팩** | 데모/검증/진단/기대값을 묶는 D-PACK 단위(레포의 `pack/`) | D-PACK |
| **생김새** | 임자(엔티티)의 시각적 표현/렌더 상태 이름씨(구조) | 모양 |
| **특성** | 생김새가 어떤 보개 트레잇(ID)을 쓰는지 나타내는 필드 | 트레잇 |
| **보개_바탕_가로/보개_바탕_세로** | 보개 캔버스(바탕) 크기(픽셀) 키 | bogae_canvas_w/bogae_canvas_h |
| **기호변환** | 수식을 기호적으로 바꾸는 일(미분/적분/정리 등) | symbolic transform |
| **수치미분** | 함수값/샘플로 도함수를 근사 계산 | numerical differentiation |
| **수치적분** | 함수값/샘플로 적분값을 근사 계산 | numerical integration |
| **적분상수** | 부정적분에서 더해지는 상수(정본 기호: `C`) | constant of integration |
| **차수** | 미분/적분의 반복 횟수(1차, 2차 …) | order |
| **오차추정** | 수치근사의 오차 추정값 | error estimate |
| **길잡이말** | `#...`로 시작하는 **메타 줄**. 실행/`state_hash`에는 영향이 없고, 도구(UI/린트/팩)가 읽어 관찰/조종/추적 등을 구성한다. | pragma, directive |
| **관찰목록** | 글(.ddn)에서 관찰 가능한 마디/바탕 항목을 구조화한 목록(JSON). 보개(Seamgrim)·누리Gym이 공유할 수 있다. | observation manifest |
| **보개메타** | 보개(관찰) 채널에 담기는 렌더/관찰 힌트(축/겹침/렌즈 등). `state_hash` 비대상. | view_meta |



## 7. AI-aware / 밖일(Effect) / 할힘(Capability)

- **슬기맞춤 걸쇠(AI-aware Hook)**  
  - 결정적 코어(누리) 흐름 속에 비결정적인 AI(슬기)를 **안전하게 끼워 넣기 위해 미리 정해 둔 표준 접점(삽입 지점)**.  
  - 표준 훅 6종(권장): 관찰/질문/주입/검문/기록/재연.

- **밖일(별칭: Effect)**  
  - 결정적 코어 밖에서 일어나는 **외부 I/O / 비결정 / 슬기 호출 / 협업 / 수선(고치기)** 류를 통칭. *(일상말: “효과”)*  
  - 원칙: 밖일의 결과는 **입력 사건으로 봉인**하여 샘(InputSnapshot)으로만 들어오며, 거울에 기록되고, 리플레이에서 재호출하지 않는다.

- **밖일갈래(별칭: Effect Types)**  
  - 밖일을 종류로 구분한 분류 체계(예: 파일읽기/네트워크요청/음성인식/OCR/슬기에게_묻기).  
  - Gate0에서는 확장하지 않고, AGE3 로드맵에서 도입하는 것을 기본으로 한다.

- **할힘(별칭: Capability)**  
  - 수문장(Gatekeeper)이 의도(intent)·밖일을 검문할 때 쓰는 “허용 범위” 규칙. *(일상말: “권한”)*  
  - 예: “말하기만 가능”, “로그 남기기 가능”, “파일읽기는 금지”, “세계 핵심 컴포넌트 직접 수정 금지”.

- **(ROADMAP 표기) `!X`**
  - ROADMAP/예시에서 `!불씨`, `!바람`처럼 `!`를 **앞에 붙여** “능표/할힘 토큰(룬 핸들)”을 표시하는 **약식 표기**이다.
  - Gate0 정식 문법/정본 산출물(`*.ddn`)에서는 `!` 표기를 요구하지 않으며, 구현은 보통 `cap_id: "불씨"` 같은 문자열 식별자 + Gatekeeper/계약 검증으로 수행한다.
  - `10@kg`(단위 표기), `@"..."`(자원 접미), `@.0`(글무늬 인덱스) 등 `@` 기반 표기와 혼동하지 않는다.


---

## 8. 슬기 역할 / 모델 쓸감 / 구조화 슬기구멍

- **슬기-운용**(별칭: runtime inference)  
  - 런타임에서 `관찰(observe) → 생각(think_async) → 의도(intent)`를 만들고, 결과를 샘(InputSnapshot) 주입으로만 반영하는 역할. *(일상말: “추론 슬기”)*

- **슬기-공방**(별칭: training)  
  - 작업대(TOOLCHAIN)에서 데이터셋/레시피/평가를 통해 모델을 만들고 `ModelArtifact(모델 쓸감)`으로 포장하는 역할. *(일상말: “학습 슬기”)*

- **슬기-통로**(별칭: gateway)  
  - 외부 LLM/외부 정책/외부 도구 호출을 담당하는 역할. request_key/캐시/리플레이/정책 필터를 통해 결정성 세계를 보호한다. *(일상말: “게이트웨이 슬기”)*

- **모델 쓸감**(별칭: ModelArtifact)  
  - 단순 “모델 파일”이 아니라, **재현/감사 단위**로 포장된 실행 자산. 스키마 해시/평가 결과/결정성 계약/무결성 해시 등을 포함한다. *(레거시 표기: “모델 꾸러미”, ModelPack)*

- **구조화 슬기구멍**(별칭: question card)  
  - `??{...}` 또는 `??(글무늬{...})`로 표현되는 TOOLCHAIN 전용 입력 표식. *(일상말: “질문카드”)* 런타임에 남지 않으며, 박제(Freeze) 메타로 재현성을 남기는 데 쓰인다.



---

## §NEW (v19.4.27) 모드·결정성 관련 용어

- **openness (닫힘/열림)**: 밖일(외부 입력/출력/네트워크/AI 호출)의 허용 정책
  - `closed`: 샘/거울/재현 계약 아래에서만 밖일 허용
  - `open`: 실험을 위해 더 많은 밖일 허용(단, 기록·격리 규칙 강화)

- **det_tier (결정성 등급)**: 프로젝트가 선택하는 재현 강도/허용 기능 범위
  - `D-STRICT`: 비트 단위 재현 목표 (Fixed64 중심)
  - `D-FAST`: 동일 HW/런타임 재현 목표(성능 타협)
  - `D-ULTRA`: 성능/기능 우선(실험), 재현은 best-effort

---


## §NEW (v20.1.2) 로드맵 단위: 줄기·고개·걸음

또니랑의 장기 로드맵(= `SSOT_ROADMAP_CATALOG`)은 실행(누리) 시간 단위인 `마디`와 **개념이 다릅니다**.  
혼선을 막기 위해 로드맵 단위는 아래 3가지를 **정본(순우리말)**으로 씁니다.

- **줄기 (별칭: 부)**  
  - 로드맵의 최상위 묶음. 예: **3줄기(부)**.
- **고개 (별칭: 기)**  
  - 줄기 아래의 중간 묶음. 예: **9고개(기)**.
- **걸음 (별칭: 단계)**  
  - 로드맵의 최소 이정표. 예: **99걸음(단계)**.

### 표기 규칙

- 문서 표기 기본형: `제N줄기`, `제N고개`, `N걸음`
- **병기(권장):** 처음 1회는 `줄기(부)`, `고개(기)`, `걸음(단계)`처럼 **순우리말 먼저, 기존말은 괄호**로.
- `마디`는 **런타임/의미론(틱)** 전용으로 남기며, 로드맵 용어로는 사용하지 않습니다.




## §NEW (v19.4.27) 바탕·터바탕씨·쓸감 용어

또니랑 문서/코드에서 `바탕`(시스템/전역상태)과 `쓸감`(에셋/자산)을 섞어 쓰면,
구현(해시/재현/로더)과 사용자(학습/문서)가 동시에 헷갈릴 수 있습니다.
그래서 TERMS에서 한 번 더 고정합니다.

- **터바탕씨** (별칭: RealmResource)
  - 누리(세계/realm)에 **전역으로 하나만 존재**하는 상태 객체(예: `중력`, `단위곳간`, `난수계보`). *(영문 번역: resource)*
  - 결정성(Closed/Strict)에서는 보통 **state_hash에 포함**되며, `schema_hash` 및 ProjectMeta 핀과 함께 재현의 일부가 됩니다.
- **`바탕.〈이름〉`** (표면 접근 루트)
  - 코드에서 `터바탕씨`에 접근하는 **정본 표기**입니다.
  - DOT-LEX 규칙: 공백 없는 `.`만 접근으로 인정합니다. (`바탕.중력` ✅ / `바탕. 중력` ❌)
- **쓸감** (별칭: Asset)
  - 그림/소리/모델/표준팩 묶음 같은 **외부 자산 파일**(또는 그 묶음)입니다.
  - 결정성 관점에서, 쓸감 자체는 세계의 지속 상태가 아니라 **프로젝트 의존성(잠금/해시 핀)**으로 재현성을 담보합니다(툴체인 책임).

정리:

- `터바탕씨`는 **개념(무엇)**, `바탕.〈이름〉`은 **표면(어떻게)** 입니다.
- `쓸감`은 “세계 상태”가 아니라 “세계가 **참조**하는 외부 자산”입니다.

## §NEW (v19.4.27) 고유권/빌림 관련 용어(초안)

> 이 절은 **개념 정리용**이다. 정식 문법/의미론은 `SSOT_DECISIONS`의 OI/DR을 따른다.

- **고유권(별칭: ownership)**
  - “어떤 값을 **바꿀 수 있는 권리**는 동시에 하나의 경로로만 존재해야 한다”는 원칙.
  - 목적: (1) 안전한 코드, (2) 병렬 실행 가능성, (3) 결정적 결과(충돌/경쟁 제거).

- **빌림(별칭: borrow)**
  - 특정 범위(scope)에서만 값을 “잠깐 쓰는” 접근.
  - 두 종류(개념):
    - **공유빌림(별칭: shared borrow)**: 읽기 전용. 여러 개 동시 허용.
    - **독점빌림(별칭: exclusive borrow)**: 바꾸기(쓰기) 포함. 동시에 하나만 허용.

- **빌림검사(별칭: borrow checker)**
  - 위 규칙을 컴파일/정적 분석 단계에서 검증하는 장치.
  - 또니랑에서는 Rust식 “표현식 단위” borrow checker를 바로 목표로 삼기보다,
    **바탕(시스템) 단위의 읽기/쓰기 집합 선언 + 스케줄러 충돌 금지**를 우선 후보로 둔다.

- **Replay Contract(재현 계약)**: “어디까지 재현을 보장하는가”를 프로젝트가 명시하는 약속
  - `bit-perfect` | `same-hw` | `recorded` | `none`

- **Feature Gate(기능 게이트)**: 기능/팩이 요구하는 최소 조건
  - `requires.det >= ...`
  - `requires.open = true|false`
  - (선택) `requires.replay = ...`

- **샘(InputSnapshot)**: 마디 경계에 맞춰 봉인된 입력 묶음(장치/네트워크 포함). 거울에 기록된다.

## §9 솎음줄(Q-Chain)·솎음고리

- **솎음줄**: AI가 만든 출력(제안/고침쪽/덧댐)을 누리에 들이기 전에 **미리보기→검증→승인**으로 걸러 넣는 품질/안전 파이프라인.
  - 정본: 솎음줄
  - 대표 별칭: Q-Chain
  - 내부 식별자(권장): `qchain` (폴더/파일/키 이름에서만 사용)
- **솎음고리**: 솎음줄을 이루는 단계(Q1~Q7 같은 링크/스텝). *(시뮬레이션 시간 단위 ‘마디’와는 다른 개념)*
  - 정본: 솎음고리
  - 대표 별칭: link

## §10 누리·마당·판 (World/Scene/Level)

- **누리(정본)**: World. 상태·규칙이 굴러가는 “세계”.
  - 대표 별칭: world
  - 레거시 입력(허용, 출력 금지): 월드
- **마당(정본)**: Scene(장면). 한 누리 안의 “한 장면/한 장”.
  - 대표 별칭: scene
  - 레거시 입력(허용, 출력 금지): stage, 씬, 무대
  - 노트: “무대(舞臺)”는 한자어라 **정본은 ‘마당’**으로 두고, *무대*는 별칭으로만 둔다.
- **판(정본)**: Level(게임 한 판/한 회). 플레이 단위/라운드 단위.
  - 대표 별칭: level
  - 약칭(권장): 판 *(“한 판” 의미로만)*
  - 레거시 입력(허용, 출력 금지): episode, round, 레벨
  - 노트: ‘판’은 (板)/(版) 등 동형이의가 있어, 게임 의미의 “한 판”을 **정본 ‘판’**으로 고유화한다.
- UI/연동 매핑(권장): `터(Realm) → 누리(World) → 마당(Scene) → 판(Level/Episode)`

## §11 차림표·체·끼우개 (Manifest/Filter/Adapter)

- **차림표(정본)**: Manifest. “이것들을 이렇게 맞춰 써라”는 맵/차림/룰셋 파일.
  - 대표 별칭: manifest
  - 레거시 입력(허용, 출력 금지): 매니페스트
- **체(정본)**: Filter(필터). 입력/이벤트/대상을 **조건으로 걸러** 다음 단계로 넘기는 틀(인터페이스/규약).
  - 대표 별칭: filter
  - 레거시 입력(허용, 출력 금지): 필터
  - 동작(함수) 정본: `거르기` (입력 레거시: 걸러/필터링 등은 허용하되, 정본 출력 금지)
- **끼우개(정본)**: Adapter(어댑터). 서로 다른 형식/규약을 “끼워 맞춰” 이어 주는 연결체.
  - 대표 별칭: adapter
  - 레거시 입력(허용, 출력 금지): 어댑터, 잇개
- 노트: 현행 문서/코드에는 레거시 표기(필터/어댑터)가 남아 있을 수 있으며, 이 경우 **별칭**으로 해석한다.


## §12 말힘누리(언령게임) — 장르/세계관 축

- **말힘누리(정본)**: ‘말(주문/문장)’이 힘이 되어 누리를 바꾸는 게임/학습 장르를 가리키는 이름.
  - 대표 별칭: 언령게임
  - 노트: **또니랑누리**는 ‘프로젝트/작품 이름’이고, **말힘누리**는 ‘장르/설계 축’이다.

## §13 움직이는 셈그림(Manim) — 보개(시각화) 가지

- **움직이는 셈그림(정본)**: 수식/도형/물리 법칙을 ‘마디 타임라인’으로 움직이는 그림(애니메이션)으로 보여주는 보개(시각화) 가지.
  - 대표 별칭: Manim
  - 약칭(권장): 셈그림
  - 추가 약칭(허용, 출력 비권장): 움셈그림
  - 노트: ‘만임’은 음차 표기이므로, 문서에서 필요하면 **Manim(만임)**처럼 한 번만 병기한다.
## §14 기본 값타입 (AGE0 정본)

AGE0에서 **말(LANG)**이 반드시 다뤄야 하는 값타입 이름을 정리합니다.  
(구현은 AGE0에서 최소로 시작하고, 컨테이너/고급 타입은 AGE1+에서 확장합니다.)

| 값타입(정본) | 대표 별칭 | 설명 |
|---|---|---|
| **수** | number | 기본 수치 타입. 결정적 계산을 위해 `Fixed64(Q32.32)`를 정본으로 둔다. |
| **글** | string | UTF-8 글. |
| **참거짓** | bool | 참/거짓. |
| **없음** | none/null | “값이 없음”. |
| **값꾸러미** | tuple/record | 여러 값을 **고정 길이**로 묶은 값(튜플/레코드). 문서 병기 허용: `값꾸러미(튜플/레코드)`. |
| **차림** | list/sequence | **순서 있는 결정적 배열/리스트**. 문서 병기 허용: `차림(배열)`. 값 리터럴 `[]`, `[v1, v2, ...]` 허용(타입 표기 `T[]` 금지). *(컨테이너 구현은 AGE1+, 표면 리터럴은 canon 전개 우선)* |
| **모음** | set | 중복 없는 모아둠. `(T)모음`. *(컨테이너 구현은 AGE1+)* |
| **짝맞춤** | dict/map | 열쇠→값 짝의 모음. `(K V)짝맞춤`. *(컨테이너 구현은 AGE1+)* |

- 노트(정수 vs 수):
  - 표면 문법에서 `정수/정수64` 같은 타입을 **따로 둘 수도** 있지만, AGE0의 핵심은 “결정적 수치(고정소수)”이므로 우선 `수(Fixed64)`를 기준으로 잡는다.
  - `길이/인덱스`처럼 “정수 성질”이 필요한 곳은 **진단/검사로 강제**하거나, AGE1+에서 서술타입(정수 ⊂ 수)로 확장한다.

## §15 부름글(Prompt)·말결(Vibe)

- **부름글(정본)**: 슬기(AI)에게 주는 입력 글/지시문. (템플릿/팩/로그로도 쓰임)
- **말무늬(정본)**: 부름글을 “고정 골격 + 변수”로 만들기 위한 템플릿 규격(프롬프트 템플릿). `SSOT_TOOLCHAIN`에서 파일 규격을 정의한다.
  - 대표 별칭: prompt
  - 레거시 입력(허용, 출력 금지): 프롬프트
- **말결(정본)**: 문장/주문이 가진 “태도·강도·분위기” 같은 미세한 결.
  - 대표 별칭: vibe, nuance
  - 정본 표기(예): `$매우`, `$조금` 같은 “말결 표지”를 정본화기가 메타데이터로 보존한다.

## §16 뜻밝힘(Manifesto)

- **뜻밝힘(정본)**: 프로젝트/도구의 “왜/무엇/어떻게”를 밝히는 선언문/원칙문서.
  - 대표 별칭: manifesto
  - 노트: `차림표(Manifest)`는 “차림/명세 파일”이고, `뜻밝힘(Manifesto)`는 “선언/원칙 문서”다.
## §17 차림새·묶음·덧댐·겹 (Profile/Bundle/Patch/Layer)

- **차림새(정본)**: 같은 도구라도 “무엇을 포함하고 어떤 규칙으로 돌릴지”를 고르는 **구성/모드 묶음**.
  - 대표 별칭: profile
  - 예: AI 컨텍스트 차림새(lean/gate0plus), DetMath 차림새(#빠름/#정밀)
- **묶음(정본)**: 문서/자원/규칙을 함께 담아 배포하는 **아카이브(보통 zip)**.
  - 대표 별칭: bundle
- **덧댐(정본)**: 기존 정본에 **덧붙여 바꾸는 변경 묶음**. (diff/patch 파일)
  - 대표 별칭: patch
- **겹(정본)**: 그림/요소의 **겹침 순서(z-order)** 같은 층/레이어 개념.
  - 대표 별칭: layer



## §18 가지(package)·팩(D-PACK)·걸음길(walks)·모듬(module)

- **가지(정본)**: 배포/의존 단위(패키지). *(대표 별칭: package)*  
  - 레거시 입력(허용, 출력 금지): `팩`, `pack`  *(DR-050 이후 별칭으로는 사용하지 않음)*
  - 예: 표준가지, 시드가지, 도구가지
- **`gaji.toml`(정본)**: 가지 메타데이터 파일. *(정본 경로: `/gaji/<가지ID>/gaji.toml`)*  
  - 레거시 입력 별칭(권장하지 않음): `pack.toml`
- **팩(정본, D-팩)**: 데모/검증/진단/기대값을 함께 담는 **D-PACK** 단위.  
  - 대표 별칭: D-PACK
  - 레포 표준 위치: `/pack/<팩ID>/...`
- **걸음길(정본)**: 튜토리얼/고개별 학습 경로 모음.  
  - 대표 별칭: walks
  - 레포 표준 위치: `/walks/<고개ID>/<walkXX>/...`
- **솔루션(정본)**: 여러 가지/팩/걸음길을 묶어 하나의 결과물을 만드는 “제품/작업 단위”.  
  - 대표 별칭: solution
- **모듬(정본)**: 코드 단위(module). *(대표 별칭: module)*  
  - 레거시 입력(허용, 출력 금지): `모듬`, `module`



## §19 협업/정본 운영 용어

- **Canon Workspace(정본 작업터)**: 정본 관리자가 발행한 작업터 스냅샷(폴더 트리) 1개.  
  예: `workspace_bundle_vX.Y.Z__sha256_<sha256>.zip`을 풀어놓은 레포 상태.
- **PROPOSAL(제안 문서)**: 직접 수정 대신 제출하는 변경 제안서.  
  파일 경로/이유/검증(pack)을 포함해야 한다.



## §NEW (v20.4.1) 또니랑 스튜디오 ‘실험대 UI’ 용어

> 주의: `메03. 결정적 부름글 실험대(LLM 실험 재현)`(ROADMAP/DEMO에서 쓰는 말)과 혼동하지 말 것.  
> 여기의 **실험대 UI**는 “교과/탐구 데모를 같은 껍데기에서 실행/관측/리플레이”하기 위한 **공통 UI 레이아웃**을 뜻한다.

- **실험대 UI(정본)**: 코드(또는 덧댐)·보개(실험창)·패널(교과판/조작반/계기판)·타임라인(마디/샘 마커)을 한 화면에 묶는 “공통 껍데기”.
  - 대표 별칭: lab bench, studio bench
  - 결정성 원칙: UI 조작 결과는 **샘(InputSnapshot)** 으로만 봉인되어 `샘 → 이야기 → 누리` 경로로만 반영된다.

- **교과판(정본)**: 단원/차시/목표/핵심개념/오개념/질문(프리셋 입력샘 링크)을 보여주는 “교과 모드 패널”.
  - 원칙: 교과판 자체는 “표현/안내”이며, 세계 상태를 직접 바꾸지 않는다.

- **조작반(정본)**: 슬라이더/토글/버튼으로 “실험 조건”을 바꾸는 조작 패널.
  - 원칙: 조작은 곧바로 상태를 바꾸지 않고, **샘 생성(봉인)** 으로만 기록된다.
  - (선택) **잠금(교사용)**: 도입/정리 모드에서 조작을 제한하여 학습 흐름을 고정할 수 있다.

- **계기판(정본)**: 그래프/표/지표 카드 등 “관측/측정 결과”를 보여주는 패널.
  - 원칙: 계기판은 상태에서 **결정적으로 파생된 표시**만 한다(샘에 의존하지 않는 한).

- **증거핀(정본)**: 그래프 구간/특정 시점을 “증거”로 찍어 student_sheet/teacher_notes에 첨부하는 표시.
  - 대표 별칭: pin, evidence pin

### 6.X 누리 쿼리/군집 실행 (W25)

| 정본 | 뜻 | 대표 별칭 |
|---|---|---|
| **여기에서_찾기** | 조건 기반 임자 검색(query) | 검색하기, query |
| **각각_돌며** | 임자묶음에 대해 군집 실행(for_each) | 모두에게, for_each |
| **체** | 쿼리 조건 필터(filter) | 거름망, 필터 |
| **임자묶음** | 임자들의 불변 묶음(collection) | 개체목록 |
| **포함이름씨** | 컴포넌트 포함 조건(with_component) | 필수컴포넌트 |
| **제외이름씨** | 컴포넌트 제외 조건(without_component) | 제외컴포넌트 |
| **포함알** | 태그 포함 조건(with_tag) | 필수태그 |
| **제외알** | 태그 제외 조건(without_tag) | 제외태그 |

### 표준 가지(stdlib) 패키지 분할 (DR-089)
- 표준 라이브러리는 gaji 패키지로 분할하여 제공한다.
  - `gaji/std_text`, `gaji/std_charim`, `gaji/std_math`, `gaji/std_map`, `gaji/std_logic`
- 문서/pack의 정답 예제는 정본 이름만 사용한다(별칭은 호환/이행 목적).


## 용어 표준화 v1 (DR-097)
- 임자(entity)
- 임자가리킴(entity ref/handle)
- 임자무리(entity set/collection)
- 붙이(component)
- 임자-붙이 짜임(ECS)
- 임자-붙이 틀(ECS framework, 별칭)
- 매김이(binder)
- 매마디(default binder name)
- 그것(current binder alias)

---

### 칸(슬롯) / 바탕칸표

- **칸(슬롯)**: 어떤 그릇(컨테이너)의 내부에 있는 “이름 붙은 자리”. 전역변수와 달리 **소속(그릇)**이 명확하다.
- **바탕칸표**: `바탕`(루트 그릇)에 존재 가능한 칸 이름(및 형)을 **미리 선언/등록**하는 표.
  - `#바탕숨김`에서 “쓰기(대입)=사전 등록 필수” 규칙을 가능하게 하는 안전장치다.
  - 레거시 별칭: `바탕칸:` (정본 출력은 `바탕칸표:`로 수렴)

---

## 변수/상수/값/선언/초기화 — 정본 순우리말

| 개념 | 정본 용어 | 뜻 |
|---|---|---|
| 변수 (Variable) | **그릇** | 알맹이를 바꿀 수 있는 유연한 공간 |
| 상수 (Constant) | **붙박이** | 한 번 마련하면 다시는 움직이거나 바꿀 수 없는 고정된 그릇 |
| 값 (Value) | **알맹이** | 그릇이나 붙박이 안에 담기는 실체 |
| 선언 (Declare) | **채비** | 공간(그릇/붙박이)의 형식을 갖추는 행위 |
| 초기화 (Init) | **마련** | 외부에서 알맹이를 가져와 채우는 행위 |

용례:
- `그릇채비:` = 변수(그릇) 선언(채비)
- `채비:` = 변수(그릇)/붙박이(상수) **혼합 선언 입력 설탕**
  - `채비:` 안에서 `=`는 붙박이 마련, `<-` 또는 `.`는 그릇 채비로 해석한다.
  - 정본 출력은 `그릇채비:` + `붙박이마련:`으로 분해 저장한다. (SSOT_LANG [GUREUT-DECL-03])

- `붙박이마련:` = 상수(붙박이) 마련(선언+초기화 동시)
- `마련`은 “초기 알맹이 채우기”를 뜻하며, 구현/문법에서는 문맥에 맞게 별도 규칙으로 정의한다.

추가 규칙(정본):
- **붙박이(상수)는 반드시 마련되어야 한다.** (알맹이 없이 “채비만” 하는 붙박이는 허용하지 않는다.)
- 따라서 상수 선언 문장 정본은 `붙박이채비:`가 아니라 **`붙박이마련:`** 이다.
  - 레거시 입력 호환(선택): `붙박이채비:`를 `붙박이마련:`의 별칭으로 허용할 수 있다.

---

## `=`(정의) vs `<-`(대입) — 정본 구분

- `=` : **정의(Definition)** 전용  
  - 셈씨/움직씨 정의, 붙박이마련(상수 정의)에만 쓴다.
- `<-` : **대입(Assignment)** 전용  
  - 그릇(변수) 값 변경, 결과칸 대입 등 “실행 중 갱신”에 쓴다.

---

## 그릇(변수)에서의 초기 알맹이

- 그릇은 바뀔 수 있으므로 “정의(=)” 대상이 아니다.
- 그릇채비에서 초기 알맹이를 함께 주고 싶으면 `<-`로 “첫 넣기”를 표현한다.
  - 예: `그릇채비: { 점수:수 <- 0. }.`

---

## 보개(뷰) 5종 — 교과 확장 최소 집합

> 이름은 working name이며, 커리큘럼/팩 운영의 기준 단위다.

- **보개/2D(평면)**: 도형/벡터/물리 장면용 “공간 캔버스”.
- **보개/그래프(좌표/곡선)**: 함수/시계열/분포/위상평면용 좌표 그래프.
- **보개/표(차림표)**: 행렬/진리표/데이터셋/반복 로그 테이블.
- **보개/글(수식·DDN·풀이·로그)**: 설명/편집/검증 로그/학습지.
- **보개/구조(그물·오토마타·벡터장 규약)**: 노드-간선 그래프, 상태기계, 벡터장/등고선(2D 표현) 등.

메모:
- “지도/연표/의존성 그래프”는 구현상 **보개/구조**로 흡수 가능하다(레이아웃 규약).
- “3D”는 초기에는 2D 표현(투영/슬라이스/등고선)으로 커버하고, 필요 시 별도 3D 보개로 확장한다.

---

## 셈그림 UI/보개 운용 용어(초안)

- **입력원**: 셈그림이 받아들이는 “입력의 출처”. (DDN, 수식 설탕, lesson, 데이터셋 등)
- **입력원 레지스트리**: 여러 입력원을 동시에 관리/전환/오버레이하는 목록.
- **겹**: 보개 오버레이의 단위(=레이어). 표시 순서/의미를 명확히 하기 위한 관리 단위.
- **타임줄**: 재생/정지/스크럽이 가능한 시간 축 UI(뷰 도크).
- **마디**: 타임줄의 이산 스텝(tick). 선택적으로 프레임/샘플 인덱스를 의미.
- **장면**: “현재 상태를 요약한 선언형 결과”. (scene summary JSON 등)

---

## 셈그림 교육 상호작용 용어(초안)

- **보개 동기화(보개맞물림)**: 한 보개에서의 선택/커서가 다른 보개에서 같은 `t/tick` 또는 같은 `id`를 기준으로 하이라이트/추적되는 동작.
- **직접조작(손대기)**: 2D/지도/구조 보개에서 객체를 끌거나 슬라이더를 움직여, 입력원(controls)이 바뀌고 DDN이 재실행(DDN-first)되는 상호작용.
- **정답겹**: 교사/정본/이상 모델의 결과를 담은 겹(레이어).
- **내겹**: 학습자가 작성/수정한 DDN의 결과를 담은 겹(레이어).
- **거울겹**: 정답겹과 내겹을 겹쳐 비교하도록 고정된 교육용 오버레이 구도(“이상 vs 실제”, “세율 A vs B”).

---

## 보개장면(씬 DSL) 용어(초안)

- **보개장면**: DDN 안에서 “시간축 기반 연출(씬)”을 선언하는 특수 블록. 실행 의미를 바꾸지 않고 `scene.v0`로 정본화된다.
- **마디**: 보개장면의 시간 구간 단위. (tick 또는 초 범위)
- **연출동사**: 나타나기/사라지기/그려지기/움직이기/강조하기 등, 씬에서의 선언형 동작 종류.
- **장면물체**: `#제목/#곡선/#점/#진자 ...` 같은 “씬 객체 정의” 태그(working).

---

## 한국어 Manim 확장 아이디어 용어(초안)

- **시간의 조각(책갈피)**: 특정 `tick`의 상태를 `state_hash`와 함께 저장해 두는 “되감기/점프”용 표식.
  - 목적: 타임줄 스크럽/디버그에서 “가까운 책갈피부터 재계산”을 가능하게 함(결정성 유지).
- **해설 트랙(자막/음성)**: 장면 연출에서 텍스트(자막)와 (향후) 음성 합성(TTS)까지 연결 가능한 서술 트랙.
- **만져지는 수식(역조작)**: 2D 보개에서 드래그/조절을 통해 파라미터(특히 `마련` 값)를 역으로 정하고, DDN을 재실행하는 상호작용.

---

## primitive/graph_kind/축 메타 — 확장 용어(초안)

- **primitive**: 2d(space2d)에서 렌더 가능한 최소 도형/명령(선/원/점/…).
- **drawlist**: primitive 목록(도형 명령 배열).
- **graph_kind**: graph 보개의 그래프 종류 식별자(timeseries/xy_line/scatter/histogram/bar/box…).
- **축 메타**: `x_kind/x_unit/y_kind/y_unit`(+label). 오버레이 허용 조건 판정의 기준.

도메인 표현 전략(요약):
- **수학**: graph+table+text 중심(필요 시 2d/structure 보조).
- **경제**: graph_kind(bar/hist/timeseries) + table + structure(인과지도) 조합.
- **화학/생물**: structure(네트워크) + graph(시계열) + 2d/3d(도식/구조) 조합.


---






## 입력/글 표준 함수 용어(추가)

- **입력키**: 현재 샘(InputSnapshot)에서 “마지막 입력 키”를 글로 얻는 표준 함수. compat에서는 미정의 시 빈 글을 반환할 수 있다.
- **입력키?**: 입력키의 옵션 반환 버전(없음/있음).
- **입력키!**: 입력키의 엄격 버전(없으면 오류).
- **글바꾸기**: 글의 특정 인덱스 문자를 새 글로 교체하는 표준 함수(안전: 범위 밖이면 원본 반환).
- **글바꾸기!**: 글바꾸기의 엄격 버전(범위 밖이면 오류).

## 열림(open) 기록 용어(추가)

- **site_id**: 열림(open) 호출 위치 식별자. replay 매칭의 기준이므로 결정적으로 생성한다.
- **key**: 열림(open) 입력 식별 키. open_kind별 생성 규칙을 따른다.
===== END SSOT_TERMS_v20.6.33.md =====
===== BEGIN SSOT_DECISIONS_v20.6.33.md =====
# 또니랑 SSOT — DECISIONS (v20.6.33)

이 문서는 우리가 논의하며 채택한 **결정(Decision)과 채택 사유(Rationale)**를 모아둔 “결정 기록”이다.  
규칙의 정본 텍스트는 각 SSOT 문서에 있고, 여기서는 **왜 그렇게 했는지**를 남긴다.

- 형식: `DR-XXX` (Decision Record)
- 상태: `채택` / `보류` / `대체`  
- 링크: 관련 SSOT 문서/규칙 ID

---

## DR-001 — 순우리말 정본 + 별칭(영문/기존어) 체계

- 상태: 채택
- 핵심: **문서/예시/AI 출력은 순우리말 정본**, 입력에서만 별칭을 허용(정규화).
- 근거:
  - 어린이/초심자에게 학습 비용↓
  - AI 덧댐/검증에서 “같은 뜻 다른 단어”로 인한 흔들림↓
- 관련:
  - `SSOT_LANG_v20.6.33.md` TERM-LINT-01, TERM-MAP-01
  - `SSOT_TERMS_v20.6.33.md`

---

## DR-002 — 글–마디–토막 3단 구조(토막 `{}` 도입)

- 상태: 채택
- 핵심: 글↔마디 사이/안에 **더 작은 묶음 단위**로 `토막`을 둔다.
- 근거:
  - AI가 “부분 수정”을 할 때 가장 작은 안정 단위가 필요
  - 사람도 “여기만 고치자”가 쉬움
  - 파이프/조건/계약을 토막 경계로 묶으면 의미가 덜 새나감
- 관련:
  - `SSOT_LANG_v20.6.33.md` THUNK-01(토막), PIPE-THUNK-01, PIPE-THUNK-02

---

## DR-003 — 조사 경계 `~` 자동 삽입(JOSA-SPLIT)

- 상태: 채택
- 핵심: 입력은 `사과를`처럼 붙여도 되지만, 정본 출력은 `사과~를`처럼 **경계를 드러낸다**.
- 근거:
  - 한국어 네이티브 문장 흐름을 살리되, 파서/AI가 안정적으로 분해 가능
  - 모호할 때는 오류(FATAL)로 “조용한 오해”를 차단
- 관련:
  - `SSOT_LANG_v20.6.33.md` JOSA-SPLIT-01

---

## DR-004 — 파이프 연결에서 `-서` 금지, `~기/~하기 해서`만 허용

- 상태: 채택
- 핵심: `-서`는 한국어 자연어의 연결 어미 `-서/-어서`와 충돌이 커서 Gate0에서 **문법 오류(FATAL)**.  
  파이프/연결은 `~기 해서` 또는 `~하기 해서`만 사용한다.
- 왜 “아직 레거시 코드가 없는데도” 이렇게 강하게 금지하나?
  - **형태 충돌이 너무 큼**: `-서`는 일상 한국어에서 원인/연결을 만드는 매우 흔한 어미라, “자연어 설명”과 “코드 연결”이 섞일 때 경계가 쉽게 무너진다.
  - **파서/정본화 결정성**: `미분해서/미분 해서/미분-해서` 같은 변형이 자연스럽게 나오고, 띄어쓰기/어절 경계 추정이 흔들리면 정본화·진단이 어려워진다.
  - **AI 생성 안정성**: LLM이 자연어 문장 끝의 `-서`를 “연산/파이프”로 오인하거나, 반대로 파이프를 자연어로 흘려버리는 사고가 많다.
  - **도구 UX**: `~기 해서`/`~하기 해서`는 “행위(동사) → 연결”이 눈에 보여 IDE가 Fix-it/자동완성으로 유도하기 쉽다.
- 관련:
  - `SSOT_LANG_v20.6.33.md` CONNECTOR-01
  - `SSOT_LANG_v20.6.33.md` PIPE-01, PIPE-02

---

## DR-005 — 결정성(Closed) 기본 + 느슨한(Open) 모드 지원

- 상태: 채택
- 핵심: 기본은 **무쇠(결정)** 또는 **주사위(시드 결정)**.  
  탐색/창작을 위해 **열림(Open)**을 선택 가능하지만, 기록(trace)을 남긴다.
- 근거:
  - 수학/물리/경제 시뮬레이션에서는 재현이 핵심
  - 이야기/창작에서는 “느슨함”이 생산성
- 관련:
  - `SSOT_TOOLCHAIN_v20.6.33.md` LEVEL-01 (무쇠/주사위/열림)
  - `SSOT_TOOLCHAIN_v20.6.33.md` REPRO-01, REPLAY-01

---

## DR-006 — AI‑aware 기능(진단/격리/재현/핀)

- 상태: 채택
- 핵심:
  - `??()`로 SSOT/사용자 입력을 **안전한 형태로 추출**
  - `!!{}` 고정 블록으로 “건드리면 안 되는 계약”을 보호
  - repro/diag/state_hash로 **재현성과 디버깅**을 강화
  - origin invalidation + agent isolation으로 **오염 확산**을 막는다
- 관련:
  - `SSOT_TOOLCHAIN_v20.6.33.md` AI-AWARE-* 섹션
  - `SSOT_INDEX_v20.6.33.md` AI-aware 요약

---

## DR-007 — 또니랑누리 ‘마법세계 게임’은 최상위 목표 중 하나

- 상태: 채택
- 핵심: 언어/플랫폼/도구는 “마법 언어로 세계를 조작하는 게임”을 **실제 데모 목표**로 삼아 설계한다.
- 근거:
  - 이야기 지향/어린이 지향/수학·시뮬레이션 지향을 한 곳에 묶는 최적의 통합 목표
- 관련:
  - `SSOT_ROADMAP_CATALOG_v20.6.33.md` “말힘 = 누리 API” 구상
  - `SSOT_DEMOS_v20.6.33.md` 또니랑누리 데모(추가)

---

---

## DR-008 — 셈씨/움직씨 호출은 “인자 선행”을 정본으로 유지

- 상태: 채택
- 핵심: 호출/정의 모두에서 **인자(수식어)는 앞에**, 머리(이름)는 뒤에 둔다.  
  정본: `(인자...) 이름` / `(x:타입, y:타입) 이름:… = …`
- 근거:
  - 한국어(SOV) 흐름과 파이프(흐름 값) 주입 규칙이 잘 맞는다
  - `이름(…)`는 FieldSpec으로 예약되어 있어, 호출과 충돌을 원천 차단
  - AI 생성 시 “어느 괄호가 무엇인지”가 흔들리지 않는다
- 비고(권장): 어린이/수학 표기는 **표기 모드(IDE/뷰)** 와 **정본화기 입력 다리(SYNTAX_BRIDGE)** 에서 제공한다.
  - 예: 화면/입력 `10 더하기 5` ↔ 정본 `10 + 5` (또는 `(왼=10, 오른=5) 더하기.`)
  - 주의: `기호~말별칭`(예: `+~더하기`) 표기는 **이음씨 정의 헤더 전용**이며, 일반 계산 표기에서는 `A + B`처럼 기호만 쓴다. (별칭은 입력 허용/정본화 대상)
- 관련:
  - `SSOT_LANG_v20.6.33.md` FieldSpec/PinSpec 규칙
  - `SSOT_LANG_v20.6.33.md` 중위 연산자(별칭 가능)

---

## DR-009 — Named args는 `핀=값`을 정본으로, `:`는 핀 고정으로만

- 상태: 채택
- 핵심:
  - 정본: `핀=값`
  - 금지(정본에서): `핀:값` (콜론은 **핀 고정 접미**와 충돌)
- 근거:
  - `:`는 타입 표기/필드 표기와도 연상이 강해, 혼동을 비용으로 만든다
  - `=`는 이미 대입/지정 계열이라 named arg와 결이 맞다
- 관련:
  - `SSOT_LANG_v20.6.33.md` CALL-NAMED-ARGS-01
  - `SSOT_LANG_v20.6.33.md` PUNCT-01(`:`의 용도 제한)

---

## DR-010 — 지도/공간 데이터는 “태그 묶음 + 특수블록” 패턴으로 확장

- 상태: 채택(구상 반영)
- 핵심: `지도#geojson{…}` 대신 `(#geojson) 지도{…}`를 정본으로 쓴다.
- 근거:
  - 특수블록은 이미 `(#tag) 수식{…}` 패턴을 쓰므로 일관성이 높다
  - 다중 태그/설정(예: `(#geojson #v1 #tile)`) 확장이 쉽다
- 관련:
  - `SSOT_LANG_v20.6.33.md` TagBundle 규칙(특수블록)
  - `SSOT_ROADMAP_CATALOG_v20.6.33.md` 지도/연표 구상

---

## DR-011 — “이름표”는 값으로(원자 `#…`) 두고, 문법 라벨은 Gate0에서 추가하지 않음

- 상태: 채택
- 핵심:
  - 값: `#또니`, `#누리` 같은 **원자**를 ID로 사용
  - 구조: `{ 이름표=#또니, … }`처럼 필드로 담는다
- 근거:
  - 문법 라벨을 늘리지 않아도 대부분의 참조/연결/덧댐이 가능
  - Gate0 파서 단순성 유지 + 미래 확장 여지 확보
- 관련:
  - `SSOT_LANG_v20.6.33.md` 원자(`#이름`) / 태그 합

## DR-012 — 정본 이름/세계관/교육 톤 (또니랑)

- 상태: 채택
- 핵심:
  1) 정본 이름은 **‘또니랑’**으로 고정한다.
  2) 기본 배경은 **현대**와 **고려-조선 변경기(전환기)** 2개 시간 겹을 오간다.
  3) 세계의 “작동 방식”은 **마법 × 과학**이 혼재(규칙/실험/공학적 사고)한다.
  4) 서술/설명 톤은 **탐구·설명형 교육 톤**으로 간다.
- 근거:
  - 이름 고정: 브랜딩/검색/문서 일관성 유지, 독자 혼란↓
  - 2-겹: 같은 문제를 시대별 기술/가치관으로 비교해 “생각의 재료”를 늘릴 수 있음
  - 마법×과학: 관찰→가설→검증의 루프를 서사에 자연스럽게 끼워 넣기 쉬움
  - 탐구형 톤: 이야기 흐름을 해치지 않으면서도 개념/원리를 “선택적으로” 학습 가능
- 결과(운영 규칙):
  - 각 에피소드는 필요하면 앞에 `[현대]` / `[전환기]` 태그를 붙인다(혼재 시 둘 다).
  - 본문은 서사를 우선하고, “개념 박스(선택 읽기)”로 설명을 분리한다.
  - 역사 파트는 디테일 과장/변형이 가능하되, 민감 요소는 안전하게 처리한다.
- 관련:
  - `SSOT_MASTER_v20.6.33.md` (핵심 중심축)
  - `SSOT_TERMS_v20.6.33.md` (용어: 또니랑)


## DR-013: 고름씨(태그) 생성에서 이름 인자 허용

- **결정:** `#태그(...)` 생성 문법에서 `필드=값` 형태의 **이름 인자**를 허용한다.  
  - 위치 인자: `#공격(주인공, 10)`  
  - 이름 인자: `#공격(대상=주인공, 피해=10)`
- **규칙:** 위치 인자와 이름 인자는 **혼합 금지**. (예: `#공격(주인공, 피해=10)` 금지)
- **정본/ABI:** 이름 인자는 입력 순서가 자유지만, 내부 표현(정본)은 **필드 정의 순서(ABI)** 로 재배치한다.
- **이유:** (1) 어린이/리뷰 친화, (2) 필드 의미가 명확, (3) 기본값/필드 추가 등 미래 확장에 유리.
- **주의:** 모르는 필드/중복 필드/필수 필드 누락은 오류. (기본값 있는 필드는 생략 가능)

## DR-014: 커스텀 조사 ‘붙여쓰기’ 입력은 **선언된 조사**에 한해 Strict에서도 허용, 정본은 항상 `~`

- **결정:** 호출 대상(움직씨/셈씨)이 “조사 인자”로 **명시적으로 선언한 조사 접미(표준+커스텀)**라면, 입력에서 `~`를 생략해 붙여쓴 형태도 **Strict에서도 허용**한다.  
  - Strict 정본(출력): `몬스터~를할라고`  
  - Strict/Loose 입력(편집기/대화): `몬스터를할라고` → (가능하면) 자동 분리 + 정본 제안
- **단서(결정성):** 분해 결과가 **유일**해야 한다. 후보가 2개 이상이면 **“명시 필요” 오류**로 처리하고 `~` 표기를 요구한다.
- **이유:** (1) 결정성은 “유일 분해”로 유지, (2) 개발자/AI가 커스텀 조사 확장해도 파서 부담이 폭증하지 않음(해당 움직씨의 조사 목록만 보면 됨), (3) 사용자 입력 편의.
- **오류:** (a) 선언되지 않은 조사 접미 사용, (b) 분해 후보가 둘 이상, (c) 같은 조사/핀 중복.

## DR-015: `글(화자):`(YAML/대본형) 표기는 **문서/예시 표기**로만 두고, DDN 정본 문법에서는 제외

- **결정:** `글(누리): "..."` 같은 “대본/시나리오” 표기는 **SSOT 데모에서 혼선을 유발**했으므로, DDN 정본 문법 요소로 채택하지 않는다.  
- **대신(정본):** (A) `"누리: ..."` 같은 일반 문자열 + `보여주기`, 또는 (B) `말하기/대사` 같은 표준 움직씨로 명시한다.
- **이유:** 코드/문서 경계가 흐려지면 다른 AI/개발자가 `{}`를 인자처럼 오해하는 사례가 늘었다.

## DR-016: 수식 평가(주입+계산/풀기) 정본은 `해서` 파이프가 아니라 **일반 호출 형태**도 동등하게 인정

- **결정:** 수식 평가(예: `풀기`)는 아래 둘을 **동등한 의미**로 지원한다.  
  - 파이프형: `식 해서 (x=3, y=4) 풀기.`  
  - 일반호출형(권장 정본 예): `(x=3, y=4) 식 풀기.`
- **정본 출력 권장:** “동사로 끝나는 한국어 문장” 형태를 살리기 위해, 가능하면 **일반호출형**으로 정규화한다.
- **주의:** `풀기{...}`처럼 **중괄호를 인자 목록으로 쓰지 않는다.** `{}`는 (1) 정의 몸통, (2) 토막/Thunk, (3) 특수블록 본문에만 쓴다.

## DR-017: `글무늬{...}`는 멀티라인(raw) 본문을 지원하고, 개행은 기본적으로 “의미 있음”으로 보존

- **결정:** `글무늬{...}`는 Gate0에서도 **멀티라인 본문을 허용**한다. (따옴표 1줄만 허용하던 제한을 완화)  
- **원칙:** 개행/공백은 기본적으로 **그대로 보존**한다.  
  - 줄바꿈을 “보기 좋게 나눈 것”으로 취급하고 싶으면, 문서에서 (a) `\`로 줄-이어쓰기, 또는 (b) 별도 태그(예: `(#접기)`)로 모드를 선택한다.
- **이유:** 이야기/교육용 콘텐츠는 긴 글이 많고, `\n` 이스케이프만으로는 작성성이 나쁘다.

## DR-018: ECS 이후 담론(효과/반응/분산)은 “참고”로 두고, 정본은 우리 핵심축으로 재표현

- **결정:** 외부 담론(Effect Handler/Reactive/Distributed)은 유용한 참고지만, SSOT 정본 설계의 축으로 직접 채택하지 않는다.  
  대신 **결정성·거울·샘·계약·승인(+수문장)** 위에서 오해 없이 재표현한다.
- **이유:** 같은 단어가 다른 공동체에서 다른 의미를 갖기 쉬우며, 외부 용어를 정본에 박으면 “결정성 계약”이 흐려질 위험이 크다.
- **결과:** 플랫폼 문서에 “ECS 이후 담론 3축”을 **참고 섹션**으로만 두고,  
  - (A) 밖일(효과) 계열, (B) 눈길(반응) 결정성 체크리스트, (C) 분산/에이전트 입력 봉인 패턴  
  을 우리 용어로 명시한다.

## DR-019: 밖일(Effect) / 할힘(Capability) 로드맵 — Gate0는 계약 수선만, AGE3에서 갈래/할힘으로 확장

- **결정:** “고치기/수선/슬기 협업/외부 I/O”를 모두 **밖일(효과) 계열**로 취급하되,
  - Gate0에서는 **계약 수선(고치기)**만 허용하고(수선 1회 제한 유지),
  - AGE3에서 **밖일갈래(Effect Types) + 할힘(권한/Capability)** 로 확장한다.
- **이유:** Gate0에서 효과 시스템을 과도하게 일반화하면 결정성/구현 복잡도가 급격히 상승한다.  
  반면 “밖일로 분류하고 기록/재연 봉인”만 먼저 못 박으면, 확장(AGE3)이 안전해진다.

## DR-020: AI-aware 훅 6종(관찰/질문/주입/검문/기록/재연)을 플랫폼 표준 접점으로 명시

- **결정:** 비결정적인 AI(슬기)는 코어 안으로 “직접 들어오지” 않고, 아래 **표준 훅 6종**을 통해서만 통합한다.
  1) 관찰, 2) 질문/추론, 3) 의도 주입, 4) 수문장 검문(할힘), 5) 거울 기록, 6) 재연(슬기 재호출 금지)
- **MUST:**  
  - AI 출력은 세계 변경이 아니라 **입력 사건(intent)** 으로만 반영한다.  
  - 반영은 **승인(솎음줄/Q-Chain)** 된 Intent/덧댐으로만 일어난다.  
  - 리플레이는 슬기를 재호출하지 않고 기록된 주입을 재사용한다.
- **이유:** AI 시대의 비용(재현/감사/디버깅)을 언어/플랫폼 차원에서 줄이기 위함이며, 멀티플레이 동기화/치팅 탐지에도 직결된다.


---

## DR-021: `??{...}` 구조화 슬기구멍을 TOOLCHAIN 전처리 입력으로 추가

- 상태: 채택(TOOLCHAIN 전용)
- 핵심:
  - `??("…")`는 빠른 시작에 좋다.
  - 하지만 재현/검증/승인 파이프라인에선 **구조화된 요청**이 더 안전하다.
  - 따라서 `??{...}`를 `??(글무늬{...})`의 **동치(sugar)** 로 허용한다.
- NOTE:
  - 이 sugar는 “중괄호 블록을 편하게 쓰자”는 뜻이다.
  - **템플릿 값을 채워서** 요청을 만들고 싶으면, toolchain에서 평가 가능한 식으로 명시한다:
    - 예: `??((k=v, ...) 글무늬{...})`
  - `??((k=v, ...) 글무늬{...})`는 언어 규칙(특수블록 즉시 렌더)에 따라 `글` 값으로 평가되며, 도구는 이를 그대로 전달한다.

- MUST:
  - `??{...}`는 Gate0 전처리에서 소거되어 런타임(AST/바이트코드)에 남지 않는다.
- 이유:
  - 따옴표/이스케이프/개행 문제를 줄이고, 요청 내용을 정본화(JSON)하여 `prompt_hash`를 안정적으로 만들 수 있다.
- 관련:
  - `SSOT_TOOLCHAIN_v20.6.33.md` AI-PP-STRUCT-01..04

---

## DR-022: AI-aware 대표 데모로 “막대기-쌓기(퍼즐형)”를 추가

- 상태: 채택
- 핵심:
  - 연속 물리 엔진 없이도 가능한 **결정적 안정 판정(중심/지지구간)** 으로, AI-aware 루프(문제생성→운용→검증/재연)를 한 번에 체험한다.
  - 결측치(질량 등)와 폴백(길이로 근사)을 의도적으로 포함해, “정직한 데이터/메타 기록”을 요구한다.
- MUST:
  - 동일 입력 로그/시드면 동일 결과(state_hash)여야 하며, Golden Replay/AI Injection Sort에 얹을 수 있어야 한다.
- 관련:
  - `SSOT_DEMOS_v20.6.33.md` 막대기-쌓기 데모 스펙
  - `SSOT_PLATFORM_v20.6.33.md` LEARN-BOUNDARY-01..03


## DR-023: 머릿말(HeadSpec)로 블록 헤더를 정본화한다 (Gate0 문법 유지 + AST 통합)

### 결정

* **정본(AST)에서는** ‘블록을 여는 헤더’를 모두 **HeadSpec(머릿말)** 노드로 수렴시킨다.
  * 예: `일때`, `늘지켜보고`, `눈길로`, `해보고`, `고르기`, (추가될) `~에 대해:`/`~에게:`류
* **표면 문법은 Gate0에서 급변시키지 않는다.**
  * 즉, 현재의 `(... ) 일때 { ... }`, `(... ) 늘지켜보고 { ... }`, `고르기:` 등은 그대로 둔다.
  * 대신 파서/정본화가 **모두 HeadSpec으로 합성**할 수 있게 SSOT에 ‘통합 모델’을 명시한다.

### 근거

* “헤더/트리거/반응/선택/시간/문맥”을 각각 다른 문법으로 늘리면, 데모·교육·AI보정이 바로 산만해진다.
* 반대로 HeadSpec 하나에 합치면:
  1) 결정성 규칙(순서/순수조건/전파)을 **한 곳**에서만 강제할 수 있고,
  2) “특수블록 + 머릿말씨” 전략과도 잘 결합된다.

### 메모

* HeadSpec의 ‘머릿말씨(HeadWord)’는 **열린 자연어가 아니라 표준 목록**으로 제한한다.
  * 새로운 머릿말씨는 ‘언어 버전 업데이트’로만 추가된다(사용자 코드로 정의 불가).

---

## DR-024: 선택/순회/바인딩은 `~중에 … ~에게:`로 고정하고 `저마다`를 바인딩한다

### 결정

* Gate0에서 “선택+순회”의 표면 문법을 다음으로 둔다:

  * **선택(필터):** `X~중에 {조건}인것들`
  * **순회/바인딩:** `…~에게:`

  예:

  ```ddn
  모든 물체~중에 {저마다.무게 > 5@kg}인것들~에게:
    { ... }
  ```

* `~에게:` 본문에서는 **`저마다`가 현재 원소로 자동 바인딩**된다.
* Gate0에서 `하나하나`는 우선 `저마다`의 별칭으로 허용하되, AGE1+에서 의미 분화 여지를 남긴다.

### 필수 규칙

1. `~중에` 조건 토막 `{…}`는 **순수식**만 허용한다.
2. 열거 순서는 **결정적 정렬키**로 고정한다(예: 엔티티 ID 오름차순).
3. `저마다`는 위 문맥 밖에서 **일반 식별자로 쓰지 않도록 린트 경고**한다.

---

## DR-025: Self 바인딩은 우선 `나`로 정본화하고, 별칭은 추후 결정한다

### 결정

* 이름씨(구조체) 멤버 `셈씨/움직씨` 본문에서 `나`는 해당 인스턴스(self)로 자동 바인딩된다.
* `나`의 별칭(예: `자기`, `이것`)은 Gate0에서 강제하지 않고 **OPEN 이슈로 남긴다**.

### 근거

* 멤버 본문에 self가 없으면 전역/암시 바인딩이 늘고, AI가 틀릴 가능성이 커진다.

---

## DR-026: `불러오기(모듬)` 언어 문법 설탕은 제거하고, 의존성은 프로젝트 메타에서 핀한다

### 결정

* `불러오기(모듬)`는 **언어 문법에서 제거(또는 DEPRECATED)** 한다.
* 모듬/이름공간 선택은:
  * 에디터/런처(UI)에서 추가/삭제하고,
  * **프로젝트 메타**(예: `ddn.project.json` + `ddn.lock`)에 **`모듬 식별자 + 해시 핀`**으로 정본화한다.

### 근거

* “언어 내부 import”는 한국어 표면 문법과도 어색하고, 결정성(재현)과도 충돌 포인트가 많다.
* 반면 “프로젝트 메타 + 해시 핀”은:
  * 10년 운영을 위한 재현/감사/캐시/배포에 유리하고,
  * 파일 1개 toy 언어로 굳지 않게 한다.

### 비고

* 언어 내부에서는 `모듬.이름`(또는 동등한 정본)으로 참조한다.

---

## DR-027: 판정(참거짓) 셈씨는 질문형 이름을 허용하고 `있나기` 강제를 하지 않는다

### 결정

* 표준 라이브러리/사용자 코드에서 **질문형 판정 이름**(예: `있나`, `눌렸나`)을 허용한다.
* 판정 셈씨 호출을 위해 `~기/~하기`를 **강제하지 않는다**.
  * `~기/~하기`는 “동작/연쇄(문장 겹)”에서의 표준 꼬리로 유지한다.

### 정리

* 자주 쓰이는 조건 자리에서는 `{…}인것` 남발을 유도하지 않게,
  * `일때`, `늘지켜보고` 등은 **괄호 조건식 `(조건)`**을 받는 것을 기본으로 한다.

### OPEN

* `눌렸나?` 같은 **물음표 설탕**은 (도움이 될 수 있으나) 토큰/린트 규칙 영향이 있어 AGE1+에서 재검토한다.

## DR-028: 특수블록(글무늬/수식) — 주입을 **앞에 붙이면** 즉시 값으로 평가한다 (특수블록 뒤 `해서/채우기/풀기` 금지)

- **결정:** 아래 특수블록은 **주입(핀묶음)** 이 바로 앞에 붙는 순간, 그 자리에서 “기본 값”으로 **즉시 평가**된다.
  - `(<키=값, ...>) 글무늬{...}` → 결과 타입: `글` *(= 렌더 완료)*
  - `(<변수=값, ...>) (#태그매듭)? 수식{...}` → 결과 타입: `수` *(= 평가/계산 완료)*

- **정본(권장/표준) 표면:**
  - 글무늬(즉시 렌더):  
    `(<키=값, ...>) (#태그매듭)? 글무늬{...}`
  - 글무늬값(변수) 렌더:  
    `(<키=값, ...>)인 무늬 채우기`
  - 수식(즉시 평가):  
    `(<변수=값, ...>) (#태그매듭)? 수식{...}`
  - 수식값(변수) 평가:  
    `(<변수=값, ...>)인 식 풀기`  *(정본; DR-016의 일반호출형도 여전히 허용)*

- **금지(비문/혼선; Gate0 문법 오류):**
  - `글무늬{...} 해서 (<키=값, ...>) 채우기`
  - `글무늬{...} 채우기`
  - `글무늬{...} 해서 () 채우기` *(빈 주입 표면 금지)*
  - `(#tag) 수식{...} 풀기`
  - `(#tag) 수식{...} 해서 (<변수=값, ...>) 풀기`

- **fix-it(정본화기 제안):**
  - `글무늬{T} 해서 (K) 채우기` → `(K) 글무늬{T}`
  - `(#tag) 수식{E} 풀기` → `(주입) (#tag) 수식{E}`  *(주입이 필요한 경우)*

- **사유:**  
  - “`해서 () 채우기`” 같은 비문을 제거하고,  
  - 특수블록이 많아져도 “동사(서술어)를 100개 외우는” UX를 피한다.  
  - 동시에, 결정성(동일 입력→동일 출력) 규칙은 유지된다(단위/반올림/포맷은 결정적이어야 함).

---

## DR-029: `teul-cli ai prompt` 통합 테스트 정책 — Gate0는 구조/불변식, AGE1은 출력 전체 골든까지

### 결정

`teul-cli ai prompt`(TOOLCHAIN §T9.6C)를 **구현/제공**하는 구현체는 아래 테스트 정책을 따른다.

1) **BUNDLE_HASH 단위 테스트 벡터** — MUST  
2) **`ai prompt` 구조/불변식 통합 테스트** — MUST  
3) **`ai prompt` 출력 전체 골든(스냅샷) 테스트** — Gate0: SHOULD, AGE1: MUST

> NOTE: 여기서 “Gate0/AGE1”은 ‘언어 기능’이 아니라 **툴체인 품질 게이트**(CI/릴리스 기준) 구분이다.

### 정의(용어)

- **구조/불변식 통합 테스트**: 출력 전체를 골든 파일로 고정하지 않고, 아래 **불변식**을 검사한다.
  - 헤더/메타가 정본 순서로 등장한다(키 순서 고정)
  - `FILE_LIST`가 묶음의 실제 파일 목록과 정확히 일치한다(이름/순서)
  - `BUNDLE_HASH`가 규칙에 따라 재계산한 값과 일치한다
  - 각 파일 본문이 `BEGIN/END` 경계 마커로 감싸져 있고, `FILE_LIST` 순서와 일치한다
  - 출력이 UTF-8 + LF만 사용하며, **타임스탬프/로컬 경로/OS 정보** 등 비결정 정보가 포함되지 않는다

- **출력 전체 골든(스냅샷) 테스트**: `teul-cli ai prompt --profile lean`의 **출력 바이트열 전체**를 golden 파일로 보관하고, CI에서 1:1로 비교한다.

### 근거(왜 이렇게 나눴나)

- Gate0는 부름글 템플릿/문구가 자주 다듬어질 수 있어, 출력 전체 골든을 **바로 MUST로 두면** 변경 때마다 갱신 비용이 커져 개발 속도가 크게 떨어질 수 있다.
- 하지만 **구조/불변식**(헤더 순서/파일목록/해시/경계/금지 정보 부재)은
  - 결정성(재현),
  - 보안/프라이버시(로컬 경로/환경 노출 방지),
  - LLM 컨텍스트의 기계적 안정성  
  을 위해 “최저선”이므로 MUST로 둔다.
- AGE1부터는 `ddn.patch.json` + 승인 UX + 재현/검증이 “운영 루프”로 들어가며,
  `ai prompt` 출력이 흔들리면 다른 AI/사람이 **근거 문서 자체를 매번 다르게 해석**할 위험이 커진다.  
  그래서 AGE1에서는 `--profile lean` 출력 전체를 골든으로 고정해 **회귀를 즉시 검출**한다.

### 대안(고려했지만 채택하지 않음)

- A안) Gate0부터 출력 전체 골든을 MUST로: 안정성은 높지만, 템플릿 문구 변경 때의 유지보수 비용이 과도할 수 있다.
- B안) 항상 구조/불변식만 검사: 유지보수는 쉽지만, “부름글 텍스트 회귀”가 조용히 쌓여 AGE1 운영에서 비용이 폭증할 수 있다.

### 관련(문서 링크)

- `SSOT_TOOLCHAIN §T9.6C.6` (AI-PROMPT-GOLDEN-01..03)
- `GATE0_IMPLEMENTATION_CHECKLIST` — G0-DOC-06
- `SSOT_ROADMAP_CATALOG` — AGE0/AGE1 체크리스트의 `teul-cli ai prompt`
---

---

## DR-030 — 동시성(병렬) 문법은 Gate0에서 제외, 표면만 예약

- 상태: 채택
- 핵심:
  - Gate0에서 `{...}` 는 **Thunk/블록**이며 “병렬 실행”을 의미하지 않는다.
  - `}하며 / }한채 / }하자마자` 는 **미래 확장용 예약 표지**로 잡아두되, Gate0에서는 파싱 에러(사용 불가)로 둔다.
  - 병렬 실행(Structured Concurrency)은 **AGE3 이후** 별도 설계/정책 결정과 함께 도입한다.
- 근거:
  - 동시성은 우선순위/결정성/에러 전파/취소/자원 경합 등 “정책”이 먼저 필요하다.
  - Gate0에서 이를 넣으면 문법이 아니라 런타임 정책까지 함께 흔들릴 위험이 크다.
  - 대신 표면 토큰을 예약하면, 추후 추가 시 파괴적 변경(기존 텍스트 충돌)을 최소화할 수 있다.
- 결과(언어/도구체인 규칙):
  - Gate0에서 “동시에”는 **서사적 표현**만 허용한다(실행 의미 X).
  - 실제 병렬이 필요하면 **언어 밖**에서 태스크를 분해하고, 결과 합성(머지) 규칙을 명시한다.
  - AGE3 도입 전까지, `{...}` 두 개를 나란히 써도 “동시 실행”으로 해석하지 않는다.
- 관련:
  - `SSOT_LANG_v20.6.33.md` [V18-01]
  - `SSOT_ROADMAP_CATALOG_v20.6.33.md` (동시성/병렬 슬롯)


---

## DR-031: 모드/결정성 2축(Closed/Open × det_tier) + 기능 게이트

- 상태: **승인됨**
- 날짜: 2026-01-07
- 배경:
  - Closed가 코어 정체성이지만, 실험/개발/협업을 위해 Open 영역이 필요함.
  - 프로젝트 단위로 det level을 정하기로 했고, 기능 허용 범위를 엄격히 구분해야 함.
- 결정:
  1) SSOT는 “openness(Closed/Open)” 와 “det_tier(D-STRICT/D-FAST/D-ULTRA)” 를 **직교 축**으로 정의한다.
  2) 프로젝트는 det_tier를 하나 선택하고, 이는 **계약**으로 고정된다.
  3) 모든 고위험 기능은 **Feature Gate(requires.det / requires.open)** 를 선언하고,
     컴파일러/런타임이 위반을 에러로 차단한다.
- 결과:
  - Closed 코어를 유지하면서도 Open 실험을 안전하게 수용.
  - “det ultra에서만 가능한 기능”을 정책적으로 구분 가능.

## DR-032: Closed에서도 키보드/마우스/네트워크 입력 허용 (샘/거울로 봉인)

- 상태: **승인됨**
- 날짜: 2026-01-07
- 배경:
  - Closed라도 실시간 인터랙션(키보드/마우스/패드)과 네트워크(멀티/협업)가 필요함.
  - 단, 결정성은 입력을 “샘(InputSnapshot)”으로 봉인하여 유지해야 함.
- 결정:
  1) Closed에서 키보드/마우스/패드 입력은 **샘으로만** 세계에 들어온다.
  2) 네트워크는 “세계 상태 직접 변경”이 아니라 **입력 릴레이**로만 허용한다.
     - 메시지는 tick-stamped input record로 변환하여 샘/거울에 기록한다.
  3) 리플레이는 기록된 샘을 재주입하여 계약 범위 내 재현을 보장한다.
- 결과:
  - Closed의 정체성을 깨지 않고도 상호작용/멀티 실험 기반 확보.


## DR-033: SSOT 버전과 배포(구현) 버전 분리 + stage 기반 릴리스 스킴

- 상태: **승인됨**
- 날짜: 2026-01-07
- 배경:
  - SSOT는 “규범(스펙)”이고, `teul-cli` 같은 구현/배포는 “제품”이다.
  - 두 버전이 항상 1:1로 일치하도록 강제하면, 스펙/구현/문서/툴이 서로 발목을 잡는다.
  - 반대로 분리하되, 재현·감사·AI 작업에서 혼돈이 없도록 **버전 손잡이(version handshake)** 를 표준화해야 한다.
- 결정:
  1) **SSOT 버전(vMAJOR.MINOR.PATCH)** 과 **배포 소프트웨어 버전(impl/toolchain SemVer)** 은 독립적이다.
  2) 참조 배포(Reference toolchain)는 혼란을 줄이기 위해 `0.<stage>.<patch>`(SemVer) 스킴을 권장한다.
     - `stage=0`은 Gate0(000)
     - `stage=1..99`는 단계(001..099)
  3) 프로젝트/재현 산출물은 아래를 함께 기록한다. (MUST)
     - `ssot_version`, `ssot_bundle_hash`
     - `toolchain_version`(또는 `impl_version`)
  4) `ddn.project.json`은 `ssot_requires`(전제 SSOT 버전)를 포함한다. (MUST)
  5) 도구는 `ssot_bundle_hash` 불일치가 감지되면 기본적으로 실행을 거부한다. (MUST)
     - 우회는 `--unsafe-compat` 같은 명시적 옵션으로만 허용한다. (MAY)
- 결과:
  - 스펙/구현의 속도를 분리하면서도, 재현성과 AI 작업 컨텍스트가 안정된다.


## DR-034: 큰정수/유리수는 표준 가지 타입으로 제공(AGE2+) + 정규형/직렬화 규약

- 상태: **승인됨**
- 날짜: 2026-01-07
- 배경:
  - Fixed64는 시뮬레이션/물리에는 적합하지만, 조합/정수론/정확한 분수 계산에서는 근사 오차가 아쉽다.
  - “작은 코어 + 큰 표준(가지/도구)” 원칙을 유지하면서도 수학적 엄밀성을 확보할 필요가 있다.
- 결정:
  1) `큰정수(BigInt)`와 `유리수(BigRational)`는 **표준 가지(STDLIB)** 로 제공한다. (SHOULD)
  2) `유리수`는 **기약분수 + 분모 양수 + 0은 0/1** 정규형을 강제한다. (MUST)
  3) 직렬화/해시는 정규형 바이트를 기준으로 하여 구현체가 달라도 결정성이 유지되도록 한다. (MUST)
  4) Fixed64/정수64 ↔ 유리수 변환은 명시적 함수로만 허용하고, 반올림 규칙을 고정한다. (MUST)
  5) 물리 틱(마디) 루프의 기본 수치 백엔드는 여전히 `FIXED64_Q32_32`가 정본이다. (MUST)
- 결과:
  - 수학/교육 가지의 “엄밀함”을 확보하면서도, Gate0 코어의 단순성과 성능 원칙을 유지한다.


---


---

## DR-035: 지킴이 집행 순서 고정(위반자 집합 선계산) + Origin 단일 라벨/전파 규칙

- 상태: **승인됨**
- 날짜: 2026-01-07
- 배경:
  - 지킴이(불변식) 위반 시 “마디 전체 롤백”은 Gate0 구현 난이도와 의미론 복잡도를 급격히 증가시킨다.
  - 대신 “커밋 버퍼에서의 출처 기반 폐기(Origin-based invalidation)”를 채택했으나,
    - 위반자를 **어떤 순서로** 집행하느냐에 따라 결과가 달라질 위험,
    - 출처(Origin)가 모호하거나 복수일 때 무효화가 불안정해지는 위험이 남는다.
- 결정:
  1) 지킴이 집행은 **(a) 위반자 집합 V 선계산 → (b) origin∈V 대입 일괄 폐기 → (c) 격리/진단 기록**의 순서로 고정한다. (MUST)
  2) Origin은 **단일 라벨**로만 기록한다(복수 출처 금지). 다중 원인 설명은 diag에만 남긴다. (MUST)
  3) 플랫폼은 평가 컨텍스트에 `current_origin`을 두고, 컨텍스트 내 대입은 기본적으로 `origin=current_origin`으로 전파한다. (MUST)
- 결과:
  - Guard 집행이 **순서 의존성 없이** 재현 가능해지고, AI 교정(덧댐 생성) 시 원인 추적이 단순해진다.
  - “A가 B를 변경한 대입”도 origin 전파로 인해 원인 기반 폐기가 가능해져, 세계 오염을 줄인다.


---


---

## DR-036: 용어 표기 — 정본 1개 + 대표 별칭 0~1개 + 약칭(선택)

- 상태: **승인됨**
- 날짜: 2026-01-08
- 배경:
  - SSOT는 “정본은 순우리말 우선, 기존 업계어는 별칭으로 병행” 원칙을 갖고 있다.
  - 다만 별칭이 과도하게 늘어나면:
    - 문서/UX에서 같은 개념이 여러 이름으로 반복되어 혼란이 생기고,
    - 슬기(도우미)가 출력에서 별칭을 섞어 쓰며 정본화(SSOT化) 품질이 떨어질 수 있다.
- 결정:
  1) 각 용어는 **정본(1개)** 을 가진다. (MUST)
  2) 각 용어의 **대표 별칭은 0개 또는 1개**만 둔다. (SHOULD)
     - 대표 별칭은 **(a) 일상 용어 1개** 또는 **(b) 영문/업계어 1개** 중 하나로 고른다.
  3) 짧은 표기가 필요하면 **약칭**을 둘 수 있으나, 약칭은 “대표 별칭”으로 취급하지 않는다. (MAY)
     - 문서/UX에서 약칭을 쓸 때는, 해당 문서의 첫 등장에만 정식 표기를 함께 둔다.
  4) 과거 표기/동의어는 필요 시 **레거시 입력**으로만 유지하고, 정본 출력에서는 사용하지 않는다. (SHOULD)
- 결과:
  - 문서 일관성이 높아지고,
  - 정본화 파이프(언어/도구)의 출력이 흔들리지 않으며,
  - 외부 검색/호환도 “대표 별칭 1개”로 확보한다.

---

## DR-037: 장르/시각화 이름 정본화 — 말힘누리, 움직이는 셈그림

- 상태: **승인됨**
- 날짜: 2026-01-08
- 배경:
  - “언령게임”은 의미는 맞지만 한자어/일본어 전통(言靈) 말결이 강해, 순우리말 정본 정책과 톤(아이/교육/마법세계)에서 손해가 있다.
  - “Manim”은 외부 생태계 호환을 위해 별칭 유지가 필요하지만, 한국어 정본 이름이 있어야 문서/UX가 자연스럽다.
- 결정:
  1) “언령게임/wordbinding 게임” 계열 장르는 **말힘누리**를 정본으로 한다. (MUST)
     - ‘또니랑누리’는 작품/프로젝트 이름이며, **말힘누리**는 장르/설계축 이름이다.
  2) Manim 트랙의 정본 이름은 **움직이는 셈그림**으로 한다. (MUST)
     - 대표 별칭은 **Manim** 1개만 둔다.
     - ‘셈그림/움셈그림’은 약칭으로만 취급한다.
  3) Q-Chain의 정본 이름은 **솎음줄**로 유지하고, 대표 별칭은 **Q-Chain** 1개로 축소한다. (SHOULD)
- 결과:
  - 순우리말 중심의 브랜드 톤을 유지하면서도,
  - 검색/개발자 호환은 대표 별칭(Manim, Q-Chain)으로 확보한다.


# 부록 A — 세션 총정리(비규범, 공유/복붙용)

이 부록은 이번 세션에서 나온 합의/결정을 **“무엇을(아이디어/제안) → SSOT/결정성 관점 평가 → 채택/수정/보류 결론 → 구현 순서”** 흐름으로 정리한 것이다.  
(중복 메시지는 핵심 주장 기준으로 통합했고, 감탄/수사는 제거했다.)


## DR-038: AGE0 동결 규칙 — Gate0는 “끝내고” AGE1로 간다

**결정**

- Gate0(=AGE0)의 목적은 “기능을 계속 추가”하는 것이 아니라, **결정성·정본·거울·골든(재현)** 을 코드/테스트로 증명하는 것이다.
- `GATE0_IMPLEMENTATION_CHECKLIST`의 **AGE0 항목(A~F)이 충족되면, AGE0 스펙을 동결한다.**
- 동결 이후 신규 논의(새 기능/새 문법/새 타입/새 태그/새 원소 역할 변화)는 원칙적으로 **AGE1 이후 문서(로드맵/기획안/덧댐)** 로만 추가한다.

**AGE0에 허용되는 변경(예외)**

- 버그 수정(명세-구현 불일치)
- 오탈자/중복/모순 제거
- “동일 동작”을 더 엄밀하게 고정하는 명확화(예: 정의/용어 통일)

**이유**

- “좋은 생각이 계속 떠올라 Gate0가 영원히 안 나오는 문제”를 구조적으로 막기 위함.

---

## DR-039: 정본 출력 우선 규칙 — 공유/배포/골든은 canon 출력만

**결정**

- 사람/AI가 어떤 표면형으로 입력하든, 저장/공유/배포/문서/예제/골든 테스트에 들어가는 DDN은
  **`teul-cli canon --emit ddn`의 정본 출력만** 사용한다. (MUST)
- `canon`이 fix-it을 제시하는 경우:
  - 자동 반영하지 않는다. (MUST)
  - 사용자/리뷰어 승인(덧댐 승인 흐름)으로만 반영한다. (MUST)

**이유**

- AI(그리고 사람)는 인자 위치, 조사 바인딩, 공백/줄바꿈 같은 표면 규칙을 반복해서 틀린다.
- “정본화 + fix-it + 승인” 레일을 깔아야, 실수가 프로젝트를 오염시키지 않는다.


---

# 1. 대화의 전제: 또니랑이 지키려는 헌법(변하지 않는 원칙)

우리가 계속 반복해서 지키려던 “최상위 원칙”은 아래 4가지였다.

## 1) 한국어 네이티브 + 교육 친화

- 읽는 순간 이해되는 한국어 어순/용어
- 초등학생~연구자까지 **겹드 UX**(겉은 쉬움, 속은 엄밀)

## 2) 수학적 엄밀함(단위/차원, Fixed64 등)

- “물리/수학 교과서처럼 정확한 세계”
- 타입/단위/차원 오류를 “뒤늦게 런타임에서”가 아니라 **체계적으로** 다루기

## 3) 결정적 세계(재현성 계약)

- 같은 입력이면 **언제 어디서나 동일한 결과**(비트 단위까지)
- 리플레이/감사/포렌식이 가능한 구조

## 4) AI 지향

- 단순히 “AI가 코드 생성”이 아니라  
  **실행 결과 → 진단 데이터 → 재현 → 덧댐 → 검증**의 폐회로(자가교정 루프)까지

---

# 2. 다른 AI가 가져온 4대 제안(“AI-aware” 4종 세트)과 우리의 판단

처음 들어온 제안은 다음 4개였다.

1. **지킴이(Guard/Invariants)**: “절대 깨지면 안 되는 규칙”을 문법으로 선언
2. **기계거울(JSON Diagnostics)**: 실패 원인을 AI가 파싱 가능한 구조로 기록
3. **말글틀(Schema)**: AI가 사용할 수 있는 이름/필드/함수/핀/단위를 미리 알 수 있게
4. **슬기구멍 `??(자연어)`**: 코드 중 일부를 자연어로 쓰면 AI가 결정적 코드로 치환

그리고 우리가 내린 핵심 결론은 이렇다.

## 결론 A: AI-aware는 LANG 코어보다 TOOLCHAIN + PLATFORM에서 먼저 완성하는 게 안전

- 이유: 결정성을 지키려면 **AI가 실행 중(runtime)에 끼어들면 위험**
- 따라서 AI 개입은 **전처리(compile/build time)**와 **디버그/검증(tooling)**로 올리는 게 정답

---

# 3. 채택/수정/보류 결론(정리표)

| 항목 | 최종 결론 | 어디에 둠 | Gate0에서의 상태 |
|---|---|---|---|
| 말글틀 `ddn.schema.json` | 강력 채택(“세계 지도”) | TOOLCHAIN | 필수(Dev) / Release 비의존 |
| 기계거울 `geoul.diag.jsonl` | 강력 채택(구조화 진단말) | PLATFORM+TOOLCHAIN | 필수(state_hash 영향 0) |
| 지킴이 `지킴이{}` | 채택하되 “롤백 금지”로 수정 | LANG+PLATFORM | 검사 시점/집행 규칙 엄밀화 |
| `??("자연어")` | 채택하되 “LANG 코어 X” → 전처리 매크로 | TOOLCHAIN | 런타임 잔존 금지 |
| 결정성 계층(L0~L3) / 무쇠·주사위·열림 | 개념은 좋음 | MASTER/PLATFORM/TOOLCHAIN | Gate0에 강제 X(설명/INFO) |
| `열림 { ... }` 블록 | Gate0 금지 | AGE2+ | Gate0 문법 자체 미제공 |

---

# 4. 지킴이(Guard) 핵심: “롤백 vs 무효화” 봉합

## 4.1 왜 “마디 전체 롤백”이 위험했나

롤백을 허용하면 Gate0가 갑자기 트랜잭션 시스템처럼 무거워진다.

- 어떤 변경이 롤백 대상인지
- 외부 입력(Sam), 로그, 난수, 시스템 보정은 어떻게 취급하는지
- “중간에 기록된 것”은 되돌릴 수 있는지

이를 Gate0에서 정의하는 순간, “가벼운 파서+결정적 실행” 목표가 깨진다.

## 4.2 채택한 해법: Origin(출처) 기반 무효화 + 임자 격리

- 모든 `<-` 대입은 **target(대상)** 뿐 아니라 **origin(출처)** 를 가진다.
- 지킴이 위반이 발생한 임자 `E`가 있으면:
  - 커밋 직전, **Origin=E인 대입을 전부 폐기**
  - `E`는 `#규칙위반` + `휴면(Disabled)`로 격리
  - 진단말(diag)에 남긴다

### 왜 이게 결정적이고 깔끔한가

- “A가 B를 때려서 B.HP가 줄어든 대입”도 Origin을 A로 잡으면 같이 폐기됨  
  → “A만 멈췄는데 B는 맞은 채로 남는” 이상한 세계를 줄일 수 있다.
- 롤백이 아니라 “커밋 버퍼에서 폐기”라 Gate0 구현 난이도도 통제된다.

## 4.3 집행 순서도 고정

- 1) 위반자 집합 V를 먼저 계산
- 2) Origin ∈ V 인 대입을 일괄 폐기
- 3) 그 다음 격리/진단말 기록

## 4.4 Origin 보강(정본급 요지)

- Origin은 **단일 값**이어야 한다(복수 출처 금지)
- 시스템 유발 대입은 `#시스템:<원소>`로 표기  
  예: `#시스템:물리`, `#시스템:초기화`, `#시스템:거울`

---

# 5. “AI-aware 3종 폐회로”로 확장

AI가 **실패를 재현하고**, **관찰하고**, **검증으로 고쳤음을 증명**하는 자가교정 루프를 목표로 했다.

## 5.1 재현묶음 `ddn.repro.json`

- 실패를 재현하는 데 필요한 것들을 묶은 패키지
- Dev에서는 MUST 생성
- Release에서는 MAY(옵션) / 보안·마스킹·암호화는 OPEN_ISSUES로 관리

## 5.2 거울 질의(Observation / Query)

- LANG 문법이 아니라 **TOOLCHAIN 전용**
- 원칙:
  - 무부수효과(Pure)
  - state_hash 영향 0
  - 디버그/도구 전용

## 5.3 검증 러너(골든 테스트)

- `teul-cli test` 같은 러너가 golden 테스트를 수행
- 실패하면 repro 자동 생성
- Open(열림) 모드까지 고려해 **DetTest/TraceTest 분리** 아이디어가 등장
  - DetTest: state_hash 일치(무쇠/주사위)
  - TraceTest: 재현 보장 없으니 “규칙 위반 없음/특정 이벤트 개수” 같은 최소 검증(Open)

---

# 6. “되돌이하고 고쳐” (Replay-driven Self-correction) 제안

- 흐름:
  1) 실패 → diag/repro 생성
  2) 마지막 성공 지점까지 되감기
  3) schema+diag+사용자 피드백으로 AI에게 덧댐 생성 요청
  4) 덧댐 적용 후 test로 검증
  5) 최대 N회 반복
- 결론:
  - 킬러 UX가 될 수 있다
  - 단, 결정성 때문에 **런타임 기능이 아니라 TOOLCHAIN 자동화(AGE1 이후)**로 둔다

---

## DR-040: Gate0 수식 입력 표준은 `ddn.math`( #ascii/#ascii1 )로 고정, `#latex`는 저장/표시 전용

- 상태: 채택
- 핵심:
  - Gate0에서 **평가 가능한 수식 본문 언어**는 `ddn.math`로 정의한다.
  - Gate0 지원 방언:
    - `#ascii` (디폴트): 암묵곱 금지, 곱셈은 `*`만
    - `#ascii1`: 영문 1글자(+숫자 첨자) 변수만 허용 + 암묵곱 허용
  - `#latex`: 본문은 유니코드 허용(표시/복붙/저장 목적). 단 Gate0 실행기에서 `풀기/미분하기/적분하기`는 금지(FATAL).
- 근거:
  - 교육/콘솔/AI 생성 모두에서 “입력하기 쉬운 최소 문법”이 필요
  - 모호성 차단: 암묵곱은 `#ascii1`에서만, 그리고 식별자 제약으로 경계를 선명하게 한다
  - 구현/검증(골든/재현/해시) 난이도를 낮추고, 결정성 계약을 흔들지 않는다
  - LaTeX는 표시층(View)로 남기고, 계산은 MathIR로 통일(§M1 삼층 분리)
- 관련:
  - `SSOT_LANG_v20.6.33.md` §M1, §M2.2
  - `SSOT_TOOLCHAIN` §TC-M1.4 (ddn.math)
  - `SSOT_DEMOS_v20.6.33.md` (Gate0: `#latex`는 저장/표시만)


## DR-041: ddn.math 확장 표기(ddn.math/ext)는 Call + 예약 호출(`sum/prod/diff/int`), Gate0 `풀기`는 core-only

- 상태: 채택
- 결정:
  - Gate0의 “평가 가능한 수식 본문 언어”는 기존대로 **ddn.math/core**로 유지한다. (산술 + 대입)
  - 교과서형 수식 표현을 위해 **ddn.math/ext**(함수호출 + 수열합/수열곱 + 형식 미분/적분)를 예약한다.
    - `#ascii`에서만 의미가 있으며, `#ascii1`은 설계상(1글자 변수 + 암묵곱 전처리) ext를 표현하기 어렵다.
  - Gate0 구현체는 **(권장)** ddn.math/ext를 파싱해서 “수식값 저장/표시/변환”은 허용하되,
    `풀기`(수치 평가)는 **core-only**로 제한한다.
    - 즉, 평가 대상 식에 `Call` 또는 `sum/prod/diff/int`가 포함되면 `FATAL:FORMULA_EVAL_EXT_UNSUPPORTED`.
- 근거:
  - Gate0의 구현 난이도/검증 난이도를 낮추면서도, “수식값”을 1급 값으로 저장/표시/변환하는 길을 막지 않는다.
  - 수열합/수열곱/미분/적분은 표현력이 큰 반면, 결정적 수치 평가(정수 범위 제한, 수렴 규칙, 오버플로 등)를 동반하므로 별도 시즌에서 안전하게 확장하는 편이 좋다.
- 관련:
  - `SSOT_TOOLCHAIN` §TC-M1.4A(core), §TC-M1.4B(ext)
  - `SSOT_LANG` §M1(삼층 분리), §M2(변환 동사)
  - `GATE0_IMPLEMENTATION_CHECKLIST` [G0-MATH-03]



## DR-042: MathIR v1 정본(알맹이) 채택 — 바인딩은 De Bruijn, MathIRDetBin v1 고정

- 상태: 채택
- 결정:
  - `수식값`의 **의미 알맹이**는 MathIR v1로 고정한다.
  - 수식이 상태 해시(state_hash)에 포함될 수 있으므로, MathIR의 직렬화(`MathIRDetBin v1`)는 태그/엔디언/문자열/배열 규칙까지 **완전히 고정**한다.
  - `sum/prod/int`처럼 바인더가 만드는 더미 변수는 이름이 의미가 아니므로:
    - MathIR에서는 **묶인변수 = De Bruijn index**로만 표현한다.
    - 따라서 `sum(i,1,n,i)`와 `sum(j,1,n,j)`는 동일 MathIR로 수렴할 수 있다(α-동치).
  - 가환/결합 연산(`Add/Mul`)은 평탄화 + 정렬로 정규화할 수 있다.
- 근거:
  - “동일 의미 → 동일 state_hash”는 또니랑의 감사/리플레이 핵심 계약이다.
  - 바인딩 변수 이름을 해시에 포함하면 의미는 같아도 해시가 달라져, 캐시/동치성/검증이 불필요하게 깨진다.
- 스펙 위치(정본):
  - `SSOT_TOOLCHAIN` §TC-M1.5 (MathIR v1, MathIRDetBin v1)
  - `SSOT_LANG` §M1 (삼층 분리), §M1.5(요약)


## DR-043: 가지(gaji) 표준 = `/gaji/<가지이름>/gaji.toml` + 빌드 산출물 규약

- 상태: 채택
- 결정:
  - 가지(패키지)는 **repo 표준 폴더** `/gaji/<가지이름>/` 아래에 둔다. (MUST)
  - 가지 메타데이터(정본)는 `gaji.toml` 이다. (MUST)
    - 호환/편의 목적의 `pack.toml`은 **입력 별칭**으로 읽을 수 있다. (MAY)
    - 정본 출력/산출물에는 `pack.toml`을 쓰지 않는다. (MUST)
  - 가지 루트의 표준 하위 폴더:
    - `ddn/` : 소스 루트 (MUST)
    - `쓸감/` : 자원 루트 (MAY)
    - `build/` : 툴체인 산출물(생성물, 수정 금지) (SHOULD)
    - `dist/` : 배포 산출물(생성물, 수정 금지) (MAY)
  - 모듬은 `ddn/<모듬이름>/` 단위로 배치하며, 정규 모듬 ID는 `<가지ID>/<모듬이름>`로 정규화한다. (MUST)
  - 대표 산출물 경로를 SSOT_TOOLCHAIN에서 고정한다. (MUST)
    - `build/canon/**`, `build/registry/alrim.registry.json` 등
- 이유:
  - “패키지(가지)”를 repo에서 **즉시 발견 가능**하게 만들고,
  - CI/재현/배포의 파일 경로 규칙을 고정해 도구/문서/교육이 흔들리지 않게 한다.
- 결과:
  - TOOLCHAIN: /gaji 스캔 규칙 + 산출물 규약 + dist(결정적 아카이브) 권장안을 포함한다.

## DR-044: 알림목록(고름씨) merge 규칙 고정 — 충돌/정렬/해시

- 상태: 채택
- 결정:
  - 모든 모듬(프로젝트 + 전이 의존)의 `알림목록:고름씨 = { ... }.` 선언을 수집하여 **합집합**으로 병합한다. (MUST)
  - 같은 태그가 여러 번 선언되는 것은 허용하되, **스키마가 완전히 동일할 때만** 중복으로 간주해 dedup 한다. (MUST)
    - 스키마 비교는 태그 + 필드(이름/타입/기본값/순서)의 전체 동치로 한다. (MUST)
  - 같은 태그가 서로 다른 스키마로 정의되면 빌드 실패 `E_ALRIM_VARIANT_CONFLICT`. (MUST)
  - 병합 결과(알림 레지스트리)는 아래 정렬 규칙으로 정본 순서를 고정한다. (MUST)
    - 1차: 태그 UTF-8 오름차순
    - 2차: `variant_schema_hash` 오름차순
  - `SignalId`는 정렬된 레지스트리에서의 0 기반 인덱스로 고정한다. (MUST)
  - 레지스트리는 결정적 직렬화(DetBin v1) 후 `alrim_registry_hash = blake3(...)`로 해시 핀을 만든다. (MUST)
  - 해시/레지스트리 산출물 경로는 TOOLCHAIN에서 고정한다. (MUST)
- 이유:
  - 이벤트(알림)를 “닫힌 집합”으로 만들어 정적 검증/리플레이/감사를 가능하게 하되,
  - 모듬 합집합/의존성 변화가 있어도 **결정적** 결과(정렬/ID/해시)가 나오게 한다.
- 결과:
  - `(#태그)할때` / `알리기`의 정적 검증은 이 레지스트리를 기준으로 한다.
  - 빌드 산출물에 레지스트리/해시를 남겨, 런타임/리플레이에서 동일성 검증이 가능해진다.

## DR-045: “꼬리 없는 호출” 진단 + QuickFix 표준화

- 상태: 채택
- 결정:
  - 씨앗(움직씨/셈씨/흐름씨/이음씨 등) 호출 후보가 호출 꼬리 없이 끝나면 오류로 진단한다. (MUST)
    - 형태 A(인자/바인딩이 있는데 꼬리 없음): `E_CALL_TAIL_MISSING_AFTER_ARGS`
    - 형태 B(씨앗 이름만 문장으로 끝남): `E_CALL_TAIL_MISSING_STMT`
  - LSP/IDE는 위 진단에 대해 QuickFix를 최소 2개 제공한다. (MUST)
    - `…하기` 붙이기
    - `…기` 붙이기
  - 정본화기/포매터는 자동으로 꼬리를 삽입하지 않는다. (MUST)
- 이유:
  - “꼬리(말끝)가 실행/연결을 결정한다”는 또니랑 핵심 원칙을 코드 수준에서 강제하고,
  - 실수로 `이동.` 같은 무효 문장을 작성했을 때 조기에 잡아내기 위함이다.
- 결과:
  - TOOLCHAIN: 진단 코드/QuickFix 동작을 규정한다.
  - LANG: 호출/실행 예제는 항상 꼬리를 포함한다.



## DR-046: 말 이음씨(단어 중위연산자) 정식 채택 + 정본화 규칙

- 상태: 채택
- 결정:
  - “기호 없이” 한국어 단어만으로 중위연산자를 정의할 수 있다. (MUST)
    - 예: `A:수 비교:참거짓:이음씨 B:수 = { ... }`
  - 말 이음씨는 표현식에서 그대로 중위로 쓸 수 있다. (MUST)
    - 예: `3 비교 5`
  - 말 이음씨는 “브리지 전용(교육용)”이 아니라, 99걸음 완성판 기준으로 **언어 자체 기능**이다. (MUST)
  - 결정성 보장을 위해, `A <말> B` 형태는 `<말>`이 **이음씨로 정의되어 있을 때만** 중위연산으로 해석한다. (MUST)
    - 그렇지 않으면 문법 오류(또는 해석 불가)로 진단한다.
  - 같은 스코프에서 동일 이름을 이음씨와 다른 씨앗(셈씨/움직씨/값 등)으로 중복 정의하는 것은 금지한다. (MUST)
- 이유:
  - “읽는 순간 이해”되는 한국어 네이티브 표기를 제공하면서도,
  - 임의 추측/암묵 규칙을 늘리지 않고(=정의된 것만 중위로), 파서의 결정성을 유지하기 위함.

## DR-047: 확장 이음기호(EXT_OPCHAR) 고정 + 1~3글자 조합 허용

- 상태: 채택
- 결정:
  - 또니랑은 “아무 기호나” 연산자로 허용하지 않고, **고정된 후보 집합(EXT_OPCHAR)** 만을 이음기호로 인정한다. (MUST)
  - 확장 이음기호 토큰은 EXT_OPCHAR 안에서 **1~3글자(코드포인트) 조합**으로 만든다. (MUST)
  - 렉서는 최장 일치(가장 긴 토큰 우선)로 토큰화한다. (MUST)
  - 주석/대입/비교/시프트 등 이미 의미가 고정된 “예약 토큰”과 겹치는 조합은 금지한다. (MUST)
  - 문서 메타 자리표시자와 충돌을 막기 위해 `〈〉《》`는 코드 토큰으로 금지한다. (MUST)
    - 대안(허용): `⟪⟫`(수학용 이중 꺾쇠)는 EXT_OPCHAR에 포함해, 필요 시 이음기호로 쓸 수 있다. (SHOULD)
  - 정본화기는 이음기호에 섞인 variation selector(예: `▪︎`)를 제거하거나 오류로 처리한다. (SHOULD; 구현 선택)
- 이유:
  - 수학/물리/AI에서 필요한 기호 표현력을 제공하되,
  - “키보드/폰트/유니코드 변형”으로 인해 의미가 흔들리는 문제를 후보 집합 고정 + 정본화로 통제하기 위함이다.
## DR-048: 시스템 자음 약칭(단자음) 예약 — `ㅅ.` = `바탕.`

- 상태: 채택
- 결정:
  - 자음(ㄱ-ㅎ)만으로 이루어진 식별자는 **시스템 예약**으로 둔다. (MUST)
  - 일반 개발자는 씨앗/그릇/타입/핀 이름을 “자음식별자”로 정의할 수 없다. (MUST)
  - 초기 할당(채택):
    - `ㅅ.` 은 `바탕.`의 별칭으로 허용한다. (MUST)
  - 아직 할당되지 않은 자음 약칭은 사용 시 오류로 진단한다. (MUST)
- 이유:
  - `바탕.` 같은 뿌리 이름은 초반 학습/데모에서 자주 반복되며, 길이가 곧 피로도로 이어진다.
  - “자음만의 이름”은 일반 코드에서 거의 쓰지 않으므로(가독성↓), 시스템이 짧은 표기를 안정적으로 쓸 수 있는 공간으로 확보하기 좋다.
  - 사용자가 `ㄱ`, `ㅅ` 같은 이름을 우연히 만들면 IDE/AI가 의미를 오해할 가능성이 커지므로, 금지하는 편이 안전하다.
- 결과:
  - LANG: 자음식별자 정의/허용 위치를 렉서 규칙으로 고정한다.
  - TOOLCHAIN: LSP/QuickFix에서 `ㅅ.` → `바탕.`(또는 그 반대) 스타일 변환은 “옵션”으로만 제공한다. (자동 치환 금지)


---

## DR-049: SSOT 배포물(묶음) 표준화 — `SSOT_ALL` + `gemini10`(≤10 files)

- 상태: 채택
- 결정:
  - SSOT는 “사람이 읽는 문서”이면서 동시에 “도구/AI가 먹는 계약서”이므로, **배포 아티팩트(파일 집합)** 를 표준화한다.
  - 각 SSOT 릴리스는 아래를 함께 제공한다. (MUST)
    1) `SSOT_ALL_v{VERSION}.md` : 올인원 1파일(업로드 제약 대응)
    2) `ssot_bundle_v{VERSION}_gemini10.zip` : 파일 10개 제한을 만족하는 핵심 문서 묶음
    3) `ssot_bundle_v{VERSION}.zip` : 전체 문서 묶음
  - (권장) LLM 컨텍스트 위생을 위해, diff 제외 묶음 `ssot_bundle_v{VERSION}_codex.zip`을 함께 제공한다. (SHOULD)
- 이유:
  - 일부 LLM 플랫폼은 “파일 업로드 개수 제한(예: 10개)” 또는 “1파일만 허용” 같은 제약이 있다.
  - 제약을 회피하려고 임의 요약본/발췌본을 쓰면, 구버전 규칙·레거시 용어가 재유입되는 문제가 반복된다.
  - 따라서 “같은 버전의 SSOT를 **어떤 플랫폼에서도 같은 방식으로** 전달”할 수 있게, *공식 배포물*을 고정하는 편이 안전하다.
- 관련:
  - `SSOT_TOOLCHAIN_v{VERSION}.md` §T9.6D (SSOT 배포 묶음 규약)
---

## DR-050: `pack` 용어 충돌 해소 — `pack/`은 D-PACK 전용, `가지(gaji)`는 package로 고정

- 상태: 채택
- 문제:
  - 과거 문서/대화에서 `pack`이 **(A) 배포/의존 패키지**와 **(B) 데모/검증용 D-PACK** 두 의미로 혼용되어 혼선이 컸다.
- 결정:
  1) **`가지(gaji)` = 배포/의존 “패키지(package)” 단위**로 확정한다.  
     - 별칭(대표): `package`  
     - **`pack`은 가지의 별칭으로 더 이상 쓰지 않는다.** (레거시 입력 호환은 TOOLCHAIN에서만 제한적으로 처리)
  2) **레포 루트의 `pack/` 디렉터리는 D-PACK(데모/검증 꾸러미) 전용**으로 예약한다.  
     - “예제+테스트+diag+expect”를 묶어 재현/검증하는 단위는 앞으로 `pack/` 아래에 둔다.
  3) 가지 메타 파일의 정본은 **`/gaji/<id>/gaji.toml`** 하나로 고정한다.  
     - `pack.toml`은 레거시 입력 별칭으로만 MAY(권장하지 않음).  
     - 도구는 `pack.toml`을 발견하면 **진단 + `gaji.toml`로 rename Fix-it**을 제공한다.
- 이유:
  - D-PACK은 “검증/재현” 흐름의 핵심이라 `pack/` 이름을 살려야 한다.
  - `가지(package)`는 외부 생태계(패키지)와도 의미가 맞고, 검색/문서/팀 커뮤니케이션이 안정된다.
- 관련:
  - `SSOT_TERMS_v20.6.33.md` §18
  - `SSOT_TOOLCHAIN_v20.6.33.md` (가지/워크스페이스 레이아웃)
  - `SSOT_DEMOS_v20.6.33.md` (D-PACK, golden/*.test.json)

---

## DR-051: 작업터(Repo) 표준 상위 폴더 레이아웃(권장) 고정

- 상태: 채택
- 결정(권장 표준):
  - 레포 루트는 아래 상위 폴더 구성을 **권장 표준(SHOULD)**로 둔다.
    - `/gaji/` : 가지(package) 모음
    - `/pack/` : D-PACK(데모/검증/진단/기대값) 모음
    - `/walks/` : 걸음길(튜토리얼/고개별 학습 경로) 모음
    - `/age/` : AGE 단계별 구현/검증 작업터(예: age1/age2/age3)
    - `/ssot/` : SSOT 원문/패치/릴리스 산출물(선택; 레포에서 분리 운영해도 됨)
    - `/docs/` : 레포/솔루션 공통 문서 포털(선택)
- 이유:
  - “규칙(SSOT) / 패키지(가지) / 검증(D-PACK) / 학습(walks)”의 층위를 폴더에서 바로 분리하면, 도구 스캔과 팀 커뮤니케이션이 단순해진다.
- 관련:
  - `SSOT_TOOLCHAIN_v20.6.33.md` WORKSPACE-LAYOUT-*

---

## DR-052: 솔루션(solution) 개념 도입 — “제품/작업 단위”와 “패키지 단위”를 분리

- 상태: 채택
- 문제:
  - 하나의 레포에서 “여러 앱/도구/콘텐츠”를 함께 굴리면, `가지(package)`만으로는 “제품 단위(실행/발행/데모 묶음)”를 표현하기 어렵다.
- 결정:
  - **솔루션(solution)**은 “하나의 결과물(앱/수업/데모 세트/툴체인 확장)”을 만드는 **상위 작업 단위**다.
  - 솔루션은 보통 아래를 함께 가진다:
    - 의존 가지 목록(= 어떤 gaji를 쓰는지)
    - D-PACK(검증/리플레이/데모)
    - walks(학습/튜토리얼)
    - docs(기획/설계/화면/사용자 여정)
  - `가지(package)`는 솔루션에 **포함되는 재사용 단위**이며, 솔루션 자체는 “의존성 배포 단위”로 간주하지 않는다.
- 이유:
  - “배포/재사용(package)”과 “제품/작업(solution)”을 섞으면 버전/해시/릴리스가 불필요하게 흔들린다.
- 관련:
  - `SSOT_TERMS_v20.6.33.md` (솔루션, 걸음길, D-PACK)
  - `SSOT_TOOLCHAIN_v20.6.33.md` (워크스페이스 스캔/빌드 단위)

---

## DR-053: `bogae_hash`는 픽셀 해시가 아니라 DrawList 해시로 고정

- 상태: 채택
- 결정:
  - 보개(Bogae)는 마디 커밋 후 스냅샷을 읽어 **BogaeDrawListV1**(논리 그리기 명령 목록)을 만든다.
  - `bogae_hash = blake3(DetBin(BogaeDrawListV1))` 로 정의한다.
  - **픽셀 해시/스크린샷 해시로 골든을 검증하는 것은 금지**한다. (폰트/AA/브라우저/드라이버 차이로 결정성이 깨짐)
  - DrawList 생성기는 코어(공통) 1개로 두고, 콘솔/웹/2D/3D 백엔드는 drawlist를 **소비(consume)만** 한다.
- 이유:
  - “표현(렌더러)”은 플랫폼마다 달라도 되지만, “의도(무엇을 그리려 했나)”는 결정적으로 고정되어야 한다.
- 관련:
  - `SSOT_PLATFORM_v20.6.33.md` BOGAE-DRAWLIST-*
  - `SSOT_TOOLCHAIN_v20.6.33.md` (MadiFrame.bogae_frames / golden 기대값)
  - `SSOT_DEMOS_v20.6.33.md` (DetTest에서 bogae_hash 검증)

---

## DR-054: 표준 색 이름 팩(ColorNamePack/CSS4/V1) — 대용량 테이블은 SSOT 밖(가지 쓸감)으로

- 상태: 채택
- 결정:
  - 색 이름/별칭(영문 CSS4 + 한국어 별칭) 테이블은 SSOT 본문에 직접 내장하지 않는다.  
    대신 표준 가지의 `쓸감/`로 제공한다.
  - 색의 정본 표현은 `#rrggbbaa`(hex8, 소문자)로 정규화한다. (`#rrggbb` 입력은 `aa=ff`를 붙여 정본화)
  - `white`, `rebeccapurple` 같은 CSS4 이름 및 한국어 별칭은 **ColorNamePack/CSS4/V1**로 해석한다. (이름 해석은 구현 단계에서 SHOULD, 정본 출력은 항상 hex8)
- 표준 위치(권장):
  - `gaji/ddn.std.colors/쓸감/색/COLOR_NAME_PACK_CSS4_V1.detjson`
- 이유:
  - 대용량 데이터는 버전/해시가 자주 흔들리므로, 규범(SSOT)과 데이터(가지)를 분리해야 한다.
- 관련:
  - `SSOT_LANG_v20.6.33.md` COLOR-LIT-*, COLOR-PACK-*
  - `SSOT_TOOLCHAIN_v20.6.33.md` (가지 쓸감 로딩)


---

## DR-055: DrawListV1(BDL1) 커맨드 집합은 동결, Circle(원) 계열은 V2(BDL2)로 이월

- 상태: 채택
- 결정:
  1) `BogaeDrawListV1`의 커맨드 집합은 **최소 프리미티브**로 동결한다. (MUST)
     - V1 포함: `Clear`, `RectFill`, `RectStroke`, `Line`, `Text`, `Sprite`
     - V1 제외: `Circle*`, `Ellipse*`, 곡선/패스, 텍스트 레이아웃
  2) 원/타원 등 곡선 계열 커맨드는 **DrawListV2 + DetBin 매직 BDL2**에서 도입한다. (SHOULD)
  3) V1 단계에서 “원” 표현은 생성기(코어 빌더)가 **결정적으로 낮춰서** 만든다. (MUST)
     - 우선안: `Sprite(...)` 사용 (권장)
     - 대안: `Line×N` 근사(고정 N) (허용)
- 근거:
  - 12걸음의 본질은 “보개 파이프라인/해시/골든” 계약 고정이며, 커맨드 확장은 13걸음 이후로 미루는 것이 비용/리스크가 가장 낮다.
  - V1을 뒤늦게 확장하면 BDL1 디코더/백엔드/골든이 함께 흔들린다.

---

## DR-056: 픽셀 정수 강제는 DrawListV1의 모든 `*_px` 필드에 MUST, 서브픽셀은 V2로

- 상태: 채택
- 결정:
  1) `BogaeDrawListV1`의 모든 픽셀 필드(`x_px, y_px, w_px, h_px, thickness_px, size_px, ...`)는 **반드시 정수**여야 한다. (MUST)
  2) DrawListV1에 소수 픽셀 값이 들어오면 `E_BOGAE_NON_INT_PIXEL`로 실패한다. (MUST)
  3) 누리/상태는 `Fixed64` 등 연속 좌표를 가질 수 있으나, DrawList로 내려오는 경계에서 **생성기(코어 빌더)가 결정적으로 정수화**해야 한다. (MUST)
     - “정수화 규칙(라운딩)”은 V1에서 **정본으로 강제하지 않는다**. (MAY)
     - 다만 Walk12/12팩 준수 모드에서는 “정수화 없이 들어온 비정수 픽셀”은 오류로 본다. (MUST)
  4) 서브픽셀(고정소수점) 표현은 DrawListV2(BDL2)에서 별도 타입/필드로 설계한다. (SHOULD)
- 근거:
  - 초기 단계에서 픽셀 정수는 백엔드(콘솔/웹) 간 해석 차이를 줄여 골든/디버그 비용을 크게 낮춘다.
  - 연속 좌표/고급 렌더 품질(AA/서브픽셀)은 계약이 안정된 뒤(V2) 확장하는 것이 안전하다.

---

## DR-057: `gaji/`는 “정식 가지”만, 솔루션/씨앗은 `/solutions` 또는 `/seed`로 분리 + 스캔 경고

- 상태: 채택
- 결정:
  1) `gaji/` 하위 1-depth는 **정식 가지(package)** 만 둔다. (SHOULD)
     - 정식 가지 최소 조건: `gaji.toml` + `ddn/` (MUST)
  2) 제품/작업 단위(솔루션), 템플릿/씨앗 묶음은 `/solutions/<id>/...` 또는 `/seed/<id>/...`로 분리한다. (MAY)
  3) `teul-cli scan`은 `gaji/*/` 중 `gaji.toml`이 없는 디렉터리를 발견하면 경고(diag)해야 한다. (SHOULD)
     - 권장 코드: `W_SKIP_NON_GAJI_DIR`
  4) `/solutions/<id>/solution.toml`(또는 `solution.json`) 같은 “솔루션 매니페스트”는 선택 표준으로 둔다. (MAY)
- 근거:
  - `WORKSPACE-SCAN-01`의 기본 스캔이 `gaji/*/gaji.toml`만 대상으로 하므로, `gaji/`에 솔루션/초안 폴더가 섞이면 “조용히 스킵”되어 혼선이 반복된다.

## DR-058: Canon Workspace + PROPOSAL-only + 메시지 머리말 + WIP 동결(운영 규범)

**상태:** Adopted (v20.4.1)  
**요지:** SSOT가 안정된 이후에는 “언어 규범”만으로는 협업이 꼬이기 쉽다.  
따라서 정본 작업터(Canon Workspace)를 고정하고, 직접 수정 대신 PROPOSAL로만 제출하며,
모든 메시지에 SSOT/Workspace 버전·해시 머리말을 붙이고, WIP 걸음 계약을 동결한다.

- Canon Workspace: 정본 관리자가 발행한 `workspace_bundle_vX.Y.Z__sha256_<sha256>.zip`
- 직접 수정 금지: (SSOT 수정 세션 제외) 변경은 `PROPOSAL_*.md`로만 제출
- 메시지 머리말: `SSOT_ALL`, `Workspace`, `Date`를 상단에 명시
- WIP 동결: 진행 중 걸음 계약을 깨는 변경은 `[DEFER_TO_STEP13+]`로 이월

**이유:** 여러 세션/여러 AI가 동시에 움직일 때 “정본이 무엇인지/어디를 바꾸는지/검증은 무엇인지”가 흐려져
구현이 엇갈리는 문제가 반복되었기 때문.

---

## DR-059 — W13/W14 보개(Viewer) 전략 정합화: W13=웹 첫 화면, W14=헤드리스 정합, ASCII=개발편의

- 상태: 채택
- 핵심:
  - **W13(첫 화면)**: BDL1(DetBin) 기반 DrawList를 **웹(Canvas) 뷰어**로 렌더해 “첫 화면”을 제공한다. (MUST)
  - **W14(정합/헤드리스)**: UI를 띄우지 않는 `--no-open` 실행에서 `bogae_hash` 및 `cmd_count`를 **결정적으로** 출력해 정합성을 확인한다. (MUST)
  - **콘솔 ASCII 렌더**는 유지보수 비용이 크므로 필수 요구사항이 아니다. 개발 편의 기능으로만 둔다. (MAY)
- 범위/비고:
  - 본 결정은 12걸음(BOGAE/DrawList/색팩) 계약을 깨지 않는다. (W13/W14 이후 범위)
  - Circle/서브픽셀은 V2(BDL2) 이월 유지.
- 관련:
  - `SSOT_TOOLCHAIN_v20.6.33.md` 보개(Viewer) 모드/헤드리스 출력 규칙
  - `SSOT_DEMOS_v20.6.33.md` expected_bogae_hash 기반 골든(픽셀 해시 금지)

---

## DEC-20260118-TERMS-01: 생김새/특성/보개_바탕 키 정본화 (별칭 유지)

- 상태: **ACCEPTED**
- 날짜: 2026-01-18
- 근거: `context/proposals/PROPOSAL_TERMS_SHAPE_TRAIT_CANVAS_2026-01-18.md`

### 결정
- (정본) `모양` → `생김새`
- (정본) `모양.트레잇` → `생김새.특성`
- (정본) `bogae_canvas_w/h` → `보개_바탕_가로/보개_바탕_세로`

### 호환/정본화 규칙
- 레거시 표기는 **입력으로 허용**한다(별칭).
- `teul-cli canon`/실행 파이프라인은 **출력/내부 AST를 정본으로 수렴**할 수 있다(원본 파일 변경 아님).
- 원본 파일 자동 수정은 금지. 필요 시 `ddn.patch.json` 제안 + 승인으로만 적용.

### DoD
- SSOT_LANG TERM-MAP에 해당 별칭이 `legacy_terms`로 포함된다.
- 문서/예제는 정본 표기(생김새/특성/보개_바탕_*)를 우선 사용한다.


---

## DEC-20260118-BDL2-01: BDL2 AA(서브픽셀) 의미론 확정

- 상태: **ACCEPTED**
- 날짜: 2026-01-18
- 범위: `WALK22 (BDL2 detbin/AA 플래그 정책)`

### 결정
- detbin 좌표/두께 타입은 FixedQ24.8로 유지한다.
- 커맨드 `flags bit0=AA`는 **소수부 의미 유무**를 고정한다.
  - AA=1: 소수부 유지(서브픽셀 좌표 의미 있음)
  - AA=0: 정수 스냅(소수부 무시, `raw & ~0xFF`)
- 콘솔 렌더는 AA와 무관하게 항상 정수 스냅으로 렌더한다.

### DoD
- `walks/gogae2/walk22/SPEC.md`에 위 의미론이 문서로 고정되어 있다.
- `walks/gogae2/walk22/GOLDEN_TESTS.md`에 AA=0/1 케이스가 포함되어 있다.

## DEC-20260118-REPORTS-01: 구현 보고서 정본 경로 고정

- 상태: **ACCEPTED**
- 날짜: 2026-01-18

### 결정
- 보고서 정본 위치는 `docs/reports/impl/`로 고정한다.
- `docs/context/reports/`는 안내(리다이렉트)만 유지한다.

### DoD
- `docs/context/reports/README.md`가 정본 경로를 안내한다.

---

## DEC-20260119-W25Q-01: W25 Phase 1 누리 쿼리/군집 실행 API 정본화

- 상태: **ACCEPTED**
- 날짜: 2026-01-19
- 근거: `context/proposals/PROPOSAL_W25_QUERY_API_v2_2026-01-19.md`

### 결정
- 표면 문법 `모두 {}`는 SSOT_LANG 정본 확정 전까지 **의사 코드**로 유지한다.
- W25(AGE0/고개3)에서는 먼저 Phase 1 런타임/표준 가지 API로 제공한다:
  - `(조건:체~를, 정렬기준:글~으로~로? = "기본") 바탕.여기에서_찾기:움직씨:임자묶음`
  - `(대상묶음:임자묶음~을~를, 실행할것:움직씨~를) 각각_돌며:움직씨`
- 쿼리 결과는 (1) 스냅샷 의미론, (2) `(realm_id, entity_id)` 오름차순 안정 정렬을 MUST로 고정한다.

### DoD
- SSOT_PLATFORM에 “누리 쿼리 API” 절이 추가되어 있다.
- SSOT_LANG TERM-MAP에 `쿼리/필터/forEach` 금지어가 반영되어 있다(식별자 위치 FATAL).
- `walks/gogae3/w25_query_batch/SPEC.md`와 `pack/gogae3_w25_query_batch`가 본 결정을 참조한다.

---


## DEC-20260119-GOGAE4-01: 제4고개(기)(34~44) “시간의 거울” 실행 기획 문서 채택

- 상태: **ACCEPTED**
- 날짜: 2026-01-19
- 근거: `context/proposals/PROPOSAL_GOGAE4_TIME_MIRROR_PLAN_v20.1.8.md`

### 결정
- 제4고개(기) 구간(34~44)의 “어떻게 구현할지(티켓/팩/DoD)”는 SSOT 밖 문서로 고정한다:
  - `docs/context/roadmap/gogae4/PROPOSAL_GOGAE4_TIME_MIRROR_PLAN_v20.1.8.md`
- SSOT에는 포인터만 둔다(`SSOT_PLANS §P4.4`, `SSOT_ROADMAP_CATALOG 제4고개 기술 상세 명세 상단`).
- 레포에는 실행 레일을 위해 스켈레톤을 포함한다:
  - `walks/gogae4/w34_*` ... `walks/gogae4/w44_*`
  - `pack/gogae4_w34_*` ... `pack/gogae4_w44_*`

### DoD
- 위 문서/폴더가 실제로 존재한다.
- 제4고개 D-PACK ID 목록이 `SSOT_PLANS §P4.4.2`에 반영되어 있다.

---


## DEC-20260120-BOGAE-BG-01: 보개 배경색 키(바탕.*) 정본화

- 상태: **ACCEPTED**
- 날짜: 2026-01-20
- 근거: `docs/decisions/SSOT_PENDING.md` (2026-01-20), TERM-MAP 정리

### 결정
- 보개 배경색(캔버스 바탕색) 설정 키는 정본으로 `보개_바탕색`을 사용한다.
- 레거시 키 `bogae_bg`는 **허용**하되 LEGACY 경고(추천 출력) 대상이다.
- Canonicalizer는 레거시 키를 정본 키로 **표기 통일**할 수 있다.

### DoD
- SSOT_LANG TERM-MAP에 `bogae_bg → 보개_바탕색` LEGACY 매핑이 존재한다.
- 대표 pack 예제들은 `보개_바탕색`을 사용한다.
- 레거시 키로 작성된 기존 예제도 실행(결정성 해시)에서 동등하게 처리된다.

---


## DEC-20260121-CHARIM-LIT-01: 대괄호 `[]`의 용도 확정 — 차림(결정적 배열) 리터럴

- 상태: **ACCEPTED(표면 표기) / IMPLEMENTATION DEFERRED(파서/런타임)**
- 날짜: 2026-01-21
- 근거: `docs/decisions/SSOT_PENDING.md` (2026-01-21), 텐서/형상 표현 요구

### 결정
- 대괄호 `[]`는 **값 위치**에서만 차림(결정적 배열) 리터럴로 사용한다.
  - `[]`: 빈 차림(빈 배열)
  - `[v1, v2, ...]`: 차림 리터럴(순서=기록 순서)
- `[]`는 **타입 표기**로 사용하지 않는다.
  - `수[]`, `글[]` 같은 표기는 계속 금지한다.
- `<>`(꺾쇠)는 비교 연산(`<`, `>`)과 충돌 가능성이 커서 제네릭/배열 표기로 채택하지 않는다.
- 인덱싱 표면 설탕 `a[i]`는 당장 채택하지 않는다(AGE1+ 논의). 정본 접근은 꼬리 호출로 유지한다:
  - `(대상=a, i=i) 차림.값.`

### DoD
- SSOT_LANG §0 요약에 본 결정이 반영되어 있다.
- W25/고개3 문서에서 `[]`는 “빈 차림(기본값)” 의미로 해석되며, 타입 표기로 오인되지 않는다.

---


## DEC-20260121-CONTAINER-NAMES-01: 차림/값꾸러미 의미 고정(스왑 금지) + 문서 병기

- 상태: **ACCEPTED(용어/의미) / IMPLEMENTATION N/A**
- 날짜: 2026-01-21
- 배경: 텐서/형상 표현 요구, 컨테이너 용어 혼선 제거

### 결정
- **차림**은 “순서 있는 결정적 배열/리스트(list/sequence/array)”를 의미한다.
- **값꾸러미**는 “고정 길이 튜플/레코드(tuple/record)”를 의미한다.
- 두 용어는 **서로 이름을 바꾸지 않는다(스왑 금지)**.
- 문서에서는 교육/표준화 목적의 병기를 허용한다:
  - `차림(배열)`
  - `값꾸러미(튜플/레코드)`

### 텐서 표준안과의 연결(요지)
- **밀집 텐서(dense)**: `형상(shape) + 자료(차림)` 모델을 기본으로 한다.
- **희소 텐서(sparse)**: `형상(shape) + 자료(짝맞춤)` 모델을 기본으로 한다.
  - 키(인덱스 값꾸러미)의 순회/직렬화는 **사전식(정준) 정렬 MUST**.

---

## DEC-20260121-SUGAR-01: 표면 설탕(가독성) — `아니고 … 일때`, `(… 아님)`

- 상태: **ACCEPTED(표면 표기) / CANON-ONLY(전개) / PARSER DEFERRED**
- 날짜: 2026-01-21

### 결정
- `아니고 (조건) 일때 { ... }`를 elif 표기로 허용한다.
  - 정본 전개는 **중첩 `아니면 { (조건) 일때 { ... } }`**로 고정한다.
- `(조건 아님)`을 postfix 부정 표기로 허용한다.
  - 정본 전개는 `{ 조건 }아닌것`과 동치로 취급한다.
- 기호 `!` 부정은 Gate0에서 채택하지 않는다(보류).
- `+=`, `-=` 복합 대입은 **PENDING**으로 남긴다(표면 치환 실험은 가능).

### DoD
- `SSOT_LANG §SUGAR`에 전개 규칙이 명시되어 있다.
- canon 결과(정본 AST)는 기존 표기와 동일하며, `state_hash`에 영향을 주지 않는다.

---

## DEC-20260121-TENSOR-CANON-01: 텐서 리터럴(중첩 차림) — 설탕 / 정본=형상+평탄자료

- 상태: **ACCEPTED(설탕 입력) / CANON-ONLY(전개) / PARSER DEFERRED**
- 날짜: 2026-01-21

### 결정
- 중첩 차림 표기 `[[...],[...]]`는 **입력 편의 설탕**으로만 허용한다.
- 정본 텐서 표현은 항상 아래 형태로 canonicalize 한다.
  - `형상(shape): 차림` (예: `[2, 2]`)
  - `자료(data): 1차 차림` (row-major, “가로먼저”가 기본)
  - `배치(layout): "가로먼저"(row-major)` 기본값
- 중첩 차림 설탕의 전개 규칙(canon):
  1) 모든 하위 차림의 길이가 동일해야 한다(불규칙 금지).
  2) `형상=[행수, 열수]`로 추론한다(Phase 0: 2차만).
  3) row-major로 평탄화하여 `자료`를 만든다.
- 불규칙(톱니) 차림은 텐서 설탕으로 취급하지 않으며 오류로 본다.

### DoD
- `SSOT_LANG`에 “중첩 차림 → 텐서 정본 전개” 규칙이 명시되어 있다.
- canon 결과(정본 AST)는 `형상+평탄자료(+배치)`만을 사용하며, 해시/직렬화 기준이 단일하다.

---

---

## DR-067 — AGE1 런타임 타입검사 의미론(타입 표기 있는 경우만 강제)

- 상태: 채택
- 날짜: 2026-01-22
- 근거: `docs/context/proposals/PROPOSAL_LANG_RUNTIME_TYPECHECK_2026-01-22.md`
- 목적:
  - AGE1에서 PinSpec/TypeRef(타입 표기)가 있는 경우의 **런타임 타입검사 적용 지점/규칙/진단 코드**를 고정해, 구현 기준을 명확히 한다.
- 범위:
  - 포함:
    - 표준 함수/씨앗 파라미터(PinSpec)의 타입 검사
    - `T?`(옵션) 검사
    - `정수`(수의 부분집합) 검사
    - `수@단위`(차원 일치) 검사
    - `차림<T> / 모음<T> / 짝맞춤<K,V>` 원소 타입 검사(정준: 전 원소 순회)
  - 제외:
    - 정적 추론/빌림검사/필드 타입(묶음씨/고름씨) 등은 Gate1+로 이월
- 핵심 결정:
  1) **검사 시점**: 호출 인자 바인딩 완료 후(PinSpec 확정 후) 검사한다. 파이프/기본값 주입도 동일.
  2) **강제 대상**: PinSpec에 타입이 명시된 항목만 강제한다. `_`/`Infer` 등 “검사 생략 표기”는 강제하지 않는다.
  3) **표준 함수(STDLIB)**: STDLIB PinSpec 타입을 강제한다. 인자 수/타입 불일치 시 런타임 오류.
  4) **옵션(T?)**: 값이 `없음`이면 통과, 아니면 T 규칙으로 검사.
  5) **컨테이너 제네릭**: `차림<T>/모음<T>/짝맞춤<K,V>`는 구조+원소 검사. 원소 검사는 결정성 우선으로 **전 원소 순회**를 정준으로 한다.
  6) **단위 타입**: `수@단위`는 차원 일치 필수. `수/정수`는 차원 없는 값만 허용.
  7) **진단 코드**: 타입 불일치는 `E_RUNTIME_TYPE_MISMATCH`로 통일한다. 메시지에 기대 타입/실제 타입/핀 이름을 포함(SHOULD). 기본 동작은 즉시 중단(FATAL).
- DoD:
  - 런타임에서 `E_RUNTIME_TYPE_MISMATCH`가 결정적으로 발생/표현된다.
  - `pack/type_runtime_typecheck/*`로 `수/정수/단위/옵션/컨테이너` 불일치를 골든으로 고정한다.

---

## DR-068 — AI 친화성 강화 v1: Phase 0(문법 변경 없이 데이터/검증 루프부터)

- 상태: 채택
- 날짜: 2026-01-22
- 근거: `docs/context/proposals/PROPOSAL_AI_FRIENDLY_ENHANCEMENTS_v1.md`
- 문제 인식:
  - “AI 지향” 선언 대비 실제 AI 생성/검증 사례가 부족하다. (데이터 부족/검증 루프 부재/오류 피드백 부재)
- 결정(Phase 0: 즉시 착수, 파서 변경 없음):
  1) **주석 기반 힌트 시스템**을 도입한다(주석 규격이므로 AGE0 호환).
     - `@type @intent @input @output @expects @returns @property`
  2) **Self-Documented Pack** 표준 구조를 채택한다(최소 10개).
     - `intent.md / input.ddn / alternatives.ddn / common_errors.ddn / golden.jsonl`
  3) **오류 코퍼스(errors.jsonl)**를 구축한다(최소 100개, 패턴 분류 포함).
  4) (문서) 표준라이브러리 문서화를 “AI가 읽기 쉬운 형태”로 확장하는 방안은 Phase 0에서는 스펙/포맷만 준비하고, 실제 자동화는 Phase 1+로 이월한다.
- 비목표(Phase 0에서 금지):
  - 정적 타입 추론, DDN-BERT, 대화형 워크플로우 엔진 통합 등은 Phase 2+로 이월
- DoD:
  - `docs/context/ai/COMMENT_HINT_SPEC_v1.md` 존재
  - `pack/stdlib_examples/*` 10개 이상 존재 + 각 폴더에 5개 파일 완비
  - `docs/context/ai_learning/errors.jsonl` 100개 이상 + 패턴 12종 이상
  - `docs/context/ai_learning/index.json` 존재
---

## DR-069 — 계약 실패 메시지/진단 표준 v1

- 상태: 채택
- 날짜: 2026-01-23
- 근거: `docs/context/proposals/PROPOSAL_CONTRACT_FAILURE_MESSAGE_STANDARD_v1.md`
- 목적: 계약(전제/보장) 위반 시 메시지/필드 구성을 고정하여 골든/리플레이/AI 수집 경로를 안정화한다.
- 결정:
  1) 표준 메시지(정본 문자열):
     - 전제(pre): `전제하에 조건이 실패했습니다`
     - 보장(post): `보장하고 조건이 실패했습니다`
  2) `geoul.diag.jsonl` 계약 위반 레코드는 아래 최소 필드를 MUST로 가진다.
     - `level`: `warn`(알림) | `error`(중단)
     - `code`: `W_CONTRACT_PRE|POST` | `E_CONTRACT_PRE|POST`
     - `reason`: `CONTRACT_PRE` | `CONTRACT_POST`
     - `contract_kind`: `pre` | `post`
     - `mode`: `알림` | `중단`
     - `message`: 위 표준 메시지
     - `rule_id`: `L0-CONTRACT-01`
     - 좌표: `source_span`(권장) 또는 `file,line,col`(최소 1종 MUST)
  3) 선택 필드: `contract_id`, `origin`, `targets`, `expr`
  4) 모드-레벨 매핑(정준):
     - `mode=알림` → `level=warn`, `code=W_*`
     - `mode=중단` → `level=error`, `code=E_*`
- DoD:
  - 계약 위반 케이스가 위 필드/문구로 결정적으로 기록된다.
  - `pack/diag_contract_standard/*`로 골든 검증한다.

---

## DR-070 — 계약 위반 슬기 훅 v1 (AGE1: 기록만)

- 상태: 채택
- 날짜: 2026-01-23
- 근거: `docs/context/proposals/PROPOSAL_CONTRACT_SEULGI_HOOK_v1.md`
- 결정:
  1) 훅 이름: `슬기.계약위반`
  2) 호출 시점(의미론):
     - 전제(pre): `아니면` 블록 실행 후
     - 보장(post): `아니면` 블록 실행 + 재검사 실패 후
  3) 입력: DR-069 계약 diag 레코드 1건을 그대로 입력으로 사용한다.
  4) AGE1 정책: 훅을 **실행하지 않고** `geoul.diag.jsonl`에 “훅 기록 이벤트”만 남긴다.
     - `event_kind=hook`, `hook_name="슬기.계약위반"`, `hook_input_ref`(해당 계약 diag의 `(madi,seq)` 또는 `fault_id`)
  5) AGE2 정책(이월): 실제 실행(LLM 호출/패치 생성) 허용 여부는 별도 결정으로 격리한다.
- DoD:
  - 계약 위반 발생 시 diag 1건 + 훅 기록 이벤트 1건이 결정적으로 생성된다(AGE1).
  - `pack/diag_contract_seulgi_hook/*`로 훅 기록의 필드/순서를 골든으로 고정한다.

---

## DR-071 — 보고서 정본 경로 통일 및 중복 제거

- 상태: 채택
- 날짜: 2026-01-23
- 배경: `docs/context/reports/`와 `docs/reports/impl/`에 동일 보고서가 중복되어 링크/정본 판정이 흔들림.
- 결정:
  1) 보고서 정본 경로:
     - 구현/테스트/pack 보고서: `docs/reports/impl/`
     - 감사/정리 보고서: `docs/reports/audit/`
  2) `docs/context/reports/`는 **리다이렉트/색인만** 유지한다(실물 보고서 금지).
- DoD:
  - 중복 보고서가 제거되고, `docs/context/reports/*`는 README/INDEX만 남는다.

---

## DR-072 — 텐서 표준 라이브러리 최소 범위(AGE1 Phase 0)

- 상태: 채택
- 날짜: 2026-01-25
- 근거: `docs/context/proposals/PROPOSAL_TENSOR_STDLIB_SCOPE_2026-01-25.md`
- 배경:
  - 텐서 설탕(`[[...],[...]]`)은 이미 정본화(형상+자료+배치) 되었으나,
    런타임/표준 함수 범위가 불명확하여 구현/테스트 기준이 흔들린다.
- 결정(AGE1 Phase 0):
  1) 텐서는 **묶음**으로 취급한다.
  2) 필수 필드(정준 키):
     - `형상`: 차림(행, 열)
     - `자료`: 1차 차림(평탄, row-major)
     - `배치`: 글(기본 `"가로먼저"`)
  3) 최소 표준 함수(AGE1):
     - `텐서.형상(텐서) -> 차림`
     - `텐서.자료(텐서) -> 차림`
     - `텐서.배치(텐서) -> 글`
     - `텐서.값(텐서, 행, 열) -> 값?`  (범위 밖: `없음`)
     - `텐서.바꾼값(텐서, 행, 열, 값) -> 텐서` (범위 밖: FATAL)
       - 의미는 **불변 갱신 + 재바인딩** 해석을 따른다(차림 인덱스 대입과 동일 계열).
  4) 입력이 텐서가 아니면 `E_RUNTIME_TYPE_MISMATCH`로 처리한다(AGE1 런타임 타입검사 표준과 정합).
- DoD:
  - `[[1,2],[3,4]]`가 `형상=[2,2]`, `자료=[1,2,3,4]`, `배치="가로먼저"`로 정본화됨을 골든으로 검증.
  - `텐서.값/텐서.바꾼값`의 범위 정책(없음/FATAL)이 pack으로 고정된다.

---

## DR-073 — W25 `모두 {}` 표면 문법 정본화(설탕)

- 상태: 채택
- 날짜: 2026-01-25
- 근거: `docs/context/proposals/PROPOSAL_LANG_W25_ALL_BLOCK_SYNTAX_2026-01-25.md`
- 배경:
  - W25 “군집 명령/쿼리” 문서에서 `모두 {}` 표면 표기가 의사 코드로 남아 있어,
    문서/구현이 일치하지 않는다(OI-202).
- 결정:
  1) 표면 문법(설탕):
     - `(임자) 대상차림 모두 { ...문장... }.` 를 허용한다.
  2) 정본 전개:
     - 위 표기는 다음으로 전개한다.
       - `(임자) 대상차림에 대해: { ...문장... }.`
  3) 의미론(결정성):
     - `대상차림`은 블록 실행 전에 **스냅샷**으로 평가한다.
     - 반복 순서는 차림의 정준 순서를 따른다(인덱스 증가).
     - 블록 내부에서 새로 생기는 바인딩은 `임자`만이다(기타 외부 규칙은 기존 `~에 대해:`를 따른다).
  4) 제한:
     - `대상차림`은 `차림`을 반환하는 식(또는 쿼리 결과 차림)으로 제한한다(AGE1).
- DoD:
  - 파서/정본화에서 `모두 {}`가 항상 `~에 대해:`로 전개됨을 골든으로 검증한다.
  - OI-202는 CLOSED로 전환한다.

---

## DR-074 — fixits-json 스키마 v1 (teul-cli canon --emit fixits-json)

- 상태: 채택
- 날짜: 2026-01-25
- 근거: `docs/context/proposals/PROPOSAL_FIXITS_JSON_v1.md`
- 목표:
  - `teul-cli canon --emit fixits-json` 출력 형식을 **최소/결정적/플랫폼 독립** JSON 스키마로 고정하여 IDE/LSP가 안정적으로 Fix-it을 소비할 수 있게 한다. fileciteturn16file0
- 범위:
  - 적용: `teul-cli canon`의 fix-it 제안 출력
  - 비적용: 자동 적용(autofix) 금지. 제안은 반드시 승인(리뷰/덧댐) 흐름을 거친다.
- 결정(스키마 v1):
  - 출력은 **JSON 배열**이며, 항목 1개가 fix-it 제안 1건이다.
  - 필수 필드:
    - `code`(string): lint/parse 코드 (예: `TERM-WARN-001`)
    - `message`(string): 요약
    - `span`(object):
      - `file`(string)
      - `start_line`/`start_col`/`end_line`/`end_col` (int, 1-based)
    - `suggestion`(object):
      - `kind`(string): `replace` | `insert` | `delete`
      - `old`(string, optional)
      - `new`(string, optional)
      - `note`(string, optional)
  - 정렬(결정성):
    - `file` → `start_line` → `start_col` 순으로 정렬해 출력한다.
    - 출력 인코딩은 UTF-8 + LF로 고정한다.
  - 빈 제안:
    - 제안이 없으면 반드시 `[]`를 출력한다.
- DoD:
  - 같은 입력에 대해 플랫폼/시간에 상관없이 **바이트 단위로 동일한** fixits-json이 나온다.
  - `pack/cli_fixits_json_basics/*` (또는 동등)로 정렬/좌표/빈배열을 골든으로 검증한다.

---

## DR-075 — NuriGym 최소 스키마 v1 (OI-301 최소 확정)

- 상태: 채택
- 날짜: 2026-01-24
- 근거: `docs/context/proposals/PROPOSAL_NURIGYM_MIN_SPEC_2026-01-24.md`
- 결정:
  1) 최소 스키마 v1 고정: episode/step/dataset JSONL 포맷 + DetJson 해시 규칙.
  2) 훈련/실행 분리 규칙 고정: 학습은 외부, 실행/리플레이는 결정적 코어.
  3) 대표 환경 `nurigym.cartpole1d` 최소 스펙(관측 4값, 행동 -1/+1, 보상/종료 규칙).
- DoD:
  - `w47_observation_spec`, `w53_dataset_export`, `pack/nuri_gym_cartpole`가 최소 스키마 기준으로 정렬됨.
  - OI-301의 “미정” 항목이 “잔여 미정”으로 축소됨.


---

## DR-076 — 씨앗(익명함수) 리터럴 표기 v1 (막대 `|` 정본)

- 상태: 채택
- 날짜: 2026-01-25
- 배경:
  - 씨앗(1급 함수)은 `거르기/바꾸기/각각돌며` 등 고차 셈씨의 핵심이며, AI/사람 모두가 혼동 없이 읽고 쓸 수 있는 **표준 표면 표기**가 필요하다.
  - `->`는 타입 시그니처(예: `(차림)->수`)에서 이미 “입력→출력” 의미로 사용되므로, 씨앗 리터럴 구분자로 재사용하면 파서/AI 혼동 위험이 크다.
- 결정:
  1) **씨앗(익명함수) 리터럴의 표준 표기**는 다음을 채택한다.
     - 1개 매개변수: `{x | 식}`  
       예: `{점수 | 점수 >= 60}`
  2) `{x -> 식}` 표기는 v1에서 **비권장/미지원**으로 둔다. (타입 화살표와 충돌)
  3) v1의 씨앗 본문은 **단일 식**을 기본으로 한다. 여러 줄/토막 본문 씨앗은 후속 결정으로 이월한다.
  4) 씨앗을 인자로 받는 표준 셈씨(거르기/바꾸기/각각돌며 등)는 **AGE1의 1급 함수 지원 이후** 활성화한다.
- DoD:
  - 문서/예제/팩에서 씨앗 리터럴 표기는 `{x | ...}`로 통일된다.
  - `->`를 사용한 씨앗 표기는 문법/린트에서 명확한 진단으로 거부(또는 자동 치환 후보로만 제시)된다.


---

## DR-077 — `(임자)마다 { ... }` / `(임자) 모두 { ... }` 임자(바인더) 규칙 + 지역 범위(바탕.* 최소화)

- 상태: 채택
- 날짜: 2026-01-25
- 근거:
  - `docs/context/proposals/PROPOSAL_LANG_W25_ALL_BLOCK_SYNTAX_2026-01-25.md`
  - 제안 메모: `(매마디)마다` 표기 정합(2026-01-24)
- 배경:
  - 반복/블록 문법에서 `(매마디)마다 { ... }`의 “매마디”는 예시 이름일 뿐이며,
    사용자가 원하는 임자 이름을 써서 **지역 변수로 다루면 `바탕.*` 의존을 줄일 수 있다.
  - SSOT_LANG 머릿말 표의 `:` 열이 “지원/미지원”처럼 오해될 여지가 있어, 표의 의미를 명확히 해야 한다.
- 결정:
  1) **임자(바인더) 형식**:
     - 기본: `(이름)`  
     - (선택) 타입 부착: `(이름:타입)`  
     - 적용: `마다 { ... }`, `모두 { ... }` (및 동일 계열의 반복 블록)
  2) **임자 이름은 임의의 식별자**를 허용한다. `매마디`는 관용 예시일 뿐 고정 이름이 아니다.
  3) **임자 생략 규칙(v1)**:
     - `마다 { ... }`처럼 괄호 임자를 생략한 경우, 정본 임자 이름은 `매마디`로 둔다. (문서/정본 출력에서 일관)
  4) **지역 범위(스코프)와 이름 해석**:
     - `(임자)마다 { ... }` / `(임자) 모두 { ... }` 블록 안에서 `임자`는 **지역 변수**로 바인딩된다.
     - 블록 안의 이름 해석은 “지역 → 바깥 지역 → 바탕” 순서를 따른다.
     - `바탕.*`은 “명시적 전역”으로만 사용하도록 권장한다(지역/임자 우선).
  5) **짧은 별칭(선택, v1 고정)**:
     - 블록 내부에서 `그것`은 현재 임자(바인더)와 동일한 값으로 해석되는 별칭이다.
       - 예: `(점수)마다 { 그것 >= 60 }` 는 `(점수)마다 { 점수 >= 60 }` 와 동치.
- DoD:
  - SSOT_LANG “대표 머릿말 목록” 표의 `:` 열은 “콜론 문장형 사용 여부”임을 명확히 주석으로 표시한다.
  - 문서/예제에서 `(매마디)마다`가 “지원 문법”임이 오해 없이 드러난다.
  - (구현/팩) `마다 { ... }`(임자 생략)와 `(x)마다 { ... }`(임자 지정)이 동일 의미로 동작함을 pack으로 검증한다.

---

## DR-078 — rN(리비전) 표기 전면 금지 & 번들/산출물 식별은 해시 접미사로

- 상태: 채택
- 날짜: 2026-01-25
- 배경:
  - `r1/r2/...` 같은 리비전 표기는 “사실상 서브버전”으로 오해를 낳고,
    SSOT의 단일 SemVer(vMAJOR.MINOR.PATCH) 규칙과 충돌한다.
  - 번들/패치의 식별은 **해시가 이미 충분**하며, 동일 버전 다회 제출은 “해시 접미사”로 해결하는 것이 결정성/감사에 유리하다.
- 결정:
  1) SSOT 및 파생 산출물의 파일명/태그에서 `rN`(예: `_r1`, `_r2`) 표기를 **사용하지 않는다**. (MUST NOT)
  2) 동일 SSOT 버전에서 여러 번들/패치가 존재할 경우, 식별자는 아래 규칙으로 만든다. (MUST)
     - 접미사: `_{YYYYMMDD}_{sha8}` 또는 `_{YYYYMMDDHHMM}_{sha8}`
     - 여기서 `sha8`은 번들(zip) 또는 패치 묶음의 sha256 앞 8 hex이다.
  3) 정본 판정은 언제나 `WORKSPACE_MANIFEST.json`의 `key_files.sha256` 및 번들 sha256로 한다. (MUST)
- 예:
  - `ssot_only_v20.4.1_20260125_1a2b3c4d.zip`
  - `workspace_bundle_v20.4.1_20260125_1a2b3c4d.zip`
  - `patch_docs_context_migration_20260125_1a2b3c4d.zip`
- DoD:
  - 문서/프로토콜에서 `rN` 표기 예시는 제거되고, 해시 접미사 규칙이 안내된다.
  - Codex 제출물은 `_rN` 없이도 충돌 없이 식별 가능해야 한다(해시 접미사+manifest).

---

## DR-079 — AGE1 표준라이브러리 “정본 이름 + 별칭(호환) + 구현현황판” 운영 규칙

- 상태: 채택
- 날짜: 2026-01-25
- 근거: `docs/context/proposals/PROPOSAL_STDLIB_EXTENSION_IMPL_MATRIX_20260125.md`
- 배경:
  - AGE1 표준라이브러리 확장 v1이 진행되면서, 구현체에는 유사 기능이 존재하되 **이름/시그니처/경계 정책**이 어긋나는 “부분대응”이 다수 발생했다.
  - 이 상태에서 “문서/예제/pack/코드”가 각자 다른 이름을 쓰면 AI/사람/골든이 모두 흔들린다.
- 결정:
  1) **정본(규범) 이름/시그니처/정책은 SSOT가 고정**한다. (MUST)
     - 정본 목록은 `SSOT_LANG`(표준 셈씨 표)과 `SSOT_DECISIONS`(관련 DR)로만 확정한다.
  2) 구현은 빠르게 맞추기 위해 **별칭(호환) 레이어**를 허용한다. (SHOULD)
     - “부분대응” 기능이 이미 있으면, 정본 이름을 새로 만들고 내부에서 기존 기능을 호출해도 된다.
     - 반대로, 기존 이름을 유지하되 정본 이름을 alias로 제공해도 된다.
     - 어느 쪽이든 **정본 이름은 반드시 제공**되어야 한다. (MUST)
  3) 별칭은 무제한이 아니라, 아래 정책을 따른다. (MUST)
     - alias는 `docs/status/STDLIB_ALIAS_TABLE.md`에 “정본→별칭” 표로 기록한다.
     - alias는 *동일 의미*만 허용하며, 의미/경계 정책이 다르면 alias로 두지 말고 새 정본 함수를 구현한다.
  4) “구현 현황”은 규범이 아니라 **상태 문서**로 운영한다. (MUST)
     - 구현 매핑 표(구현/부분대응/미구현)는 `docs/status/STDLIB_IMPL_MATRIX.md`를 정본으로 두고,
       SSOT에는 근거 링크만 둔다.
- DoD:
  - AGE1 최소 셋(글/차림/수학/묶음)에서 정본 이름이 문서·예제·pack에서 일관되게 사용된다.
  - `pack/stdlib_*` 골든에서 “정본 이름 호출”이 통과한다.
  - alias가 필요한 항목은 `STDLIB_ALIAS_TABLE.md`에 기록된다.
---

## DR-080 — 복합 갱신 연산자 표준: `+<-`/`-<-` ( `+=`/`-=` 금지 )

- 상태: 채택
- 날짜: 2026-01-25
- 배경:
  - 또니랑은 `=`(정의/바인딩)과 `<-`(갱신/대입)을 엄격히 구분한다.
  - 따라서 복합 대입도 `=` 계열(`+=`, `-=`)이 아니라 `<-` 계열로 일관되게 제공한다.
- 결정:
  1) AGE1+에서 복합 갱신 설탕을 다음으로 표준화한다.
     - `x +<- y`
     - `x -<- y`
     - (후속 확장 후보) `*<-`, `/<-`
  2) 정본 전개(Desugar)는 항상 “단일 갱신(`< -`)”으로 고정한다.
     - `x +<- y`  ≡  `x <- x + y`
     - `x -<- y`  ≡  `x <- x - y`
  3) LHS 제약(초기 안정성):
     - v1에서는 **단순 이름(식별자)**만 허용한다.
     - `a[i] +<- 1` 같은 “구조 갱신 복합형”은 후속 결정으로 이월한다.
  4) `+=`, `-=`는 v1에서 **미지원(MUST NOT)** 으로 한다.
     - 타언어 호환을 위해 별칭으로 허용할 필요가 생기면, 별도 DR로만 논의한다.
- DoD:
  - 파서가 `+<-`, `-<-`를 인식한다.
  - 정본화 출력이 위 전개로 결정적으로 고정된다.
  - `+=`, `-=`를 사용하면 진단으로 거부한다.

---

## DR-081 — 심볼릭 미분/적분 변환(수식) 최소 규격 v1 (Gate0, #ascii만)

- 상태: 채택
- 날짜: 2026-01-25
- 개정: 2026-02-08
- 배경:
  - AGE1에서 “수식값 → 수식값” 변환(미분/적분)은 교육/물리/셈그림(Seamgrim) 데모에 바로 필요하다.
  - 다만 MathIR/단순화/다변수 등 전체 범위를 지금 고정하면 범위가 폭발하므로, Gate0/AGE1에 필요한 **입력/출력/오류**만 최소로 확정한다.
  - “심볼릭(기호) 변환”과 “런타임 수치 미분/적분(근사)”은 **오차/표시/결정성 계약이 다르므로**, 시그니처/표시/진단을 분리 고정하는 편이 안전하다.
- 결정:
  1) 범위(모드) 분리:
     - DR-081은 **심볼릭(기호) 변환**만을 정의한다.
     - “수치 미분/수치 적분(근사)”은 **별도 규격**으로 분리한다. (OPEN: `OI-CALC-NUMERIC-01`)
     - 구현/문서/UI에서 “심볼릭 결과”와 “수치 근사 결과”를 같은 출력으로 섞지 않는다(MUST NOT).
  2) 대상 수식 표기:
     - Gate0/AGE1 v1에서는 `#ascii` 수식만 입력으로 받는다.
     - `#ascii1`(표시 변환) 및 다른 수식 표기계는 OUT-OF-SCOPE.
  3) 표준 셈씨(변환 동사) 시그니처(요약):
     - (약식) `미분하기(수식값, 변수이름?:글) -> 수식값`
     - (약식) `적분하기(수식값, 변수이름?:글) -> 수식값`
     - (정식) `미분하기(수식값, 옵션?:묶음) -> 수식값`
     - (정식) `적분하기(수식값, 옵션?:묶음) -> 수식값`
  4) 옵션 묶음(v1 최소, 키 고정):
     - `변수?:글` : 미분/적분 대상 변수 이름
     - `차수?:수` : **양의 정수**. 기본 `1`
     - `상수포함?:참거짓` : 적분만. 기본 `거짓`
       - `참`이면 결과 끝에 `+ C`를 덧붙인다. (`C`는 정본 적분상수 이름)
  5) 약식 인자 해석(설탕):
     - 두 번째 인자가 `글`이면, `옵션=(변수=<그 글>)` 설탕으로 본다.
  6) 변수 선택 규칙:
     - `옵션.변수`가 있으면 그 변수를 사용한다.
       - 수식의 자유변수에 없으면 FATAL(진단 코드 `E_CALC_FREEVAR_NOT_FOUND`).
     - `옵션.변수`가 없으면:
       - 수식의 자유변수가 정확히 1개이면 그 변수를 자동 선택한다.
       - 자유변수가 0개이거나 2개 이상이면 FATAL(진단 코드 `E_CALC_FREEVAR_AMBIGUOUS`).
  7) 차수 규칙:
     - `차수`는 1 이상의 정수여야 한다. 그 외는 FATAL(`E_CALC_TRANSFORM_BAD_ORDER`).
     - v1에서 구현체는 최소 “1차(기본)”를 MUST로 지원한다.
       - 2차 이상을 지원할 수는 있으나, **지원 범위는 pack에 포함된 케이스로만 정의**한다.
  8) `이름 = 식` 형태 보존:
     - 입력이 “정의식(좌변 이름 + 우변 수식)”이면, 출력도 같은 좌변 이름을 유지한다.
     - 예: `y = x*x` 를 `미분하기` 하면 `y = ...` 형태를 유지(좌변 이름 보존).
  9) 출력 표기 + 표시 규칙:
     - 반환값은 변환된 `#ascii` 수식값 1개다(동일 표기계 유지).
     - 단, UI/문서/도구가 변환 결과를 “사람에게 표시”할 때는 아래 메타를 **별도 블록**으로 함께 보여주는 것을 권장한다(SHOULD):
       - `변환종류`: `미분` | `적분`
       - `표기`: `#ascii`
       - `변수`, `차수`
       - (적분) `상수포함` 정책
  10) 실패 정책(침묵/추정 금지):
      - 미지원 수식 형태/연산자/함수는 FATAL(진단 코드 `E_CALC_TRANSFORM_UNSUPPORTED_EXPR`).
      - 미지원 옵션(예: 구간 적분 요청 등)은 FATAL(진단 코드 `E_CALC_TRANSFORM_UNSUPPORTED_OPTION`).
- OUT-OF-SCOPE(잔여 미정):
  - MathIR 완전 규격(정규화/단순화/미분 규칙 전체)
  - 다변수 적분, 구간 적분, 수치 적분
  - 단위/차원 타입과의 결합(AGE2+)
- DoD:
  - `pack/math_calculus_v1/*`에서:
    - 자유변수 1개 자동 선택 케이스
    - 자유변수 0개/2개 이상 오류 케이스
    - (신규) 옵션 묶음 기반 호출(변수/차수/상수포함) 케이스
    - `이름=식` 보존 케이스
    - `#ascii` 입력/출력 고정

---

## DR-082 — 보개 drawlist “목록 키” 확장 v1: `보개_그림판_목록`

- 상태: 채택
- 날짜: 2026-01-25
- 배경:
  - 단건 키(예: Rect 하나를 그리는 입력 키)만으로는 테트리스/격자/텍스트 UI 등 “다항목” 화면을 만들 때 입력이 과도하게 장황해진다.
  - 따라서 DrawListV1(BDL1)을 유지한 채, 입력 스키마에 “항목 목록” 키를 추가하여 **결정적 순서**로 렌더링할 수 있게 한다.
- 결정:
  1) 신규 입력 키(정본):
     - `보개_그림판_목록` : “그림 항목들의 차림”
  2) 항목 스키마(v1 최소):
     - 항목은 “묶음(레코드)”이며, 최소 필드는 다음을 가진다.
       - `종류`: `Rect` | `Text` | `Sprite`
       - `x`, `y`: 수(정수 픽셀; BDL2에서 고정소수 허용 시 별도 규칙)
     - `Rect` 필수: `w`, `h`, `색`
     - `Text` 필수: `글`, `색` (폰트/크기/정렬은 OUT-OF-SCOPE)
     - `Sprite` 필수: `자원`, `w`, `h` (스프라이트 시트/회전 OUT-OF-SCOPE)
  3) 결정성(순서 규격):
     - 목록 순서는 차림 인덱스 증가 순서를 그대로 따른다(=렌더 순서).
     - 동일 프레임에서 목록이 여러 경로에서 합쳐지는 경우는 허용하지 않는다(v1).
  4) 하위호환:
     - 기존 단건 키 입력은 계속 지원한다. 단, 동일 프레임에 단건 키와 목록 키가 동시에 존재할 때의 우선순위는 FATAL로 처리(v1).
- OUT-OF-SCOPE:
  - 도형 확장(Path/Circle), 그라데이션, 클리핑, 변형행렬, 텍스트 레이아웃
  - 목록 합성/레이어링 규칙(AGE2+)
- DoD:
  - `pack/bogae_drawlist_listkey_v1/*`에서:
    - Rect/Text/Sprite 최소 1개씩 포함된 목록 렌더가 결정적으로 동일한 `bogae_hash`를 만든다.
    - 단건 키+목록 키 동시 사용 시 FATAL 진단이 재현된다.

---

## DR-083 — BDL2 최소 확정 v1: Q24.8 좌표/두께 + AA 플래그(서브픽셀 정책)

- 상태: 채택
- 날짜: 2026-01-25
- 배경:
  - BDL1은 정수 픽셀 계약을 고정해 “결정성”을 먼저 확보했다.
  - 그러나 교육/애니메이션/물리 UI에서 서브픽셀 이동과 선두께(0.5 등)가 즉시 요구된다.
  - 범위 폭발을 막기 위해 “좌표/두께 표현 + AA on/off에 따른 정준 스냅 규칙”만 최소로 확정한다.
- 결정:
  1) 좌표/두께 입력 타입(DetBin 기준):
     - BDL2는 `Q24.8`(signed fixed, frac=8)로 `x,y,w,h,두께`를 직렬화할 수 있다.
  2) 커맨드 플래그:
     - `cmd_flags` bit0 = `AA` (1=AA on, 0=AA off)
  3) 정준 렌더 규칙:
     - `AA=1`: Q24.8 값을 **그대로** 렌더 입력으로 사용(서브픽셀 유지)
     - `AA=0`: 렌더 직전에 `x,y,w,h,두께`를 정수 픽셀로 **스냅**한다(반올림 규칙은 “버림 toward -inf”로 고정)
     - 콘솔 보개(ASCII)는 항상 `AA=0` 스냅을 사용한다.
  4) 결정성(해시/골든):
     - `bogae_hash`는 픽셀 결과가 아니라 **DetBin(직렬화된 drawlist)**를 기준으로 한다.
     - 따라서 같은 drawlist 입력이면 환경/플랫폼과 무관하게 동일 해시가 나와야 한다.
- OUT-OF-SCOPE(잔여 미정):
  - Circle/Ellipse/Path 커맨드 설계
  - 텍스트 서브픽셀/힌팅 정책
  - AA 알고리즘 선택/품질 옵션
- DoD:
  - `pack/bdl2_subpixel_aa_v1/*`에서:
    - 동일 입력의 `bogae_hash`/detbin 해시가 결정적으로 동일함을 검증
    - `AA=0` 스냅 규칙이 골든과 일치함을 검증
---

## DR-084 — 차림 인덱싱 설탕 v1: `a[i]` (읽기) + 제한된 `a[i] <- v` (쓰기)

- 상태: 채택
- 날짜: 2026-01-25
- 배경:
  - 차림(배열)의 인덱스 접근이 표준 셈씨 호출만으로는 너무 장황해져 AGE1 데모/팩 생산성이 떨어진다.
  - 단, `=`(정의)와 `<-`(갱신)을 엄격히 구분하는 또니랑의 원칙을 유지해야 하며,
    결정성/정본/골든이 흔들리지 않도록 “정본 전개 1개”로 고정해야 한다.
- 결정:
  1) 읽기 설탕:
     - 표면: `a[i]`
     - canon: `a[i]` → `(대상=a, i=i) 차림.값.`
     - 경계: 범위 밖이면 `없음`
     - 제약: `i`는 정수(차원 없음)이어야 한다(아니면 진단).
  2) 제한된 쓰기 설탕(불변 갱신 + 재바인딩):
     - 표면: `a[i] <- v`
     - canon: `a[i] <- v` → `a = (대상=a, i=i, 값=v) 차림.바꾼값.`
     - 의미: 제자리 수정(mutation)이 아니라 **불변 갱신 + 재바인딩**
     - 제약: 좌변 `a`는 단순 이름(식별자)만 허용한다. (`f()[i] <- v`, `a[i][j] <- v` 금지)
     - 경계: 범위 밖이면 FATAL(자동 늘림/자동 채움 없음)
- DoD:
  - 정본화 출력이 위 canon 전개로 결정적으로 고정된다.
  - `pack/age1_charim_index/*`에서 읽기/쓰기/경계/진단이 골든으로 고정된다.

---

## DR-085 — 계약(전제/보장) 모드 표면 문법 v1: `(알림)` / `(중단)` + 기본값

- 상태: 채택
- 날짜: 2026-01-25
- 배경:
  - 계약(전제/보장)은 결정성/감사/리플레이의 핵심이며, 위반 시 “계속(알림)”과 “즉시 중단”을 명확히 구분해야 한다.
  - Codex 구현이 멈추지 않도록 표면 문법과 기본값을 AGE1에서 최소로 고정한다.
- 결정:
  1) 전제(Pre) 표면 문법(확장):
     - `{조건}인것 바탕으로.`  (기본 = 중단)
     - `{조건}인것 바탕으로(알림).`
     - `{조건}인것 바탕으로(중단).`
  2) 보장(Post) 표면 문법(확장):
     - `{조건}인것 다짐하고.` (기본 = 중단)
     - `{조건}인것 다짐하고(알림).`
     - `{조건}인것 다짐하고(중단).`
  3) 모드 의미:
     - `알림`: 계약 위반을 진단으로 기록하고(should), 실행은 계속한다.
     - `중단`: 계약 위반을 진단으로 기록한 뒤 즉시 종료한다(FATAL).
  4) 진단 필드(최소):
     - `reason=CONTRACT_PRE|CONTRACT_POST`, `mode=알림|중단`은 계약 진단에 포함 SHOULD.
- OUT-OF-SCOPE:
  - 계약 위반 슬기 훅 실행(AGE2+), 자동 수선, 계약 레벨/카테고리 확장
- DoD:
  - 동일 입력에서 계약 위반의 기록/중단 여부가 결정적으로 동일해야 한다.
  - `pack/diag_contract_mode_v1/*`로 알림/중단 차이를 골든으로 고정한다.

---

## DR-086 — 키보드 입력 한국어 별칭 v1 (샘(InputSnapshot) 정본화)

- 상태: 채택
- 날짜: 2026-01-25
- 개정: 2026-02-08 (keymap_v1 정본 표 + 원문(raw)/정본(canon) 분리 기록 규칙 보강)
- 배경:
  - 교육/데모에서 키 입력을 한국어로 쓰고 싶지만, 키 식별자가 영어/스캔코드로만 고정되어 있으면 문서/팩의 가독성이 크게 떨어진다.
  - 결정성 관점에서 “표기만 달라지고 정본 키는 동일”해야 한다.
  - 웹/OS/IME/키보드 레이아웃 차이 때문에, **원문(raw) 입력**과 **정본(canon) 입력**을 분리 기록해 두지 않으면 리플레이/팩에서 흔들릴 수 있다.
- 결정:
  1) 정본 키 이름(의미 키, canon key)
     - 샘(InputSnapshot)의 키 식별자는 **정본 키 문자열**로 정본화된다.
     - 정본 키는 `Key.<이름>` 형식이며, `<이름>`은 아래 `keymap_v1` 후보 집합 중 하나여야 한다(MUST).
  2) 정본 코드 이름(물리 키, canon code) — 선택
     - 물리 키(스캔코드/DOM code)가 주어지는 환경에서는 `Code.<이름>`도 함께 기록하는 것을 권장한다(SHOULD).
     - 정본 코드는 “좌/우 쉬프트/컨트롤/알트/메타 구분”을 포함할 수 있다(아래 `keymap_v1`의 code 집합).
  3) 별칭 입력(입력에서만 허용) → 정본 키로 치환
     - 한국어 별칭, DOM `key` 문자열, DOM `code` 문자열을 입력으로 허용한다.
     - 정본화 시, 반드시 정본 키(`Key.*`)로 치환하여 기록/리플레이한다(MUST).
  4) 정본 표(version) 고정
     - 별칭 치환은 **고정 테이블** `keymap_v1`에 의해 수행한다.
     - 테이블을 바꾸거나 후보 집합을 늘리는 경우는 `keymap_v2`로 분리하고 별도 DR로만 진행한다(MUST).
  5) 실패 정책(중요)
     - raw 입력이 `keymap_v1`으로 정본화되지 않으면 FATAL 진단으로 거부한다(MUST).
     - 침묵/추정/플랫폼 의존 fallback은 금지(MUST NOT).
     - 권장 진단 코드: `E_INPUT_KEY_UNSUPPORTED`, `E_INPUT_KEY_ALIAS_CONFLICT`
  6) 문자열 정규화(입력 단계)
     - 좌우 공백 제거, ASCII 대소문자 무시(비문자 키 이름), 일부 레거시 표기 통일을 수행할 수 있다(SHOULD).
     - 문자키(알파벳/숫자)는 `A..Z`, `0..9`로 정본화한다(소문자 입력 허용).
  7) 한국어 별칭 최소 집합(v1)
     - 방향키: `위/아래/왼쪽/오른쪽`
     - 특수키: `스페이스/엔터/탭/백스페이스/이스케이프`
     - 수정키: `쉬프트/컨트롤/알트/메타` (좌/우 구분은 code로만 표현; key는 구분하지 않음)
     - 문자키: `A..Z`, `0..9`

### keymap_v1: canon key 후보 집합(요약)
- 방향키: `ArrowUp`, `ArrowDown`, `ArrowLeft`, `ArrowRight`
- 기본키: `Enter`, `Escape`, `Backspace`, `Delete`, `Tab`, `Space`
- 수정키: `Shift`, `Control`, `Alt`, `Meta`, `CapsLock`
- 네비게이션: `Home`, `End`, `PageUp`, `PageDown`, `Insert`
- 시스템: `PrintScreen`, `ScrollLock`, `Pause`, `NumLock`, `ContextMenu`
- 펑션키: `F1`..`F12`
- 한글키: `HangulMode`, `HanjaMode`
- 문자키: `A`..`Z`, `0`..`9`

### keymap_v1: canon code 후보 집합(요약)
- 방향키: `ArrowUp`, `ArrowDown`, `ArrowLeft`, `ArrowRight`
- 기본키: `Enter`, `Escape`, `Backspace`, `Delete`, `Tab`, `Space`
- 수정키(좌/우 구분): `ShiftLeft`, `ShiftRight`, `ControlLeft`, `ControlRight`, `AltLeft`, `AltRight`, `MetaLeft`, `MetaRight`, `CapsLock`
- 네비게이션/시스템: `Home`, `End`, `PageUp`, `PageDown`, `Insert`, `PrintScreen`, `ScrollLock`, `Pause`, `NumLock`, `ContextMenu`
- 펑션키: `F1`..`F12`
- 문자키: `KeyA`..`KeyZ`, `Digit0`..`Digit9`

### 별칭 예시(일부, v1)
- 한국어(방향):
  - `왼쪽/좌/왼` → `Key.ArrowLeft`
  - `오른쪽/우/오른` → `Key.ArrowRight`
  - `위/상/위쪽` → `Key.ArrowUp`
  - `아래/하/아래쪽` → `Key.ArrowDown`
- 한국어(특수/수정):
  - `스페이스/공백/스페이스바` → `Key.Space`
  - `엔터/리턴` → `Key.Enter`
  - `백스페이스/백스페` → `Key.Backspace`
  - `삭제/딜리트` → `Key.Delete`
  - `이스케이프/esc` → `Key.Escape`
  - `쉬프트/시프트` → `Key.Shift`
  - `컨트롤/ctrl` → `Key.Control`
  - `알트/alt` → `Key.Alt`
  - `메타/윈도우키/커맨드` → `Key.Meta`
- DOM key/code:
  - raw_key `"ArrowLeft"` → `Key.ArrowLeft`
  - raw_code `"ShiftLeft"` → `Code.ShiftLeft`

### OUT-OF-SCOPE
- 국제 키보드 레이아웃, 한글 IME 조합키, dead key 처리
- “의미 키” 수준에서의 좌/우 수정키 구분(필요 시 `Key.ShiftLeft`류를 도입하는 keymap_v2로 이월)

### DoD
- 별칭 입력과 정본 키 입력이 동일한 샘/리플레이 결과를 만든다.
- `pack/input_key_alias_ko_v1/*`로 동치성을 골든으로 고정한다.
- 원문(raw) 필드를 포함하더라도, 리플레이의 의미는 정본 키(`Key.*`)만으로 결정된다.


---

## DR-087 — AGE1 보개 입력 키 정본화 보강: `보개_바탕색` + 레거시 `bogae_bg`

- 상태: 채택
- 날짜: 2026-01-25
- 배경:
  - 보개(뷰어) 데모/팩에서 배경색 키가 혼용되어 혼란이 발생한다.
  - 표기 통일(A) 원칙에 맞게 “정본 키 1개 + 레거시 별칭”을 고정한다.
- 결정:
  - 보개 배경색(캔버스 바탕색) 키는 정본으로 `보개_바탕색`을 사용한다.
  - 레거시 키 `bogae_bg`는 허용하되, 정본화 시 `보개_바탕색`으로 치환한다(LEGACY 경고 SHOULD).
- DoD:
  - `pack/bogae_bg_key_v1/*`에서 정본 키/레거시 키가 동등하게 처리됨을 골든으로 검증한다.

---

## DR-088 — 제4고개(기) FAST TRACK v1: W34(거울)→W35(리플레이)→W43A(즉각조회)

- 상태: 채택
- 날짜: 2026-01-25
- 근거: `docs/context/proposals/PROPOSAL_GOGAE4_FAST_TRACK_W34_W35_W43A_v20.1.19.md`
- 목적:
  - 34~44 전체를 한 번에 완성하지 않고, **재현 레일(35) + 즉각 조회(43A)**까지 먼저 뚫어 개발 속도를 올린다.
- 비목표(FAST TRACK에서 제외):
  - W36 trace tier 정책 최적화(T-OFF~T-FULL 전체), W40/41 서사 UI, W42 분기, W44 대규모 통합.
- 결정(최소 규격 v1):
  1) `teul-cli run --geoul-out <dir>` 실행 시 **아래 레이아웃을 생성**한다.
     - `manifest.detjson` : 고정 메타 + 산출물 파일 해시
     - `audit.ddnbin` : DDNI 헤더 + AuditFrame 스트림 + payload(입력 포함)
     - `audit.idx` : `madi → offset` + checkpoint 마커
     - (선택) `sam.ddnbin`, `sam.idx` : InputSnapshot 스트림(대형 로그 성능용)
  2) FAST TRACK 기본값:
     - `trace_tier = T-FULL`
     - `checkpoint_stride = 256` (CLI로 변경 가능)
  3) AuditFrame payload(FAST TRACK):
     - 매 마디 InputSnapshot(정본화 detjson UTF-8)을 반드시 포함한다.
     - checkpoint_stride 마다 상태 스냅샷(StateDetBinV1)을 포함한다.
  4) 재현/검증 CLI:
     - `teul-cli replay verify --geoul <dir> --entry <entry.ddn> ...`
     - 출력 1줄 고정 권장: 성공 `OK replay_equal=true frames=<n>`, 실패 `FAIL diverge_madi=<m> expected=<hex> got=<hex>`
  5) 즉각 조회 CLI:
     - `teul-cli geoul query --geoul <dir> --madi <n> [--path "바탕.점수"] --format detjson`
     - idx로 checkpoint를 찾아 “처음부터 replay”하지 않고 target까지 재구성한다.
- DoD(팩):
  - `pack/gogae4_w34_blackbox_basics`, `pack/gogae4_w35_replay_harness_basics`, `pack/gogae4_w43a_query_basics` 3개 팩으로 결정성을 고정한다.
---

## DR-089 — 표준 라이브러리(stdlib)는 “표준 가지(가-표준)”로 분할한다 (AGE1부터)

- 상태: 채택
- 날짜: 2026-01-25
- 배경:
  - AGE1 표준 라이브러리의 구현 범위가 커지면서 “한 덩어리 코어”로는 추적/검증/교체가 어렵다.
  - SSOT는 이미 `gaji/`를 재사용 가능한 패키지 단위로 두고 있으므로, stdlib도 동일한 운영 원칙으로 분할하는 것이 가장 안전하다.
- 결정:
  1) 표준 라이브러리(“표준 가지”)의 **배포/검증 단위는 gaji 패키지**로 한다.
     - 코어(런타임/정본화)는 “호출 규약/결정성/진단”만 제공하고,
     - 표준 셈씨(글/차림/수학/묶음/논리)는 gaji에 위치시킨다.
  2) 표준 패키지 ID(정본):
     - `gaji/std_text`   : 글(문자열) 기본
     - `gaji/std_charim` : 차림(배열) 기본
     - `gaji/std_math`   : 수/수학 기본
     - `gaji/std_map`    : 묶음(키-값) 기본
     - `gaji/std_logic`  : 논리/비교 기본
     - (선택) `gaji/std_tensor` : 텐서 최소(별도 DR 범위에서 확장)
  3) “정본 이름/시그니처/경계 정책”은 SSOT_LANG/DECISIONS가 고정한다.
     - gaji 구현체는 정본 이름을 MUST로 제공한다.
     - 기존 구현/레거시 이름이 있으면 **별칭(alias)** 으로 허용할 수 있으나,
       - 문서/pack의 정답 예제는 **정본 이름만 사용**한다.
  4) 구현 현황표(impl matrix)는 **규범(SSOT)이 아니라 status 문서**로 운영한다.
     - SSOT는 “정본 이름/정책”만 규범으로 두고,
     - 상태(구현/부분대응/미구현)는 `docs/status/*`에서 추적한다.
- DoD:
  - `docs/status/STDLIB_IMPL_MATRIX.md` 와 `docs/status/STDLIB_ALIAS_TABLE.md`가 운영 문서로 존재한다.
  - 최소 4종 pack(글/차림/수학/묶음)이 정본 이름 기준으로 골든을 가진다.


---

## DR-090 — 제5고개(기) ‘슬기 눈뜨기’(45~55) FAST TRACK v1 (W45~W55)

- 상태: 채택
- 날짜: 2026-01-25
- 근거: `docs/context/proposals/PROPOSAL_GOGAE5_SEULGI_AWAKEN_PLAN_v20.1.19.md`
- 선행(게이트):
  - W34: 거울 audit 로그(프레임별 state_hash) MUST
  - W35: replay verify(로그 기반 100% 재현) MUST
  - W43A: geoul query/seek(즉각조회) MUST
- 목적:
  - 45~55걸음을 “티켓/파일경로/팩/DoD”로 쪼개서, 4고개 FAST TRACK(34/35/43A) 이후 바로 개발 착수 가능하게 한다.
  - 결과는 항상 **거울 기록 + 리플레이 검증**으로 재현 가능해야 한다(55 통합 DoD).
- 핵심 원칙(결정성):
  1) 외부 AI/네트워크/지연 등 비결정 요소는 엔진 밖에서 처리하되,
     - 엔진에는 **L-마디 지연 + InputSnapshot 봉인** 형태로만 주입한다.
  2) intent/goal/spec/safety/latency/dataset은 DetJson(정본화) + 해시 규칙을 가진다.
- 정본 단위(데이터 규격 v1):
  - SeulgiIntent v1
  - TargetState v1 (Goal Parser: `-도록`)
  - ObservationSpec v1 (NuriGym 관찰 스키마)
  - ActionSpec v1 (행동 공간)
  - SafetyRule v1 (Gatekeeper 룰)
  - LatencyPolicy v1 (L-마디 정책)
- 도구줄(teul-cli) 서브커맨드(최소):
  - `teul-cli intent inspect --geoul <dir> [--madi <n>] [--agent <id>]`
  - `teul-cli goal parse <ddn|text> -> target.detjson`
  - `teul-cli nurigym spec --from <ddn> -> obs_spec.detjson action_spec.detjson`
  - `teul-cli latency simulate --L <n> --mode jitter|fixed ...`
  - `teul-cli safety check --rules rules.detjson --intent intent.detjson`
  - `teul-cli dataset export --geoul <dir> --format nurigym_v0 --out <dir>`
  - (선택) `teul-cli workshop open|gen|apply ...` : v0는 정적 HTML 생성+편집+replay verify
- D-PACK(회귀 방지, 최소):
  - `pack/gogae5_w45_intent_bundle/`
  - `pack/gogae5_w46_goal_parser_dorok/`
  - `pack/gogae5_w47_nurigym_observation_spec/`
  - `pack/gogae5_w48_goap_planner/`
  - `pack/gogae5_w49_latency_L_madi/`
  - `pack/gogae5_w50_safety_gatekeeper/`
  - `pack/gogae5_w51_llm_bridge_mock/`
  - `pack/gogae5_w52_multi_agent_bus/`
  - `pack/gogae5_w53_dataset_export/`
  - `pack/gogae5_w54_workshop_gui_v0/`
  - `pack/gogae5_w55_smart_errand_integration/`
- 기본값(정준) — 이 3개는 골든/재현성과 직결되므로 v1에서 고정한다:
  1) L-마디 기본값: **L=3**
  2) ObservationSpec 슬롯 기본값: **K=64**
  3) GOAP 비용 tie-break: `(총비용, 단계수, action_id)` (총비용 오름, 단계수 오름, action_id 사전식)
- 잔여 미정(AGE2+ 이월 권장):
  - workshop GUI v1(IDE급), LLM 실호출/권한서명, 리플레이/데이터셋 포맷 확장(서명/압축) 등
- DoD:
  - W55 통합 팩에서: `run -> geoul 생성 -> replay verify PASS -> dataset export 해시 PASS`가 결정적으로 재현된다.

---

## DR-091 — STDLIB 레거시 정책 v1 (정본 오염 방지 + 호환 유지)

- 상태: 채택
- 날짜: 2026-01-26
- 근거: `docs/context/proposals/PROPOSAL_STDLIB_LEGACY_POLICY_2026-01-26.md`

### 목적
- 레거시 stdlib 호출/표기를 **입력 호환**으로는 허용하되,
  문서/예제/팩/AI 출력/정본화 결과가 레거시로 오염되는 것을 방지한다.
- 레거시를 “별칭(정식)” 또는 “정본 승격”으로 다루는 **단일 운영 규칙**을 고정한다.

### 정의: 레거시 상태(enum)
- `LEGACY_ALLOWED_INPUT_ONLY` : 입력(파서/실행)은 허용. 정본 출력/문서/팩/AI는 금지.
- `ALIAS_OFFICIAL` : 레거시 이름을 **공식 별칭**으로 인정. 정본은 따로 존재.
- `PROMOTED_CANON` : 레거시가 **정본으로 승격**(레거시→정본으로 재정의).
- `REMOVED` : 입력도 금지(진단+fixit 제공).

### 정본 출력(canon output)의 범위 (MUST)
아래 산출물에서 레거시 이름이 등장하면 안 된다(별칭은 fixit 제안으로만 등장 가능).
- `teul-cli canon` 정본화 결과
- `pack/**`의 정답(골든 기준) 및 `intent.md`의 “정답 코드”
- `docs/**`의 사용자 예제(튜토리얼/가이드)
- AI 코퍼스(예: `errors.jsonl`)의 `correct` 필드

### 정책: 핵심 레거시 항목 (v1)
1) `번째` (차림 인덱스 접근)
- 상태: `ALIAS_OFFICIAL`
- 정본: `차림.값` 및 설탕 `a[i]`
- 규칙:
  - 입력에서 `번째`는 허용한다.
  - 정본 출력은 반드시 `a[i]` 또는 `차림.값`을 사용한다.
  - fixit(자동 수정) 우선순위:
    - 가능하면 `a[i]`로 치환
    - 아니면 `(대상=..., i=...) 차림.값.`로 치환

2) `글바꾸기` (문자열 치환)
- 상태: `LEGACY_ALLOWED_INPUT_ONLY`
- 규칙:
  - 입력에서는 허용한다(호환).
  - 문서/예제/팩/AI 정답/정본 출력에서는 사용 금지.
  - 정본 문자열 치환 API는 별도 DR로 설계 후, 그때 `PROMOTED_CANON` 또는 `REMOVED`로 전환한다.

### 도구 연계: fixits-json (MUST)
- 레거시가 발견되면 `fixits-json`에 `suggestion.kind="replace"`로 정본 이름을 제안한다.
- `번째`는 자동 치환이 가능하도록 최소 1개 fixit을 제공해야 한다.

### DoD
- `docs/status/STDLIB_ALIAS_TABLE.md`에 `번째 -> 차림.값 / a[i]`를 공식 별칭으로 기록한다.
- `docs/status/STDLIB_IMPL_MATRIX.md`에 레거시 상태(enum) 칼럼이 추가되고, 위 두 항목의 상태가 반영된다.
- pack:
  - 정본 사용 pack 1개 이상(정답은 정본만)
  - 레거시 입력 허용 pack 1개 이상(입력에는 레거시, 정본 출력은 정본)

---

## DR-092 — AGE2(Open) “열림(Open) 봉인” 최소 규격 v1 (문법 변화 0안)

- 상태: 채택
- 날짜: 2026-01-26

### 목적
- AGE2(Open)에서 **비결정 입력(벽시계/파일/네트워크/호스트 FFI 등)**을 “기록→리플레이”로 감싸
  재현 가능한 실행(감사/리플레이)을 보장한다.
- 본 결정은 **또니랑 본문 문법을 바꾸지 않는(0안)** 방식으로도 완주 가능하도록 규격을 고정한다.

### 용어
- **열림(Open)**: 실행 결과가 실행 환경에 의해 달라질 수 있는 외부 입력/호출.
- **기록(record)**: 실행 중 열림 호출의 입력/출력을 로그에 남김.
- **리플레이(replay)**: 실행 중 열림 호출을 실제로 수행하지 않고(재호출 금지) 로그 값을 재주입.

### 정책(최소)
1) 기본 모드(정준): `deny`
- 열림 호출이 발생하면 즉시 진단(`E_OPEN_DENIED`) 후 중단.

2) 실행 모드 3종(도구줄/런타임 정책)
- `open=record`: 실제 호출 + 결과 기록
- `open=replay`: **실호출 금지**, 기록값 재주입
- `open=deny`: 기본값(차단)

3) 정준 규칙(MUST)
- replay 모드에서는 동일한 호출(site + key)에 대해 **항상 기록값만** 사용한다(재호출 금지).
- record 모드에서 생성된 로그는 replay 모드에서 **1:1 재현**되어야 한다.

### 구현 표면(0안: 문법 변화 없이)
- 도구줄(예시):
  - `teul-cli run --open=record ...`
  - `teul-cli run --open=replay --open-log=<path> ...`
- 표준 가지 API(예시):
  - `열림.시각.지금.`
  - `열림.파일.읽기(경로=...).`
  - 위 API는 모드에 따라 record/replay/deny 정책을 따른다.

### 로그(최소)
- `open.log.jsonl`(이름은 SSOT_TOOLCHAIN에서 정준화)
- 레코드 최소 필드:
  - `event_kind="open"`
  - `open_kind` (clock/file/net/ffi/…)
  - `site_id` (정본화된 호출 위치 식별자)
  - `key` (입력 식별: 예 경로/URL 등)
  - `value` (결과: DetJson)
  - `detjson_hash` (value 해시)

### DoD
- pack 2종(최소):
  - `pack/open_clock_record_replay/*` : 벽시계 열림의 기록→리플레이 검증
  - `pack/open_file_read_record_replay/*` : 파일 읽기의 기록→리플레이 검증
- replay 모드에서 열림 실호출이 발생하면 반드시 실패(진단)한다.

---

## DR-093 — AGE2(Open) 파일 상단 지시문 `#열림 허용(...)` (옵션 1안)

- 상태: 채택
- 날짜: 2026-01-26

### 목적
- 열림(Open) 사용 의도를 소스 상단에 명시하여 리뷰/감사/도구 진단을 쉽게 한다.
- DR-092(0안)과 **양립**한다: 이 지시문은 “가독성/도구 진단”을 위한 추가 표면이며,
  실행의 결정성은 record/replay/deny 정책으로 유지한다.

### 문법(최소)
- 파일 상단 지시문:
  - `#열림 허용(시각, 파일읽기, 네트워크, 호스트FFI, ...)`
- 인자 목록은 식별자(키워드)들의 나열이다.
- 같은 파일에 여러 줄로 나누어 쓸 수 있으며, 합집합으로 해석한다.

### 의미(최소)
- 이 지시문은 “허용 범주 선언”이다.
- 도구/런타임은 다음을 수행 SHOULD:
  - 선언되지 않은 open_kind 사용 시 `W_OPEN_NOT_DECLARED`(경고) 또는 `E_OPEN_NOT_DECLARED`(옵션) 진단.
- 단, 최종 허용/차단은 **실행 모드(open=record/replay/deny) 및 정책 파일**이 결정한다.

### 범위
- 본 지시문은 AGE2(Open)에서 사용 가능.
- Gate0/AGE1에서도 주석처럼 무시해도 되며(파서가 지시문을 통과), 실행 의미는 AGE2에서만 활성화.

### DoD
- pack 1종(최소):
  - `pack/open_decl_policy/*`: 선언 누락 경고/오류가 결정적으로 나옴을 검증

---

## DR-094 — AGE3(Bogae) 최소 규격 v1: 제7고개(기) W67~W77

- 상태: 채택
- 날짜: 2026-01-26
- 목적:
  - 보개(Bogae)를 “결정적 코어 상태”와 분리하여, **같은 입력이면 같은 보개 산출(detbin/bogae_hash)**이 나오도록 고정한다.
  - 매핑(선호) 기반으로 **자산/매핑/어댑터/뷰어/에디터 최소 루프**를 만든다.
- 범위(MUST):
  1) **BogaeAdapterV1**
     - 입력(결정적): 태그/형상/자산참조 + frame_id
     - 출력(결정적): `BogaeDrawListV2(detbin)` 또는 `BogaeSceneV1(DetJson)`
  2) **AssetManifestV1**
     - 자산은 내용기반 주소(해시)로 참조(경로는 별칭)
  3) **BogaeMappingV1(선호)**
     - 태그→Rect/Text/Sprite 최소 매핑
     - 충돌 규칙 1개로 고정(rule_id 오름차순)
  4) **WebViewerV1**
     - drawlist/scene 렌더 + `bogae_hash`, `cmd_count`, `frame_count` 출력
  5) **EditorV0**
     - 선택/이동/속성 변경/저장(최소). 저장 포맷은 SceneV1부터(권장)
  6) **결정성 규칙**
     - 픽셀은 비결정이어도 무방. **정본 대상은 detbin/bogae_hash**
     - `bogae_hash = blake3(detbin)`로 고정
- 범위(OUT-OF-SCOPE):
  - 고급 에디터(타임라인/키프레임), 고급 도형(Path/Circle), 고급 텍스트 레이아웃, 셰이더/파티클 등
- DoD:
  - pack 최소 6종:
    - `pack/bogae_adapter_v1_smoke/*`
    - `pack/bogae_asset_manifest_v1/*`
    - `pack/bogae_mapping_v1/*`
    - `pack/bogae_web_viewer_v1/*`
    - `pack/bogae_hash_determinism_v1/*`
    - `pack/bogae_bundle_v1/*`
  - demo 1종:
    - `pack/gogae7_demo_*`에서 `bogae_hash`가 골든으로 고정됨

---

## DR-095 — 셈그림 테트리스 de-verbose 표준 패턴 v1 (문법 추가 없이)

- 상태: 채택
- 날짜: 2026-01-26
- 근거: `docs/context/proposals/PROPOSAL_SEMGIRIM_TETRIS_DEVERBOSE_v20.2.0.md`

### 목적
- 테트리스(격자/블록/칸 렌더링) 구현에서 “바탕.* 과도 / 반복 코드 과도”를 줄인다.
- 문법 추가 없이(브로드캐스트/동적 엔티티 접근 없이) **차림 + 반복 + 좌표변환 셈씨**로 de-verbose를 달성한다.

### 표준 패턴(v1)
1) **좌표변환 셈씨(이름 있는 셈씨)**
- 씨앗(익명함수) 표기 `{x | 식}`와 충돌을 피하기 위해,
  `격자.픽셀.`은 “이름 있는 셈씨”로 둔다.
- 예:
  - `격자.픽셀(원점_x, 원점_y, 격자_x, 격자_y, 셀) -> (x, y)`

2) **블록 4칸을 차림으로 관리**
- `블록_칸들:(묶음)차림 = [ (dx=0,dy=0), ... ]` 형태로 고정
- 반복은 `마다/모두` 블록 임자(지역 변수)로 처리해 `바탕.*`를 줄인다.

3) **칸 엔티티도 차림으로 묶어 1:1 갱신(AGE1 안전형)**
- “모든 수집”(ECS 쿼리)은 후속(AGE2+)로 이월하고,
  AGE1에서는 `칸들 = [칸1,칸2,칸3,칸4]`처럼 명시적 차림을 정본 예제로 둔다.
- 각 칸 엔티티는 같은 인덱스의 블록 칸 오프셋에 대응한다.

### 후속(이월)
- 안2(“모든 수집” 기반 자동 매칭/서열 키)는 AGE2+에서 별도 결정으로 다룬다.

### DoD
- 예제/팩에서 정본 이름만 사용한다(레거시 이름 금지, fixit만 허용).
- `pack/semgirim_tetris_pixels_v1/*`에서 좌표/픽셀 목록 결과가 결정적으로 고정된다.

---

## DR-096 — 격자→픽셀 좌표변환 표준 호출 형태 v1 (테트리스 de-verbose 정합)

- 상태: 채택
- 날짜: 2026-01-26

### 목적
- 테트리스/격자 기반 렌더링에서 “좌표변환”을 또니랑다운 호출 형태로 통일한다.
- 괄호 나열형 `격자.픽셀.` 표기는 정본 예제/팩/AI 정답에서 사용하지 않는다.

### 정본 호출 형태(표준)
- 좌표변환은 “이름 있는 셈씨” `격자.픽셀.` 로 제공한다.
- 호출은 **명명 인자 + 꼬리마침(.)** 형태로 통일한다.

예:
```ddn
픽셀 = (대상=(dx,dy), 원점=(ox,oy), 셀=(sx,sy)) 격자.픽셀.
```

### 권장 확장(선택)
- 격자 설정을 재사용하려면(객체처럼):
```ddn
격자설정 = (원점=(ox,oy), 셀=(sx,sy)) 격자.만들기.
픽셀 = (대상=(dx,dy), 설정=격자설정) 격자.픽셀.
```

### 레거시/별칭(정본 금지)
- `격자.픽셀.` 같은 괄호 나열형 호출은 **입력 편의 별칭으로만** 허용할 수 있다.
- 정본 출력 범위(canon/팩/문서/AI 정답)에서는 항상 위 “정본 호출 형태”로 출력한다.

### DoD
- `DR-095`(테트리스 de-verbose) 예제/팩/문서에서 좌표변환은 `격자.픽셀.` 정본 호출만 사용한다.
- fixits-json은 `격자.픽셀.` 발견 시 `격자.픽셀.`로 치환 제안을 제공할 수 있다(SHOULD).

---

## DR-097 — 용어 표준화 v1: entity/ECS/binder/handle (순우리말)

- 상태: 채택
- 날짜: 2026-01-26

### 목적
- 엔티티/컴포넌트/ECS/바인더 용어를 순우리말로 통일하여 문서/예제/AI 출력의 일관성을 높인다.

### 표준 용어(정본)
- entity → **임자**
- entity ref/handle → **임자가리킴**
- entity set/collection → **임자무리**
- component → **붙이**
- ECS → **임자-붙이 짜임** (정본) / **임자-붙이 틀** (별칭)
- binder(블록의 이름 바인더) → **매김이**
  - 기본 매김이 이름: `매마디`
  - `그것`은 “현재 매김이(=매마디)”의 별칭으로 유지

### 사용 원칙
- 문서/팩/정본 출력(정본 범위)에서는 영문 용어(entity/component/ECS/binder)를 쓰지 않는다.
- `임자가르킴` 표기는 비권장으로 두고, 정본은 `임자가리킴`만 사용한다.

### DoD
- SSOT_TERMS에 위 매핑 표가 추가된다.
- 이후 신규 DR/PLN에서 관련 용어는 정본 용어를 사용한다.

---

## DR-098 — 임자무리(임자가리킴 차림) v1 (Claude Option A 채택)

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_LANG_ENTITY_ARRAY_2026-01-30.md`

### 목적
- 테트리스 등에서 `임자1, 임자2, 임자3...` 반복 갱신을 **차림+반복**으로 de-verbose 한다.
- 문법 추가 최소화: 기존 차림 리터럴을 그대로 사용하되, “임자 이름의 값 평가” 규칙만 고정한다.

### 규칙(v1)
1) **임자 이름의 값 평가**
- 임자 이름이 “값 위치”에 나타나면 그 값은 **임자가리킴**이다.
  - 예: `임자무리 <- [현재, 현재1, 현재2, 현재3].`
  - 이때 차림의 원소 타입은 `임자가리킴`이다.

2) **임자무리 순회**
- `(칸) 임자무리에 대해: Ellipsis` 에서 `칸`(매김이)은 각 원소(임자가리킴)에 바인딩된다.
- 순회 순서는 차림 인덱스 증가 순서(결정적).

3) **인덱스 접근 정책(일관성)**
- `임자무리[i]`는 차림 인덱싱 규칙을 따른다:
  - 범위 밖이면 `없음`.
- `없음`에 대한 필드 접근/대입은 FATAL 진단:
  - `E_NONE_FIELD_ACCESS` (또는 기존 none 관련 진단 코드가 있다면 그 코드로 통일)

4) **필드 접근/대입**
- `임자가리킴.붙이.필드 <- 값.` 형태의 필드 대입을 허용한다.
- `임자무리[i].붙이.필드 <- 값.` 는
  - “차림 원소 대입”이 아니라 “임자가리킴을 통해 필드 대입”으로 해석한다(허용).

### 금지/보류
- 동적 임자 생성(Option B)은 AGE3+로 이월.
- 문자열 기반 임자 조회(Option C)는 비권장/미지원으로 유지.

### DoD
- pack 3종:
  1) `pack/imja_muri_basic_update/*` : 임자무리 선언 + 반복 갱신
  2) `pack/imja_muri_oob_none_field/*` : OOB→없음 + none 필드 접근 FATAL
  3) `pack/imja_muri_nested_component/*` : `임자가리킴.붙이.필드` 갱신

---

## DR-099 — 제8고개(기) W78 병렬 터(Realms) 최소 규격 v1 (PR-1)

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR1_W78_PARALLEL_REALMS_IMPL_v20.2.3_20260130_480b3855.md`

### 목적
- 여러 “터(Realm)”를 동시에 진행하더라도, 각 터의 `state_hash`가 **서로 간섭 없이 독립적으로** 생성되도록 한다.
- 순차(threads=1)와 병렬(threads=N) 실행의 결과가 **완전히 동일**해야 한다(결정적 병렬).

### 최소 데이터 모델(v1)
- `RealmId`: 0..realm_count-1
- `Realm`:
  - `id`
  - `world`
  - `rng` (realm 전용)
  - `madi` (realm 전용)
  - `state_hash` (캐시 가능)
- `MultiRealmManager`:
  - `realms: Vec<Realm>`
  - `master_seed: u64`
  - `thread_mode: Seq | Rayon(n) | Auto`

### 결정성 규칙(v1)
1) **realm별 시드 파생(필수)**
- 전역 RNG 공유 금지.
- `seed_i = mix64(master_seed, realm_id)` (순수 함수)로 realm별 독립 RNG를 만든다.

2) **입력 정렬/정본화**
- step_batch 입력(행동/명령)은 최소한 `realm_id 오름차순`으로 정렬된다.
- (후속) agent_id가 도입되면 `realm_id, agent_id` 정렬 규칙을 동일하게 적용한다.

3) **병렬 write 위치 고정**
- `outputs[realm_id]`를 미리 할당하고,
  각 realm step은 자기 인덱스에만 write한다.
- 스케줄이 달라도 outputs는 동일해야 한다.

4) **state_hash 규격**
- world 상태는 정규 직렬화(DetJson 또는 DetBin) 후 해시(blake3)를 권장한다.
- 포인터/주소/비결정 순회를 포함하지 않는다.

### DoD
- `pack/gogae8_w78_parallel_realms/*`에서 아래 2개 golden이 **동일 기대값**으로 통과한다.
  - A) `--threads=1` (순차)
  - B) `--threads=8` (병렬)
- realm 간 격리성: realm 0만 step 했을 때 realm 1..의 `state_hash`는 변하지 않는다.

---

## DR-100 — 샘/거울 최소 스키마 v0 (sam.input.v0 / geoul.record.v0)

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_SAM_GEOUL_MIN_SCHEMA_2026-01-30.md`

### 목적
- Gate0/AGE1에서 “입력(샘) → 실행/기록(거울)”을 **결정적으로 저장/리플레이**할 수 있는 최소 계약을 고정한다.
- Seamgrim UI MVP 및 pack/golden이 동일 스키마를 공유하도록 한다.

### 정본 스키마 이름
- 입력 스냅샷: `sam.input.v0`
- 실행/기록: `geoul.record.v0`
- 별칭 표기(문서 편의): `input_snapshot.v0`, `replay_log.v0` (정본 출력은 정본 이름만)

---

## sam.input.v0 (입력 스냅샷)

### 파일
- JSON (단일 객체) 또는 JSONL(확장) 중 v0는 JSON 1개를 정본으로 한다.

### 필수 필드
- `schema`: `"sam.input.v0"`
- `meta`:
  - `ssot_version`: `"vMAJOR.MINOR.PATCH"`
  - `created_at`: ISO8601
  - `run_id`: 문자열(선택적)
- `events`: 배열(시간 순)

### event 최소 스키마(v0)
- 키 입력 이벤트(필수 지원, v0 최소):
```json
{"t":123,"kind":"key","key":"Key.Space","down":true}
```

- 권장 확장(원문(raw) + 물리 code 보존):
```json
{"t":123,"kind":"key","key":"Key.Space","down":true,"raw_key":"스페이스","raw_code":"Space","code":"Code.Space","keymap":"keymap_v1"}
```

- `t`: 정수(틱 또는 ms, 프로젝트가 1개로 고정)
- `kind`: `"key"`
- `key`: 정본 키 문자열(예: `Key.Space`, `Key.ArrowLeft`)
  - 별칭/원문 입력은 DR-086에 따라 정본 키로 치환된다(MUST).
- `down`: bool

- (선택) `raw_key`: 원문 키(사용자 입력 문자열 또는 플랫폼의 key 문자열). 디버그/가독성용.
- (선택) `raw_code`: 원문 물리키(플랫폼 code/scan code 문자열). 디버그/검증용.
- (선택) `code`: 정본 물리키 코드 문자열(예: `Code.ShiftLeft`, `Code.KeyA`). 정본화 규칙은 DR-086의 `keymap_v1`을 따른다.
- (선택) `keymap`: `"keymap_v1"` (기본값). 다른 버전은 DR로만 도입한다.

- 실패 정책(요약):
  - `key`가 정본 후보 집합 밖이면 FATAL(`E_INPUT_KEY_UNSUPPORTED`)
  - `raw_*`는 의미에 영향을 주지 않는다(정본 키만 의미).
### MAY(확장)
- 마우스/포인터/패드 이벤트는 v0에서 MAY

---

## geoul.record.v0 (실행/기록)

### 파일
- JSONL(라인당 1 레코드)을 정본으로 한다.

### 파일 헤더(첫 레코드, MUST)
```json
{"schema":"geoul.record.v0","meta":{"ssot_version":"v...","created_at":"...","cmd":"..."}}
```

### step 레코드(반복, MUST)
- 최소 필드:
  - `kind`: `"step"`
  - `step`: 정수
  - `state_hash`: 문자열(필수)
  - `inputs_ref`: 입력 참조(선택, `sam.input.v0`의 이벤트 구간 또는 해시)
- 선택 필드:
  - `bogae_hash` (표시 레일)
  - `trace_hash` (추적 레일)
  - `diag_hash` (진단 레일)
  - `extras` (DetJson)

### hash 규칙
- `state_hash`는 MUST.
- DetJson/DetBin 정본화 규칙은 SSOT_TOOLCHAIN의 정본 규칙을 따른다(중복 서술 금지).

### DoD
- pack 2종:
  - `pack/sam_min_schema_v0/*`: 입력 스냅샷 작성/파싱/정본화
  - `pack/geoul_min_schema_v0/*`: record 헤더+step 레코드 생성/검증
- Seamgrim UI MVP는 v0부터 이 스키마로 I/O를 한다.

---

## DR-101 — 제8고개(기) “배움의 깊이(78~88)” 실행 트랙 v1 (범위/우선순위 고정)

- 상태: 채택
- 날짜: 2026-01-30
- 근거:
  - `docs/context/proposals/PROPOSAL_GOGAE8_LEARNING_DEPTH_PLAN_v20.2.3_20260130_480b3855.md`

### 목적
- 78~88걸음에서 “학습→검증→배포” 파이프라인을 결정적으로 닫는다.
- 각 걸음은 PR/pack 단위로 쪼개며, 고개8의 최소 가치(Fast Path)를 먼저 완주한다.

### Fast Path(권장 순서)
1) W78 병렬 터(Realms)
2) W80 NuriGym RL API 브리지
3) W81 보상 엔진/DSL
4) W82 슬기 공방 v2(학습) — toy trainer + artifact
5) W87 평가 스위트(후속 문서)
6) W88 배포/쇼케이스(후속 문서)

### 공통 원칙
- 동일 입력/시드 → 동일 `state_hash`
- 병렬/순차/백엔드가 달라도 결과가 같아야 함(허용되는 det_tier는 별도 규칙)
- 모든 DoD는 pack(골든) 통과로 판정한다.

---

## DR-102 — W79 GPU 워프(Warp) 가속 최소 규격 v1 (backend + 결정성 정책)

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR2_W79_GPU_WARP_IMPL_v20.2.3_20260130_480b3855.md`

### 결정
- `WarpMode = Off | Cpu | Gpu` 를 정의한다.
- 데이터 레이아웃은 SoA를 권장 정준으로 둔다(SoA가 정본, AoS는 내부 최적화로만).
- 결정성 정책(현실적 2단계):
  - **정책 A(기본)**: GPU는 `det_tier=D-FAST`에서만 허용. `D-STRICT`는 Cpu로 강제(fallback).
  - (후속) 정책 B: Fixed 기반 커널로 CPU/GPU 비트 동일성을 달성.

### DoD
- 벤치 출력(DetJson) 존재: `cpu_ms`, `gpu_ms`, `speedup`, `warp_mode`, `realm_count`, `step_count`
- (옵션) GPU 스모크 pack은 GPU 없는 환경에서 skip 규칙을 가진다.

---

## DR-103 — W80 NuriGym RL API 브리지 최소 규격 v1 (훈련/실행 분리)

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR3_W80_NURIGYM_RL_API_IMPL_v20.2.3_20260130_480b3855.md`

### 결정
- DR-075(NuriGym 최소 스키마 v1)를 구현/팩으로 고정한다(episode/step/dataset JSONL + DetJson hash).
- 1차 브리지는 **in-process**를 정준으로 둔다(Zero-copy 최단 경로).
- 훈련/실행 분리: 학습은 외부, 코어는 실행/리플레이가 결정적이어야 한다.

### DoD
- `pack/nuri_gym_cartpole_v1/*` 통과(고정 action 시퀀스 → 고정 dataset_hash)
- Python 최소 바인딩(reset/step/observe) 스모크.

---

## DR-104 — W81 RewardScriptV1 + RewardEngine 최소 규격 v1 (결정적 집계)

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR4_W81_REWARD_ENGINE_IMPL_v20.2.3_20260130_480b3855.md`

### 결정
- RewardScriptV1은 “식” 최소 집합으로 시작한다(산술/비교/min/max/clamp/if).
- 기본 계산은 Fixed64(Q32.32)로 고정(D-STRICT).
- realm 집계 순서는 `realm_id` 오름차순으로 고정(간섭 금지).
- 오류 정책: 0으로 나누기/NaN 등은 FATAL.

### DoD
- `pack/gogae8_w81_reward_v1/*` 통과(동일 입력 → 동일 reward 로그/리포트)

---

## DR-105 — W82 슬기 공방 v2(학습) 최소 규격 v1 (toy trainer + artifact)

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR5_W82_SEULGI_WORKSHOP_V2_TRAIN_IMPL_v20.2.3_20260130_480b3855.md`

### 결정
- 학습 자체는 확률/부동소수로 완전 재현이 어렵다. v1에서는 **toy trainer**로 파이프라인을 결정적으로 고정한다.
- run_id는 `_rN` 없이 `YYYYMMDDHHMM_sha8` 또는 `hash(config+seed)`로 결정적으로 만든다.
- artifact 저장 정책(v1): **첫 임계값 도달 1회 저장**.
- artifact 메타에는 `ssot_version`, `ssot_bundle_hash`, `train_config_hash`, `eval_report_hash`, `weights_hash`가 MUST.

### DoD
- `pack/gogae8_w82_seulgi_train_v2/*` 통과(임계값 도달→artifact 생성 골든)

---

## DR-106 — W83 교과서 가지(Edu) 정확도 검증 최소 규격 v1

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR6_W83_EDU_PACKS_ACCURACY_IMPL_v20.2.3_20260130_480b3855.md`

### 결정
- EduScenarioV1 / EduReportV1 스키마를 DetJson으로 고정한다.
- 오차/일치도 계산 규칙을 고정한다:
  - `abs_err = |sim-formula|`
  - `rel_err = abs_err / max(|formula|, eps)`
  - `match_ratio = pass_count/total_count`
- 최소 2 시나리오로 시작(등가속도 1D, 단진자 작은각도).

### DoD
- `pack/gogae8_w83_edu_accuracy_v1/*` 통과(match_ratio>=0.999)

---

## DR-107 — W84 군집 결정성 최소 규격 v1 (충돌/행동 처리 순서 고정)

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR7_W84_SWARM_DETERMINISM_IMPL_v20.2.3_20260130_480b3855.md`

### 결정
- 충돌 후보 쌍은 `(min_id,max_id)`로 정규화하고, `min_id,max_id` 오름차순으로 정렬 후 처리한다.
- 행동(action)은 `agent_id` 오름차순으로 적용한다. 중복 id는 FATAL.
- state_hash는 정규 직렬화 후 해시(blake3).

### DoD
- `pack/gogae8_w84_swarm_deterministic_collision/*` 통과(동일 입력→동일 collision_log/state_hash)

---

## DR-108 — W85 온디바이스 슬기(WASM) 추론 최소 규격 v1 (결정적 MLP)

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR8_W85_ONDEVICE_SEULGI_WASM_IMPL_v20.2.3_20260130_480b3855.md`

### 결정
- 모델 포맷 v1: MLP + detjson(구조/양자화) + detbin(가중치) + model_hash.
- 추론은 정수 양자화(Int8/Int16) 기반을 권장 정준으로 둔다(플랫폼 차이 최소화).
- 성능 목표(운영): 50ms 내 추론. (pack은 “정확 출력”만 고정, 성능은 벤치로 관리)

### DoD
- `pack/gogae8_w85_ondevice_infer_v1/*` 통과(고정 입력→고정 출력)

---

## DR-109 — W86 모방학습(역사 기반) 최소 규격 v1 (리플레이→데이터셋→오차 감소)

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR9_W86_IMITATION_LEARNING_IMPL_v20.2.3_20260130_480b3855.md`

### 결정
- metrics curve 출력 파일을 정준화한다:
  - 파일명: `metrics_curve.detjsonl`
  - 라인 스키마: `seulgi.imitation_metric.v1`
  - 필드:
    - `epoch` (1..max_epochs)
    - `mismatch` (0..total)
    - `total` (>0)
    - `action_error_rate` = mismatch/total (Fixed64 Q32.32 문자열)
    - `dataset_hash` (정렬된 dataset JSONL 전체 sha256)
    - `curve_kind` = `"synthetic" | "measured"` (기본 `"synthetic"`)
- 단조 감소 규칙:
  - `curve_kind="synthetic"`인 경우 `mismatch`는 epoch 증가에 따라 **비증가(MUST)**.
  - `curve_kind="measured"`인 경우 단조 감소는 **권장(SHOULD)**이며, 위반은 오류가 아니다.
- 오류:
  - `total==0`이면 `E_IMI_TOTAL_ZERO`
  - `action_error_rate`가 [0,1] 범위를 벗어나면 `E_IMI_RATE_RANGE`

- replay/episode JSONL → supervised dataset JSONL 변환 규칙을 고정한다(정렬: episode_id, step_index 오름차순).
- metric: `action_error_rate = mismatch/total` 를 epoch별로 DetJson으로 기록한다.
- v1은 toy trainer로 “오차 감소 곡선”을 결정적으로 골든에 고정한다.

### DoD
- `pack/gogae8_w86_imitation_learning_v1/*` 통과(metrics_curve 범위 내)

---

## DR-110 — W87 EvalSuiteV1 + CertMark(다손 슬기) 최소 규격 v1

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR10_W87_EVAL_SUITE_CERT_IMPL_v20.2.3_20260130_480b3855.md`

### 목적
- 표준 평가를 통과한 모델(artifact)에만 **인증 마크**를 부여한다.
- 평가/리포트/마크 부여가 결정적으로 재현되어야 하며 pack으로 잠근다.

### EvalSuiteV1 (최소)
- suite_id: `cartpole1d_v1`
- seeds: `[0..9]` (정준)
- max_steps: 고정
- metric: `avg_score`
- threshold: v1에서 고정(예: `avg_score >= 195`)

### EvalReportV1 (DetJson)
- 필드(최소):
  - `model_hash`, `suite_id`, `seeds`, `scores[]`, `avg_score`, `pass`, `report_hash`

### CertMark(다손 슬기)
- pass=true면 artifact에:
  - `cert_mark="dasond_seulgi"`
  - `cert_report_hash=<report_hash>`
- pass=false면 위 필드는 없다.

### DoD
- pack 2케이스(PASS/FAIL) 고정: `pack/gogae8_w87_eval_suite_v1/*`

---

## DR-111 — W88 SeulgiBundleV1 + Hash Parity(네이티브/wasm 동일) 최소 규격 v1

- 상태: 채택
- 날짜: 2026-01-30
- 근거: `docs/context/proposals/PROPOSAL_GOGAE8_PR11_W88_INTEGRATION_HASH_PARITY_IMPL_v20.2.3_20260130_480b3855.md`

### 목적
- 모델 번들을 만들고, 네이티브/wasm 어느 환경에서도 **동일 입력→동일 출력 해시**를 보장한다.

### SeulgiBundleV1 (번들 구조)
- `bundle_in/`:
  - `manifest.detjson`, `model_mlp_v1.detjson`, `weights_v1.detbin`, `eval_report.detjson`(옵션)
- manifest 필드(최소):
  - `ssot_version`, `ssot_bundle_hash`, `toolchain_version`, `model_hash`, `artifact_hash`, `eval_report_hash`, `cert_mark`(옵션)

### Hash Parity 테스트
- inputs.detjson / outputs.detjson / outputs_hash.txt
- 네이티브와 wasm이 동일 outputs_hash를 만들어야 한다.

### DoD
- pack 1개: `pack/gogae8_w88_bundle_hash_parity/*`
---

## DR-112 — 루트 상태 용어 정본화(`살림`→`바탕`) + 접두 생략 모드(`#바탕숨김`)

- 상태: 채택
- 핵심:
  - 루트 상태/자원 컨테이너의 정본 용어를 **`바탕`**으로 정한다.
  - 기존 표기 **`살림`**은 레거시 별칭(입력 호환)으로 유지할 수 있다.
  - 교육/예제에서 접두를 줄이기 위해 `#바탕숨김`을 도입하되,
    정본 출력은 항상 `바탕.`을 드러내어 감사/재현성을 보존한다.
- 근거:
  - `살림`은 일상어 뉘앙스가 강해 코드에서 “전역변수”처럼 오해될 수 있음.
  - `바탕`은 “기반/컨텍스트” 의미가 강해 설계 의도(실행 단위 상태 봉투)에 더 부합.
  - 접두 생략은 학습 가독성을 크게 개선하지만, 오타/새 칸 생성 위험이 있어 안전장치를 권장.
- 관련:
  - `SSOT_TERMS_v20.6.33.md` (용어 정본/레거시)
  - `SSOT_LANG_v20.6.33.md` ROOT-HIDE-01, 시스템 뿌리 별칭표
  - `SSOT_TOOLCHAIN_v20.6.33.md` 정본화 출력/레거시 경고
---

## DR-113 — 셈씨 결과는 “셈씨 이름(결과칸)에 대입”으로 표현

- 상태: 채택
- 핵심:
  - 셈씨 본문에서 **셈씨 이름은 결과칸(암묵 바인더)** 이다.
  - 반환은 `이름 <- …` 대입으로 표현한다. (별도의 반환 키워드/셈씨는 현행 정본 문법에 없다.)
  - 실행/호출은 `~기/~하기` 꼬리이며, 인자는 앞에 온다: `(… )더하기.`
- 근거:
  - 교육/가독성: 반환 경로를 단일 패턴으로 통일.
  - 결정성/감사: 결과 위치가 명확하며 정본화 출력도 안정적.
- 영향:
  - SSOT_LANG: [SEMSI-RESULT-01] 규칙 블록 추가
---

## DR-114 — `#바탕숨김`의 안전장치: 쓰기(대입) = 바탕칸 사전 등록 필수

- 상태: 채택(권장 규칙)
- 핵심:
  - `#바탕숨김` 모드에서 `<이름> <- ...` (쓰기/대입)는 **바탕칸에 사전 등록된 이름만** 허용한다.
  - 바탕칸 등록은 `바탕칸: { … }.` 선언으로 수행한다.
- 근거:
  - 접두 생략의 최대 리스크는 오타로 인한 “조용한 새 칸 생성”.
  - 사전 등록을 통해 결정성/감사/디버깅을 강화한다.
- 관련:
  - SSOT_LANG: [ROOT-HIDE-02], [ROOT-DECL-01]
---

## DR-115 — “바탕칸” 명칭 정리: 선언은 `바탕칸표:`가 정본, `바탕칸:`은 레거시 별칭

- 상태: 채택(정본 용어 정리)
- 핵심:
  - `바탕칸표:`는 “바탕(루트)의 칸(슬롯) **목록/표를 선언**”하는 문장이다.
  - 같은 패턴으로 `셈씨칸/움직씨칸` 같은 용어를 만들 필요는 없다.
    - 셈씨 내부의 반환 자리는 “결과칸(셈씨 이름)”으로 다룬다. (SEMSI-RESULT-01)
  - 입력 호환을 위해 `바탕칸:`을 레거시 별칭으로 허용할 수 있으나, 정본 출력은 `바탕칸표:`로 수렴한다.
- 근거:
  - `바탕칸:`은 “칸 그 자체”처럼 읽혀, 다른 문법 요소에도 동일한 ‘…칸’이 필요하다는 오해를 유발할 수 있음.
  - `…표`를 붙이면 “등록/선언 목록”임이 즉시 드러난다.
- 관련:
  - SSOT_LANG: [ROOT-DECL-01], [ROOT-HIDE-02]
---

## DR-116 — 변수/상수/값/선언/초기화의 정본 순우리말: 그릇/붙박이/알맹이/채비/마련

- 상태: 채택
- 핵심:
  - 변수 = 그릇, 상수 = 붙박이, 값 = 알맹이
  - 선언 = 채비, 초기화 = 마련
- 목적:
  - “전역변수/슬롯/지역” 혼선을 ‘그릇(공간)’ 개념으로 통일하여 설명 가능하게 한다.
- 관련:
  - SSOT_TERMS: “변수/상수/값/선언/초기화 — 정본 순우리말”
---

## DR-117 — 선언 문장 정본화: `그릇채비:`/`붙박이채비:` + 스코프(전역/지역) 규칙

- 상태: 채택(정본 문법 정리)
- 핵심:
  - 선언은 `채비`로 표현한다. 변수는 `그릇채비:`로 채비하고, 상수는 **반드시 마련**해야 하므로 `붙박이마련:`으로 마련한다.
  - 전역 자리(파일 최상위)에서의 채비는 전역 그릇/붙박이 선언이며,
    블록 내부(셈씨/움직씨 본문)에서의 채비는 지역 그릇/붙박이 선언이다.
  - `#바탕숨김` 모드에서의 쓰기(대입)는 “미리 채비된 이름”만 허용하는 것을 권장한다.
- 비고:
  - 과거 문서의 `바탕칸표:`(또는 `바탕칸:`)는 “바탕 생략 안전장치”를 설명하기 위한 임시 명칭이었으며,
    정본은 `그릇채비:`로 수렴한다(입력 호환은 구현체 선택).
- 관련:
  - SSOT_LANG: [ROOT-HIDE-02], [GUREUT-DECL-01]
---

## DR-118 — 상수(붙박이)는 ‘채비만’ 불가: 정본 문장은 `붙박이마련:`

- 상태: 채택
- 핵심:
  - 붙박이(상수)는 **반드시 알맹이를 마련**해야 한다.
  - 따라서 상수 선언은 `붙박이채비:`가 아니라 **`붙박이마련:`** 으로 표현한다(선언+초기화를 동시 수행).
- 문법(권장):
  - `붙박이마련:` 블록 항목은 `이름:형 = 식.` 형태로 초기 알맹이를 포함한다.
- 레거시:
  - 구현체가 필요 시 `붙박이채비:`를 `붙박이마련:`의 입력 별칭으로 허용할 수 있다(정본 출력은 마련으로 수렴).
- 관련:
  - SSOT_TERMS: 변수/상수/값/선언/초기화 용어 표
  - SSOT_LANG: [GUREUT-DECL-01]
---

## DR-119 — `=`는 정의, `<-`는 대입: 문맥 분리 고정

- 상태: 채택
- 핵심:
  - `=`는 “정의(Definition)” 문맥에서만 사용한다.
    - 셈씨/움직씨 정의, 붙박이마련(상수 정의+초기 알맹이) 등
  - `<-`는 “대입(Assignment)” 문맥에서만 사용한다.
    - 그릇(변수) 갱신, 결과칸 대입 등
- 근거:
  - 문장 역할을 기호 하나로 즉시 구분(읽기/교육/감사성↑).
  - 상수는 반드시 마련되어야 하므로 `붙박이마련` 항목은 정의(`=`)가 자연스럽다.
- 관련:
  - SSOT_LANG: [EQUAL-DEF-01], [ASSIGN-ARROW-01]
  - SSOT_TERMS: `=` vs `<-` 구분
---

## DR-120 — 그릇채비는 정의가 아니다: 변수는 `=` 금지, 초기값은 `<-`(첫 넣기)

- 상태: 채택
- 핵심:
  - 변수(그릇)는 바뀔 수 있으므로 **`=`로 정의하지 않는다.**
  - `그릇채비:`는 “형만” 또는 “형+첫 넣기(초기 대입)”를 지원한다.
    - `그릇채비: { 이름:형. }.`  
    - `그릇채비: { 이름:형 <- 식. }.`
  - `그릇채비:` 항목에서 `=`는 금지(오류 권장: `E-EQUAL-IN-GUREUT`).
- 관련:
  - SSOT_LANG: [GUREUT-DECL-02], [EQUAL-DEF-01], [ASSIGN-ARROW-01]
---



## DR-148 — 통합 선언 설탕: `채비:` 블록에서 `=`(붙박이)와 `<-`(그릇) 혼합 허용

- 상태: 채택
- 날짜: 2026-02-16
- 핵심:
  - 선언 머릿말을 2개(`그릇채비:`/`붙박이마련:`) 외우는 부담을 줄이기 위해, 입력 설탕으로 `채비:` 블록을 추가한다.
  - `채비:` 블록 내부에서
    - `이름:형 = 식.` 은 붙박이(상수) 마련으로,
    - `이름:형.` 또는 `이름:형 <- 식.` 은 그릇(변수) 채비로 해석한다.
  - 정본 출력은 항상 `그릇채비:` + `붙박이마련:`로 **분해 저장**하여, 정본 문서/골든의 표면형을 안정화한다.
- 주의:
  - `채비:` 내부에서 변수/붙박이로 같은 이름을 중복 선언하는 것은 오류로 잡는다.
- 관련:
  - SSOT_LANG: [GUREUT-DECL-01], [GUREUT-DECL-02], [GUREUT-DECL-03]
  - SSOT_LANG: [EQUAL-DEF-01], [ASSIGN-ARROW-01]
---

## DR-121 — DDN 파일 메타 헤더(`#키: 값`) 표준화

- 상태: 채택
- 날짜: 2026-02-01
- 핵심:
  - DDN 파일 최상단에 `#키: 값` 메타 헤더 블록을 허용한다.
  - 표준 키(최소): `#이름:`, `#설명:`
  - 메타 헤더는 실행 의미를 바꾸지 않으며 AST에 포함되지 않는다.
  - 중복 키는 마지막 값 우선 + 경고(권장).
- 근거:
  - 도구/뷰어(셈그림 UI 브리지/export)가 이미 `#이름:`/`#설명:`을 메타로 사용 중이며,
    SSOT에 명시가 없어 “문법/주석/도구 전용” 혼란이 있었다.
- 관련:
  - SSOT_LANG: [FILE-META-01]
  - SSOT_TOOLCHAIN: [TOOL-META-01]
---

## DR-122 — 셈그림 “5-보개” 기준 교과 매핑 + required_views + 보개 계약(채널 인터페이스)

- 상태: 채택
- 날짜: 2026-02-01
- 핵심:
  - 커리큘럼/팩 운영의 기준 보개를 5종(`2d/graph/table/text/structure`)으로 둔다.
  - lesson 메타는 `required_views`로 필수 보개를 선언한다.
  - 사용자 custom DDN을 위해 “보개 계약(필수 채널)”을 SSOT_LANG에 명시한다.
- 우선순위(권장):
  - graph → table → text → structure → 2d 확장
- 관련:
  - SSOT_TERMS: “보개 5종”
  - SSOT_LANG: [BOGAE-CONTRACT-01] / [BOGAE-VIEWSET-01]
  - SSOT_PLANS: “5-보개 우선순위(v0)”
---

## DR-123 — 셈그림 입력원 레지스트리/겹/타임줄/장면요약 + 보개 갱신 규칙(update+tick)

- 상태: 채택
- 날짜: 2026-02-01
- 핵심:
  - 입력원은 레지스트리로 관리한다(DDN-first 유지).
  - 오버레이는 겹(레이어) 단위로 관리하며 순서 이동을 보존한다.
  - View Dock에 타임줄(재생/정지/스크럽)을 두고, `t`/`tick`과 연동한다.
  - 보개 갱신은 update=append|replace 규칙(+ 선택적 tick)으로 표준화한다.
  - 선언형 장면요약(JSON) 프리뷰/저장을 지원한다.
- 관련:
  - SSOT_LANG: [BOGAE-UPDATE-01], [INPUT-REGISTRY-01]
  - SSOT_TOOLCHAIN: “Scene Summary”
  - SSOT_PLANS: “셈그림 UI 설계 정리(v0.3+)”
---

## DR-124 — 보개맞물림/구조 정체성/겹 비교 교육학 + control 입력원(직접조작)

- 상태: 채택
- 날짜: 2026-02-01
- 핵심:
  - 5-보개 기반에서 cross-view 동기화(보개맞물림)를 권장한다(t/tick/id 기준).
  - structure 보개는 “생각의 지도”로 정의하고(인과지도/결정트리/회로도 등), node-link 계약을 권장한다.
  - 겹(오버레이)은 정답겹/내겹/거울겹 패턴으로 교육학적으로 활용한다.
  - 직접조작 입력을 `control` 입력원으로 정의하고, 변경 시 DDN 재실행(DDN-first)을 유지한다.
- 관련:
  - SSOT_TERMS: “보개맞물림/정답겹/내겹”
  - SSOT_LANG: [CROSS-VIEW-01], [STRUCTURE-IDENTITY-01], [OVERLAY-PEDAGOGY-01], [INPUT-REGISTRY-01]
  - SSOT_TOOLCHAIN: Cross-View Interaction, control 입력원
  - SSOT_PLANS: W13-EXT pilot_phys_econ
---

## DR-125 — `보개장면 {}` 도입(한국어 Manim): DDN 내부 선언형 시간축 연출(AGE1+)

- 상태: 채택
- 날짜: 2026-02-01
- 배경:
  - “장면 계약/메타”만으로는 DDN 문법에서 어떻게 쓰는지 불명확하다는 지적이 있었다.
- 결정:
  - DDN에 `보개장면 { ... }` 특수 블록을 추가하여, 마디(구간) 기반 연출을 선언적으로 기술한다.
- 원칙:
  - DDN-first 유지: 계산 정본은 DDN, 보개장면은 연출 메타(tracks/commands)만 만든다.
  - 보개 간섭 금지: 보개 내부 렌더링을 직접 제어하지 않는다(화이트리스트된 연출 상태만).
  - Gate0는 파싱/정본화만, AGE1에서 최소 실행.
- 최소 기능(AGE1):
  - 연출동사 5종: 나타나기/사라지기/그려지기/움직이기/강조하기
  - 시간은 tick 정본, 초 표기는 fps 기반 설탕(정수 변환만 허용)
- 관련:
  - SSOT_LANG: [SCENE-BLOCK-01]
  - SSOT_TOOLCHAIN: seamgrim.scene.v0 정본화
---

## DR-126 — 한국어 Manim 확장: 책갈피(시간의 조각) / 해설 트랙 / 역조작(control)

- 상태: 채택(확장 제안)
- 날짜: 2026-02-01
- 핵심:
  1) 책갈피(시간의 조각): tick별 state_hash 캐시로 타임줄 되감기/점프를 지원(결정성 유지, 캐시 무효 검증 가능).
  2) 해설/자막 트랙: `보개장면`에 `#자막/#해설`을 추가해 교육 콘텐츠/AI 연동 기반을 마련.
  3) 만져지는 수식: 2D 드래그/조절을 `control` 입력원으로 받아 `마련` 값 확정 후 DDN 재실행(화이트리스트 매핑).
- 관련:
  - SSOT_LANG: [NARRATIVE-TRACK-01], [TIMEBOOKMARK-01], [INVERSE-CONTROL-01]
  - SSOT_TOOLCHAIN: 캐시/내보내기(자막)
  - SSOT_PLANS: W14+ 확장 아이디어
---

## DR-130 — 보개 고정 전략 강화: space2d primitive 확장(C++/3D) + graph_kind/축 메타 정본화

- 상태: 채택
- 날짜: 2026-02-05
- 핵심:
  - 교과/도메인별 보개 증식을 금지하고, 5-보개 고정 위에서 확장한다.
  - 2d(space2d)는 drawlist primitive(C+)를 정본으로, 선택 확장(C++: 원호/베지에/경로/면채우기/주석선)을 둔다.
  - 3D는 보개 증식 없이 space2d 입력 채널 확장(`그림3d`)으로 단계적 도입한다.
  - graph는 graph_kind(v0) + 축 메타(kind/unit/label)를 정본으로 추가하여 다양한 그래프를 지원한다.
- 관련:
  - SSOT_LANG: [SPACE2D-DRAWLIST-01], [SPACE2D-DRAWLIST-02], [SPACE2D-3D-01], [GRAPH-KIND-01], [GRAPH-AXIS-META-01], [GRAPH-DATA-01]

---

## DR-131 — 호출 정본 표면 우선순위: 조사형 → :핀 → (…)

- 상태: 채택
- 날짜: 2026-02-09
- 핵심:
  - `:핀`은 **모호성 해소용 옵션**이며, 유일 바인딩이면 정본 출력에서 제거한다.
  - 또니랑의 “한국어 네이티브” 목표를 위해, 정본 출력(canon)은 가능하면 **조사형(별칭 바인딩)** 으로 호출 인자를 표현한다.
  - 조사형이 불가/중의이면 **`:핀`(핀 고정)** 으로 봉인하고, 그마저 어려울 때만 **위치 바인딩 `( … )`** 으로 폴백한다.
  - 조사형/핀 고정형은 괄호 없이 나열할 수 있어 “문장처럼 읽히는 코드”를 유지한다.
- 근거:
  - 사람/학습자 입장: `100@m~를 3@s~동안 이동하기.`가 `(100@m, 3@s) 이동하기.`보다 목적이 명확하다.
  - 도구/AI 입장: 조사/핀 메타가 있으면 핀 매핑이 안정되고(결정성), 축/라벨/그래프 자동화와도 결이 맞다.
- 관련:
  - SSOT_LANG §10.2.4 [CANON-CALL-BINDING-ORDER-01]
  - SSOT_LANG §20.3 [PARSER-LOOKUP-02]
  - SSOT_TOOLCHAIN §T5 (canon 출력 정책)

---



---

## DR-132 — 토큰/표기 일관성 v1: 논리 연산 동치 + 꼬리/예약어 정리

- 상태: 채택
- 날짜: 2026-02-09
- 배경:
  - `그리고/또는/아님` 같은 한국어 표기와 `&&/||` 같은 연산자 표기가 혼재하면,
    사람/도구/LLM이 “함수 호출인지 논리 연산인지”를 혼동하기 쉽다.
  - Gate0/AGE1에서는 형태소 추정 없이도(꼬리 규칙/심볼 테이블만으로) **결정적 파싱/정본화**가 가능해야 한다.
- 결정:
  1) 논리 연산(AND/OR/NOT)의 동치 표기:
     - `그리고` ≡ `&&`
     - `또는` ≡ `||`
     - `아님`은 단항 NOT(기존 설탕)이며, Gate0/AGE1의 정본 표기는 `아님`으로 둔다.
       - `!` 토큰은 “예약(RESERVED)”으로 유지하되, Gate0/AGE1 문법에는 **도입하지 않는다**(사용 시 진단).
  2) 구분 정책(함수 호출 vs 논리 연산):
     - `그리고/또는/아님`은 **예약어**로 취급한다(사용자 정의 이름으로 사용 금지).
     - 따라서 `그리고(...)` 같은 “함수형 호출”은 표준 문법이 아니다(진단).
  3) 평가 규칙:
     - `{ ... }인것`/`{ ... }아닌것` 등 “검증 영역”에서 `그리고/또는`는 **단락 평가를 하지 않는다**(기존 규칙 유지).
       - 좌변/우변의 평가 순서는 좌→우로 고정한다(결정성).
  4) 실행 꼬리(호출 어미) 닫힌 집합 재확인:
     - `~기/~고/~면` 및 `~하기/~하고/~하면`만을 Gate0 표면 꼬리로 허용한다. (CALL-TAIL-EQUIV-01)
     - Formatter는 꼬리 스타일을 자동 치환하지 않는다(입력 스타일 유지).
- 영향:
  - 문서: SSOT_LANG(키워드/연산/설탕 절 보강), SSOT_OPEN_ISSUES(OI-CONSISTENCY 정리)
  - 구현: 파서 토큰 분류/예약어 테이블, 진단 코드(예: E_RESERVED_WORD_AS_ID)
  - 팩(권장): `pack/lang_token_consistency_v1/*` (동치 표기 파싱/정본화/진단 골든)

---

## DR-133 — 텐서V0 정준 표현(DetJson) + 정렬/불변식/해시 규칙

- 상태: 채택
- 날짜: 2026-02-09
- 목적:
  - 텐서(밀집/희소)를 **플랫폼/언어 구현체가 달라도 동일한 바이트**로 직렬화하고,
    동일한 해시를 얻어야 한다(결정적 재현/감사/골든 팩).
- 범위:
  - “관측/로그/팩/데이터셋”에서 사용되는 텐서의 **정준(정본) 표현**을 고정한다.
  - 텐서 연산 의미론(브로드캐스팅/슬라이스 등)은 이 결정의 범위 밖이다.

### DR-133.1 tensor.v0 (DetJson) 스키마 — MUST

- 공통:
  - `schema`: `"tensor.v0"`
  - `kind`: `"dense"` | `"sparse"`
  - `shape`: `차림<자연수>` (rank 길이의 축 크기)
  - `dtype`: `"fixed64"` *(v0는 fixed64만; 확장은 후속 이슈로)*

- 밀집(dense):
  - `data`: `차림<fixed64_raw_i64_string>`
  - 길이 불변식: `len(data) == Π(shape[i])` MUST
  - 순서: **row-major(마지막 축이 가장 빠르게 변함)** MUST

- 희소(sparse):
  - `items`: `차림<[index, value]>`
    - `index`: `차림<자연수>` (길이 == rank) MUST
    - `value`: `fixed64_raw_i64_string`
  - 정렬: `items`는 `index`의 사전식(lexicographic) 오름차순으로 **정준 정렬** MUST
  - 불변식:
    - 모든 `index[k] < shape[k]` MUST
    - 동일 `index` 중복 금지(MUST) — 중복 발견 시 FATAL

> fixed64_raw_i64_string: Fixed64(Q32.32)의 `raw_i64`를 문자열로 저장(DetJson 관행). (SSOT_TOOLCHAIN의 DetJson 규칙 준수)

### DR-133.2 정본화/해시 규칙 — MUST

- 직렬화: SSOT_TOOLCHAIN의 DetJson 정본화 규칙을 따른다(MUST).
- 텐서 해시(권장): `tensor_hash = blake3( DetJsonCanonicalBytes(tensor.v0) )`
  - 같은 텐서 값이면 어떤 플랫폼에서도 동일 해시여야 한다.

### DR-133.3 연동

- std_tensor(DR-072)의 텐서 출력/내보내기는, 외부로 노출되는 경우 `tensor.v0`로 표현 가능해야 한다(SHOULD).
- DEC-20260121-TENSOR-CANON-01(중첩 차림 설탕)은, 최종적으로 `tensor.v0`의 dense 입력으로 정준화된다(SHOULD).

- 팩(필수 권장):
  - `pack/std_tensor_v0_canon_v1/*`
    - dense 1D/2D, sparse 2D 최소 케이스
    - 경계 케이스(0차원/빈 텐서/shape 불일치/중복 index) 진단 골든



---

## DR-134 — 빠른 실행 경로 정본화(브리지/도구): `cargo run` 루프 금지 + `teul-cli` 직접 호출 + 상주 reset

- 상태: 채택
- 날짜: 2026-02-10
- 목적:
  - 셈그림/보개/브리지 같은 도구에서 DDN을 자주 실행할 때,
    `cargo run`의 **프로세스 생성 + 빌드 최신 체크** 오버헤드가 실행 시간을 지배하는 문제를 제거한다.
  - 동시에 “상주 실행(daemon)”을 도입하더라도 결정성을 깨지 않게 한다.

### DR-134.1 실행기 선택 규칙 — MUST (AGE1+)

- 도구/브리지는 “반복 실행 루프”에서 `cargo run`을 호출하지 않는다. (MUST)
  - *예: Python bridge_server, GUI/IDE, 자동 테스트 러너 등*
- 기본 실행기는 **빌드된 `teul-cli` 바이너리 직접 호출**이다. (MUST)
  - 경로 발견 규칙은 SSOT_TOOLCHAIN §TC0.3을 따른다. (SHOULD)

> 참고: `cargo run`은 “사람이 수동으로 1회 실행”할 때에 한해 허용되는 개발 편의이다(MAY).  
> CI/배포/상주 브리지 경로에서 `cargo run`을 기본값으로 두면 안 된다.

### DR-134.2 상주 모드(`:reset` 경계) — 결정

상주(Resident) 모드는 성능을 위해 허용하되, 결정성을 위해 **요청 경계마다 완전 초기화**를 강제한다.

- 브리지가 상주 프로세스를 사용한다면, **각 요청 처리 전에 반드시 `:reset`을 실행**한다. (MUST)
- `:reset`의 의미는 다음과 같이 **정의**한다. (MUST)

  1) `:reset` 이후의 실행(`run_file`)은, 같은 입력/같은 바이너리로 `teul-cli run`을 “새 프로세스에서 1회 실행한 결과”와 **비트 단위로 동치**여야 한다.  
  2) `:reset`은 최소한 아래를 초기화한다:
     - 살림(State/World) 전부
     - 결정 PRNG 상태(미시드 상태로)
     - 거울(로그) 세션 버퍼/핸들
     - 보개 출력 버퍼(채널/프레임/틱 캐시)
     - 컨트롤(입력) 임시값(미커밋 포함)
     - last_error/last_trace 같은 “이전 실행 결과 상태”
  3) 파서/정본화 캐시 등은 성능을 위해 유지할 수 있으나, 키가 `content_hash` 기반으로 고정되어 **결정성에 영향이 없어야** 한다. (MAY)

(연결: `SSOT_TOOLCHAIN §TC0.3.3`)

### DR-134.3 브리지 프로토콜(최종 확정) — 결정

상주 모드에서 stdout 경계(프레이밍)를 **문자 sentinel**로 처리하면
프로그램 출력과 충돌하거나 경계가 깨질 수 있다.

따라서 상주 모드의 표준 프로토콜은 **DetJson-RPC v1(= JSON-RPC 2.0 스타일 + Content-Length 프레이밍)** 으로 **고정**한다. (MUST, AGE1+)

- Gate0에서는 sentinel 프레이밍을 임시 허용할 수 있으나(디버그/전환 기간), (MAY)
- **AGE1+에서는 sentinel을 금지**하고 DetJson-RPC v1만을 표준으로 한다. (MUST)

(연결: `SSOT_TOOLCHAIN §TC0.3.4`)

### DR-134.4 검증 팩(권장)

- `pack/toolchain_fast_run_v1/*`
  - 동일 입력을 (1) 프로세스 1회 실행, (2) 상주+reset 실행 두 방식으로 돌려
    `state_hash`/출력 해시가 일치해야 한다.
  - 부정 테스트: reset 누락 시 결과가 달라지는 케이스를 만들어 진단(경고/실패)을 보장한다.






## DR-135 — AGE2 스튜디오 커널 v1(Closed-first) 채택: 게임/교과 시뮬 공통 기반 + 4팩 증명

- 상태: 채택
- 날짜: 2026-02-11
- 목적:
  - ‘게임/수학/물리/경제’ 도메인별 라이브러리를 한 번에 완비하려는 접근은 끝이 없으므로,
    **공통 커널(실험대)** 을 먼저 완성하고 대표 팩으로 증명한다.
  - AGE2를 “Open(열림) 봉인”만으로 한정하지 않고, Closed-first 기반을 포함해
    사용자 체감(반복 실행/탐구/오버레이/세션 저장)을 끌어올린다.

### DR-135.1 AGE2 스튜디오 DoD — MUST

AGE2 스튜디오 커널 v1은 아래 3축을 동시에 만족해야 한다.

1) **빠른 반복 실행**: `cargo run` 없이도 UI/브리지에서 반복 실행이 가능하다.
   - `teul-cli` 직접 호출 기본값(반복 루프에서 cargo run 금지)
   - `teul-cli worker`(DetJson-RPC v1) + `:reset`(새 프로세스 1회 실행과 비트 동치)
2) **다변수/희소 탐구**: 채널목록(메타) + 희소 포인트 + 피벗 그래프가 표준으로 동작한다.
   - 축 선택/시리즈 선택은 세션 상태로 저장/복원된다.
3) **교과+게임 공통 루프**: 입력(조작)→재실행→비교/오버레이→동결(scene/session 저장)이 결정적으로 재현된다.

### DR-135.2 증명 팩(권장, MUST)

- `pack/age2_kernel_smoke_v1`
- `pack/age2_phys_pendulum_v1`
- `pack/age2_econ_market_shock_v1`
- `pack/age2_math_calculus_v1`
- `pack/age2_game_miniloop_v1`

(연결: `SSOT_PLANS PLN-20260211-AGE2-STUDIO-KERNEL-01`, `SSOT_ROADMAP_CATALOG AGE2-스튜디오`)



---

## DR-136 — AGE2(Open) open.net/ffi/gpu v1 정식 런타임 API + open.log 스키마 확정

- 상태: 채택
- 날짜: 2026-02-11
- 근거: PROPOSAL_SSOT_OPEN_NET_FFI_GPU_V1_20260211

### 목적
- AGE2(Open) 확장에서 네트워크/호스트FFI/GPU 밖일(open_kind)을 **정식 API**로 제공하고,
  record/replay/deny 계약에서 **open.log 스키마를 결정적으로 고정**한다.

### 표준 함수(API)
- `열림.네트워크.요청.`
- `열림.호스트FFI.호출.`
- `열림.GPU.실행.`

> 공통 원칙: 호출 인자에는 **팩 값(pack value)** 을 전달하는 것을 권장한다(정본 출력은 pack-only 권장).

#### open.net (pack 필드)
- 입력:
  - `주소`(필수, string)
  - `방법`(선택, string, 기본 "GET")
  - `본문`(선택, string)
  - `응답`(record 전용, string)
- 출력: string (응답 텍스트)

#### open.ffi (pack 필드)
- 입력:
  - `이름`(필수, string)
  - `인자`(선택, string list)
  - `결과`(record 전용, string)
- 출력: string (결과)

#### open.gpu (pack 필드)
- 입력:
  - `커널`(필수, string)
  - `입력`(선택, string)
  - `결과`(record 전용, string)
- 출력: string (결과)

### open.log v1 (DetJson) 스키마

### site_id / key 생성 규칙(MUST)

- `site_id`는 호출 위치를 결정적으로 식별한다.
  - 기본 형식: `"{file}:{line}:{col}"` (UTF-16, 0-based)
  - line/col을 얻을 수 없으면 `unknown`으로 두되, 그 경우 record는 금지(`E_OPEN_SITE_UNKNOWN`).
- `key`는 open_kind별 입력 식별 키다(정규화/추측 금지).
  - `open.net` : `"{method} {url}"` + (body 있으면 `" body_b3:{blake3(body_bytes)}"`)
  - `open.ffi` : `"{name}({args_joined})"`
  - `open.gpu` : `"{kernel}"` + (payload 있으면 `" payload_b3:{blake3(payload_bytes)}"`)

### URL/본문 기록 정책(MUST)

- `url/method/body`는 record 시점의 문자열을 **있는 그대로** 기록한다(자동 정규화 금지).
- allowlist 판정 기본은 `(open_kind, key)`의 **정확 일치**다.
- 공통 레코드 필드: `event_kind="open"`, `open_kind`, `site_id`, `key`, `value`, `detjson_hash`
- `value`는 아래 스키마 중 하나(DetJson 객체)이며, `detjson_hash`는 value의 DetJson 직렬화 바이트에 대한 해시다.

#### open.net.v1
```json
{
  "schema": "open.net.v1",
  "url": "https://...",
  "method": "GET",
  "body": "...",
  "text": "..."
}
```

#### open.ffi.v1
```json
{
  "schema": "open.ffi.v1",
  "name": "func_name",
  "args": ["..."],
  "result": "..."
}
```

#### open.gpu.v1
```json
{
  "schema": "open.gpu.v1",
  "kernel": "kernel_name",
  "payload": "...",
  "result": "..."
}
```

### v2 확장 훅(권장)

v1은 문자열 기반을 기본으로 하되, 큰 payload/result를 위해 v2에서 DetBin 참조 확장을 권장한다.

- `open.net.v2`: `body_ref`, `text_ref` 추가 가능
- `open.gpu.v2`: `payload_ref`, `result_ref` 추가 가능
- v2 공존 규칙(DR-137)에 따라 **추가 필드로만 확장**한다.

### 정책(MUST)
- record 모드: 응답/결과 필드(`text/result`)는 **필수**다.
- replay 모드: open.log만 사용한다(실호출 금지). 실호출이 발생하면 반드시 실패한다.
- 허용은 allowlist 정책으로만 한다(미허용은 FATAL). (OI-AGE2-OPEN 원칙 유지)

### DoD
- pack(최소) 3종:
  - `pack/open_net_record_replay/*`
  - `pack/open_ffi_record_replay/*`
  - `pack/open_gpu_record_replay/*`

---

## DR-137 — open.log v2 공존 규칙(추가 필드 허용/해시 포함) 확정

- 상태: 채택
- 날짜: 2026-02-11
- 근거: OPEN_LOG_V2_RULES

### 공통 원칙
- v2 로그는 v1과 동일한 필수 필드를 유지한다.
- 추가 필드는 **허용되며 무시**한다.
- `detjson_hash`는 value 전체(추가 필드 포함)의 DetJson 직렬화 바이트에 대해 계산한다.

### open.clock.v2
- 필수: `schema="open.clock.v2"`, `unix_sec`
- 선택: 그 외 모든 필드(예: `meta`)

### open.file_read.v2
- 필수: `schema="open.file_read.v2"`, `text`
- 선택: 그 외 모든 필드(예: `meta`)

### DoD
- v1 replay 검증은 v2 value를 **허용**하되(추가 필드 포함), `detjson_hash` 검증은 value 전체에 대해 수행한다.

---

## DR-138 — W90 Gateway 소켓 입력 옵션/리포트 필드 정준화

- 상태: 채택
- 날짜: 2026-02-11
- 근거: SSOT_GATEWAY_SOCKET_REPORT_REQUEST_20260210

### gateway serve 소켓 입력 옵션(MUST)
- `listen`(addr)
- `listen_proto`(tcp/udp)
- `listen_max_events`
- `listen_timeout_ms`

종료 규칙:
- `listen_max_events` 도달 또는 `listen_timeout_ms` 경과 시 수신 종료

### gateway.serve_report.v1 필드(MUST)
- `listen_addr`
- `listen_proto`
- `listen_max_events`
- `listen_timeout_ms`

### gateway.serve_report.v1 추가 필드(권장, SHOULD)

- `stop_reason`: `"max_events" | "timeout" | "eof" | "error"`
- `received_events`: 실제 수신 이벤트 수
- `elapsed_ms`: 실제 수신 루프 경과(ms)

### SSOT 범위 제외
- 테스트 전용 self-send 옵션: `send`, `send_format` (SSOT 범위 밖)

## DR-139 — 표기 스타일(canon/pretty) + 말씨(dialect ko/en/sym3) + SYM3 토큰셋

- 상태: 채택
- 링크:
  - `SSOT_LANG`: [STYLE-CANON-01], [STYLE-PRETTY-01], [DIALECT-HEADER-01], [DIALECT-SYM3-01]
  - `SSOT_LANG`: TERM-MAP(TERM-LEGACY-009~016), JOSA 별칭(`~ob/~sb/...`)
  - `SSOT_TOOLCHAIN`: `fmt --style=canon|pretty|en|sym3` (Q2 정본화 단계)

### 결정

1) **표기 스타일 분리**
- 정본 출력은 `canon`을 기준으로 하며, 조사 경계 `~`를 필요 시 삽입해 해석을 고정한다.
- 사람용 출력은 `pretty`를 두고, `~` 생략은 “왕복 파싱(AST 동일)”이 보장될 때만 허용한다.

2) **말씨(dialect) 도입**
- 파일 메타 헤더 `#말씨: ko|en|sym3`를 표준화한다.
- 말씨는 의미(=AST)를 바꾸지 않고, **입력 별칭 + 린트/포매터 기본값**만 바꾼다.

3) **SYM3(기호 말씨) 토큰셋 확정**
- 조건/분기/논리/파이프/토막 꼬리의 SYM3 토큰셋을 “2~3글자 + 최장일치” 원칙으로 확정한다.
- 파이프는 `|>>`를 정본으로 하고, `|>`는 sym3에서 금지(또는 compat 경고+정규화)로 둔다.
- sym3 호출 표지는 `!()`로 둔다.

4) **용어 정본 갱신(순우리말)**
- `되풀이/되돌림/톺아보기/맞물림씨/겹차림/바른꼴/해봄줄/차림판`을 정본(우선)으로 두고,
  `반복/반환/감사/관계씨/텐서/정본/시험줄/차림표`는 입력 별칭(LEGACY)로 둔다.

### 사유

- 한국어 네이티브 가독성과, 비한국어 사용자(영어권/교착어 아닌 사용자)의 “표기 장벽”을 동시에 낮춘다.
- 결정성(정본 출력)과 발표/교육/문서(사람용 출력)의 요구가 다르므로, 출력 스타일을 분리하는 것이 안전하다.
- 조사 별칭(`~ob` 등)으로 “괄호 천국”을 줄이면서도, pin/josa 기반의 모호성 제거 원칙을 유지한다.



---

## DR-140 — SSOT_DEMOS 말씨(ko/en/sym3) 3단 병기 + i18n(읽기 번역)

- 상태: 채택
- 링크:
  - `SSOT_DEMOS`: §E0.B
  - `SSOT_LANG`: [DIALECT-HEADER-01], [DIALECT-EN-01], [DIALECT-SYM3-01], [DIALECT-I18N-01]
  - `SSOT_TOOLCHAIN`: `fmt --style=i18n-ja|i18n-mn|i18n-tr` (문서/교육용 표시)

### 결정

1) **SSOT_DEMOS에 ‘같은 AST, 여러 말씨’ 템플릿을 추가한다.**
- ko/en/sym3로 같은 의미를 병기하여, 학습/문서/리뷰에서 비교 비용을 낮춘다.

2) **일본어/몽골어/터키어 도입은 단계적으로 한다.**
- v20.6.2에서는 i18n(읽기/교육용 표시)만 제공했다.
- v20.6.9에서는 DR-141로 `#말씨: ja|mn|tr` 입력 별칭을 v1(최소 키워드)로 채택한다.
- `i18n-*`는 계속 “표시(render)” 전용이며, 왕복 파싱을 요구하지 않는다(팩/골든 저장 금지).

3) **툴체인(fmt)은 i18n-*를 ‘표시 렌더’로만 제공할 수 있다(MAY).**
- i18n 출력은 왕복 파싱을 요구하지 않으며, pack/golden 저장에 사용하면 안 된다.

### 사유

- 교육/문서에서 ‘표기(언어)’와 ‘의미(AST)’를 분리해 보여주면, 한국어 비원어민/비교착어 사용자도 빠르게 적응한다.
- sym3는 ‘의미가 아니라 표기’이므로, 데모에서부터 혼용 위험을 낮추는 템플릿이 필요하다.
- 다국어는 커뮤니티 확장에 중요하나, 파서 입력으로의 무리한 확장은 Gate0 안정성을 해칠 수 있어 단계적으로 도입한다.

---

## DR-141 — `#말씨: ja|mn|tr` 입력 별칭 말씨(v1 최소 키워드) 채택 + 동치 pack

- 상태: 채택
- 링크:
  - `SSOT_LANG`: §10.6 ([DIALECT-JA-01], [DIALECT-MN-01], [DIALECT-TR-01]) / §10.8(조사 별칭)
  - `SSOT_DEMOS`: §E0.B (6단 병기 예시)
  - `SSOT_TOOLCHAIN`: [TC-FMT-STYLE-01] (`fmt --style=ja|mn|tr`)
  - `SSOT_PACK`(신규 제안): `pack/lang/dialect_equiv_v1`

### 결정

1) **입력 말씨로 `ja/mn/tr`를 채택한다(단, v1 최소 셋).**
- 의미(=AST)는 ko 정본과 동일하며, `ja/mn/tr`는 “키워드 별칭”만 제공한다.
- v1에서의 범위:
  - 조건/분기: `일때/아니면/이면`
  - 논리: `그리고/또는/아님`
  - 선택/분기: `따라`
  - 흐름: `되풀이/되돌림/톺아보기`
- 이 범위를 벗어나는 번역(표준 라이브러리 이름, 문장 전체 번역)은 `i18n-*` 표시 층으로 남긴다.

2) **파이프/토막 꼬리는 “말씨별 권장형 + compat”로 운영한다.**
- ja/mn/tr(및 en)은 `|>`를 **권장형(preferred)** 으로 유지한다(타이핑/관습/가독성).
- ko 및 “순수 단어 기반 말씨”(예: ne/ta/te/kn/eu)는 말씨별 **접미/단어형 파이프**를 권장형으로 하고, `|>`는 **compat 입력으로만** 허용한다.
  - fmt/pretty 및 문서 예제는 word형만 사용한다.
- sym3의 파이프는 `|>>`가 권장형이며, `|>`는 금지 또는 compat 정규화로만 취급한다.
- 토막(Thunk) 꼬리도 말씨별 권장형(예: ne `}गरेको`, `}गर्नु`)을 둘 수 있으며, `}=>/}==/}!=/}&>/}|>` 같은 기호형은 compat 입력으로 허용할 수 있다(단, lint로 혼용 경고 권장).

3) **조사 표면형은 말씨별로 포용하며, 권장형/허용형을 구분한다.**
- 목적: en/ja/mn/tr/sym3 말씨에서도 “인자 전달”을 괄호로만 쓰지 않고 `값~조사` 구조를 유지한다.
- 원칙:
  - 내부(바인딩/AST)는 role(SB/OB/…)로 정규화한다.
  - 말씨별 표면형(ja/mn/tr의 자연 조사/격 표지)은 **허용(accepted)** 할 수 있다.
  - 짧은 코드 조사(`~ob/~sb/...`)는 **모든 말씨에서 항상 허용되는 명시형(fallback)** 이다(모호성 회피용).
- canon 출력은 ko 조사로 복원한다.
4) **도구/검증: 말씨 동치 pack을 추가한다.**
- pack id(제안): `pack/lang/dialect_equiv_v1`
- 구성(예):
  - `ko.ddn` / `en.ddn` / `sym3.ddn` / `ja.ddn` / `mn.ddn` / `tr.ddn`
  - `canon.ddn`  (정본 출력 기대값, ko canon)
  - `ast_hash.txt` 또는 `ast.detjson` (동치 비교용)
- DoD:
  - 위 6개 입력을 파싱했을 때 AST 해시가 동일해야 한다.
  - 각 입력을 `canon`으로 정본화했을 때 출력이 `canon.ddn`와 동일해야 한다.
  - `fmt --style=ja|mn|tr` 출력도 다시 파싱 시 동일 AST로 복원되어야 한다.

5) **린트: 파일 말씨 혼용 경고를 유지한다.**
- `#말씨: ja` 파일에서 ko/en/sym3 전용 키워드가 섞이면 경고를 낸다.
- 단, 공용 기호(`|>`, `}|>`, `}&>` 등)는 예외로 둘 수 있다(구현체 lint 정책으로).

### 사유

- “한국어 정본 1개” 원칙을 유지하면서도, 해외 사용자/커뮤니티 확장을 위한 최소 표면 진입로가 필요하다.
- v1은 **키워드 최소 셋**만 도입하여, Gate0 파서/팩/정본화 안정성을 깨지 않는다.
- 동치 pack을 먼저 넣으면, 언어 추가가 “감각”이 아니라 “테스트로 증명”되는 변경이 된다.

## DR-142 — 말씨(dialect) 표면 차이 포용(권장형/허용형) + 조사 role 매핑 확장

- 상태: 채택
- 링크:
  - `SSOT_LANG`: §10.6([DIALECT-SURFACE-VARIATION-01]) / §10.8([JOSA-ROLE-01]~[JOSA-ROLE-04])
  - `SSOT_TOOLCHAIN`: fmt/lint 권장(말씨별 preferred 정리)
  - `SSOT_PACK`(권장): `pack/lang/dialect_equiv_v2` (허용형 케이스 포함)

### 결정

1) **말씨는 언어별 ‘자연스러운 표면 차이’를 허용한다.**
- ja/mn/tr는 언어 특성상 조사/격 표지가 ko/en/sym3와 다르게 보일 수 있다.
- 이 차이는 “표면”에서만 허용되며, 의미(AST)는 ko 정본과 동일해야 한다.

2) **권장형(preferred)과 허용형(accepted)을 구분한다.**
- 입력은 허용형을 넓게 받을 수 있다(포용).
- fmt는 말씨별 권장형으로 정리할 수 있다(정돈).
- `canon` 출력은 ko 정본 표기로 수렴한다(결정성/감사/리플레이).

3) **모호성은 추측하지 않는다.**
- 동일 표면형이 여러 role에 걸칠 수 있다(예: ja `~に`, `~から`).
- 후보가 2개 이상이면 결정적 오류로 보고하고 `:핀`(또는 더 구체적 표기)을 요구한다.

4) **짧은 코드 조사(`~ob/~sb/...`)는 보편 fallback으로 유지한다.**
- 언어별 표면 조사만으로 애매해지거나, 키보드 입력이 불편한 경우를 위해
  코드 조사는 모든 말씨에서 항상 허용된다.


## DR-143 — D-PACK 케이스/골든 파일명 + `ast_hash` 포맷 고정

- 상태: 채택
- 링크:
  - `SSOT_DEMOS`: §D-PACK.1.1 ([DPACK-CASE-01], [DPACK-GOLDEN-01], [DPACK-EQUIV-01])
  - `SSOT_PLATFORM`: [HASH256-01] (해시 표기)
  - `SSOT_TOOLCHAIN`: pack/golden은 `canon` 출력만 저장 (TC-FMT-STYLE-01 / pack 규칙)

### 결정

1) **팩의 입력은 `cases/` 아래 케이스 키로 묶는다.**  
- 케이스 키: `KNNN_<slug>`  
- 권장 파일명: `cases/<case_key>.<dialect>.ddn`

2) **팩의 정본 산출물은 `golden/` 아래 3종을 MUST로 둔다.**
- `golden/<case_key>.canon.ddn`
- `golden/<case_key>.ast.detjson`
- `golden/<case_key>.ast_hash.txt`

3) **`ast_hash`는 `ast.detjson` 바이트의 BLAKE3-256으로 고정한다.**
- 텍스트 표기: `blake3:<lower-hex64>` (1줄 + 개행)
- 목적:
  - “표기(말씨/심볼어)” 변화와 무관하게, 의미(AST)가 동일함을 빠르게 증명한다.
  - golden 비교를 “픽셀”이 아닌 “구조/해시”로 옮겨 결정성을 강화한다.

4) **golden 저장은 오직 `canon` 출력만 허용한다.**
- `pretty`/`i18n-*`는 교육/표시용 렌더로만 취급하며,
  pack/golden 저장에 사용하지 않는다. (MUST NOT)

### 사유

- pack이 커질수록 “파일 이름/해시 포맷”이 흔들리면 자동화가 붕괴한다.
- `ast_hash`를 고정하면, 다국어/심볼어/조사 포용을 해도 의미의 동치가 테스트로 보장된다.

## DR-146 — age_target 결정 기록(run_manifest) + 회귀 pack 위치(SSOT pack) (채택)

### 결정 1) age_target 결정 기록 위치
- `age_target`은 런의 메타/구성 결정이므로 **run_manifest에 기록하는 것을 정본(MUST)** 으로 채택한다.
- 기록 필드(최소):
  - `age_target_source` = `cli|project|default`
  - `age_target_value`
- 선택(SHOULD):
  - `geoul.diag.jsonl`에 `event="run_config"` 레코드 1건(런당 최대 1건) 추가
- stdout 한 줄 출력은 디버그 편의로만 허용하며 정식 기록으로는 사용하지 않는다.

### 결정 2) 회귀 pack 위치
- age_target 우선순위 정책을 검증하는 회귀 pack은 **SSOT 정식 pack**으로 생성한다.
- 경로(정준):
  - `docs/ssot/pack/project/project_age_target_precedence_v1/`
- “가이드만 작성 + 사용자 수동 반영” 방식은 채택하지 않는다.

### 완료 판정(DoD)
- pack이 CI에서 PASS/FAIL expected를 안정적으로 판정한다.
- run_manifest에 age_target 결정이 항상 기록된다.

## DR-147 — SSOT 최신 1세트 유지 정책 (채택)

### 정책
- `docs/ssot/ssot/`에는 **최신 버전 1세트만 유지한다.**
- 이전 버전은 `docs/ssot/releases/vX.Y.Z/`로 이동하여 보관한다.
- `CURRENT.md`를 두지 않고, 디렉토리 구조 자체로 “최신만 존재”를 보장한다.

### 목적
- 정본 혼선 방지
- 사람이 보는 폴더에서 다중 버전 충돌 제거

## DR-149 — 또니랑 정체성 고정: 결정론 수학/시뮬레이션 DSL (3가지 목적)

- 상태: 채택
- 날짜: 2026-02-16
- 핵심:
  - 또니랑은 “범용 언어”가 아니라 **결정론 수학/시뮬레이션 DSL**로 정체성을 고정한다.
  - 특화 목적은 3가지로 고정한다.
    1) 시뮬레이션 교육(물리/수학/경제 등 과목)
    2) AI Gym(강화학습 환경 정의 + 결정적 리플레이)
    3) 또니랑누리/말힘누리(게임/창작용 세계의 결정론 코어)
  - 이 결정은 “문법 발명”보다 **팩(pack)·리플레이·해시 중심의 개발 루프**를 우선하도록 방향을 잡는다.
- 비목표(요지):
  - 범용 I/O/OS API/스레드·네트워크를 코어 목표로 삼지 않는다.
  - 플랫폼 의존/비결정적 동작(임의 실수, 임의 시계)은 기본으로 열지 않는다.
- 관련:
  - SSOT_MASTER: “정체성” 섹션
  - SSOT_ROADMAP_CATALOG: 목적별 백로그 재정렬
  - SSOT_PLATFORM: 결정성/리플레이/해시 규약

---

## DR-150 — ‘흐름’은 값 타입, ‘흐름씨’는 씨앗: ~씨 접미의 의미 고정

- 상태: 채택
- 날짜: 2026-02-16
- 핵심:
  - 접미 `~씨`는 **씨앗 종류(seed kind)** 를 뜻한다. (세계 실행 논리 블록)
  - `흐름씨`는 기존처럼 **리액티브(Functional/Signal) 모델**의 씨앗이다.
  - `흐름(Stream)`은 별개로 **값 타입(Value Type)** 으로 도입한다(상태형 링버퍼).
    - 표면 타입 표기: `흐름(N)` (N=용량)
    - 의미: 최근 N개의 값을 결정적으로 보존(오래된 값 자동 밀어내기)
- 주의(혼동 방지):
  - 파이프 설명에서 쓰는 “흐름값”은 타입 `흐름`과 다른 말이다(용어 충돌 금지).
  - 문서/예시는 가능하면 “흐름(값 타입)”/“흐름씨(씨앗)”를 병기한다.
- 관련:
  - SSOT_LANG: 예약어/타입 시스템(복합 타입) / `<-` 의미(흐름에 대한 push)
  - SSOT_PLATFORM: state_hash에 포함되는 상태 범위(흐름 버퍼 포함)

---

## DR-151 — 보개(Seamgrim) 빠른 그래프 관행: 접두 키 자동 렌더(권장)

- 상태: 채택(권장 규칙)
- 날짜: 2026-02-16
- 핵심:
  - 학습/실험 흐름에서 “DDN에서 그래프 배관을 매번 쓰는 비용”을 줄이기 위해,
    UI(보개/셈그림)가 아래 접두 키를 자동 그래프로 렌더할 수 있다.
    - `그래프_<이름>`
    - `보개_그래프_<이름>`
  - 위 규칙은 **뷰어 관행(Convention)** 이며, DDN 코어 의미론을 바꾸지 않는다.
- 관련:
  - SSOT_TOOLCHAIN: Seamgrim UI 계약(파생/뷰 전용 기능의 위치)
  - SSOT_LANG: ‘보개’ 키 네임스페이스(예약)
  - (참고) `docs/context/proposals/PROPOSAL_STREAM_AND_BOIM_V2_20260216.md`

---

## DR-152 — state_hash 경계: 보개/뷰 전용 키는 해시 입력에서 제외

- 상태: 채택
- 날짜: 2026-02-16
- 핵심:
  - 보개(UI) 전용 설정이 state_hash를 바꾸면 “연출 변경이 결과 해시를 오염”시키므로,
    `보개_*` 계열 키는 **state_hash 입력에서 제외**한다.
  - 결정성(재현/감사)은 “세계 상태”에만 걸어야 한다.
- 관련:
  - SSOT_PLATFORM: [STATE_HASH_V1-01] 입력 스냅샷 범위
  - SSOT_LANG: 보개 키(예: `보개_바탕색`, `보개_그림판_목록`)는 “뷰 전용 네임스페이스”로 취급
  - SSOT_TOOLCHAIN: golden/pack은 state_table(row) 대신 state_hash_trace 중심으로 가는 방향(Seamgrim replan)

---

## DR-153 — STDLIB 다국어 파이프라인 Stage A: 최소 내장(builtin) 별칭 정규화

- 상태: 채택
- 날짜: 2026-02-16
- 핵심:
  - 말씨(dialect)는 “키워드 치환”을 담당하지만, STDLIB 함수/상수는 키워드가 아니므로 별도 정규화가 필요하다.
  - Stage A:
    - 최소 내장(builtin) 30개 내외를 선정하고,
    - 다국어 별칭을 **정본 식별자(ko canonical)** 로 정규화한다.
  - Stage B/C는 로드맵으로 이월한다(전수 STDLIB, 사용자 함수 별칭 등).
- 관련:
  - SSOT_TOOLCHAIN: 정본화 파이프라인(키워드 말씨 + builtin 식별자 정규화)
  - (참고) `docs/context/proposals/PROPOSAL_STDLIB_MULTILANG_PIPELINE_V1_20260215.md`

---

## DR-154 — 우향 대입 `->` 도입: 입력 설탕 허용, 정본 출력은 `<-` 고정

- 상태: 채택
- 날짜: 2026-02-16
- 핵심:
  - `값 -> 대상` 표기를 **입력 설탕**으로 허용한다.
  - 의미는 `대상 <- 값`과 동일하며, 정본화(canon) 출력은 항상 `<-`로 수렴한다.
  - 파서 규칙:
    - `->` 우항은 **L-Value(대입 가능한 자리)** 여야 한다.
    - 대입 연산자는 문장 내 **가장 낮은 우선순위**로 둔다(좌측 계산 후 우항에 저장).
- 충돌 회피:
  - `->`는 타입 시그니처 등에서 이미 쓰이므로, **정본 출력에서는 대입용 `->`를 사용하지 않는다.**
  - 말결/통신 화살표는 대입과 토큰을 분리하기 위해 `~~>`로 예약한다. (DR-156, 문맥 판정 금지)
- 관련:
  - SSOT_LANG: [ASSIGN-ARROW-01] 및 우향 대입 규칙 추가
  - SSOT_TOOLCHAIN: `teul-cli fmt --style=canon`은 `<-`만 출력



---

## DR-155 — 짝맞춤 점 접근 Step A(읽기): `m.열쇠` = 값 조회, 없는 키는 FATAL

- 상태: 채택
- 날짜: 2026-02-17
- 핵심:
  - `짝맞춤`(dict/map)에서 `m.열쇠` 표기를 **읽기 전용 설탕**으로 채택한다. *(Step A)*
  - 의미:
    - `m`이 `(글 V)짝맞춤`일 때, `m.열쇠`는 “열쇠=`"열쇠"`” 조회와 동치이다.
    - 반환은 **값(Value)** 이며, Gate0에서 `m.열쇠`는 L-Value(대입 대상)가 아니다. *(쓰기/참조는 Step B/C 이월)*
  - 키가 없으면 즉시 실패한다: `E_MAP_DOT_KEY_MISSING` (FATAL)
- 이월:
  - Step B/C(쓰기, 참조/L-Value, 중첩 갱신)는 별도 이슈로 유지한다. *(OI-MAP-ACCESS-01)*
- 관련:
  - SSOT_LANG: [MAP-DOT-READ-01]
  - SSOT_OPEN_ISSUES: OI-MAP-ACCESS-01
  - (참고) `docs/context/proposals/PROPOSAL_MAP_ACCESS_VALUE_V1_20260216.md`

---

## DR-156 — 말결/통신 화살표 토큰: `~~>` 예약

- 상태: 채택
- 날짜: 2026-02-17
- 핵심:
  - 대입 `->`(입력 설탕)과 문맥 판정을 섞지 않기 위해, 말결/통신(에이전트 메시지, 이벤트)은 **별도 토큰**으로 분리한다.
  - 말결/통신 화살표 토큰은 `~~>`로 **예약(선점)** 한다.
  - Gate0에서는 의미론/런타임이 아직 없으므로, `~~>`를 사용하면 즉시 실패한다: `E_SIGNAL_ARROW_UNSUPPORTED` (FATAL)
- 관련:
  - SSOT_LANG: [SIGNAL-ARROW-RESERVE-01]
  - SSOT_OPEN_ISSUES: OI-ARROW-SIGNAL-01

---

## DR-157 — 번들/매니페스트 무결성 운영: sha256 접미사 & `file_count` 파생값

- 상태: 채택
- 날짜: 2026-02-17
- 핵심:
  - 번들/산출물 파일명에서 `_rN`(리비전) 표기는 전면 금지한다. *(DR-078 재확인; 운영 규칙으로 재고정)*
  - `workspace_bundle`/`ssot_patch` 등 “스냅샷 ZIP”의 유일 식별자는 `sha256` 해시이며, 파일명에 `__sha256_<해시>` 접미사를 붙인다.
  - `SSOT_ALL_MANIFEST`의 `file_count`는 표의 행수(파일 경로 행)와 **항상 일치**해야 한다.  
    이 값은 “사람이 세는 값”이 아니라, **manifest 생성기/CI 체크가 검증하는 파생값**이다.
- 관련:
  - SSOT_MASTER: 협업/정본 운영 규칙(번들 식별)
  - SSOT_ALL_MANIFEST: 헤더 `file_count` 규칙


---

## DEC-REGISTRY-SCOPE-01: 꾸러미 스코프(1칸) 이름 확정 — `표준/나눔/내/벌림`

- 상태: 채택
- 날짜: 2026-02-17
- 핵심:
  - 꾸러미(배포) 식별자에서 **첫 번째 칸(스코프)** 은 “출처/신뢰/배포 경로”를 나타낸다.
  - 스코프 정본 이름은 아래 4개로 고정한다.

| 스코프(정본) | 성격 | 게시(publish) | 의도 |
|---|---|---|---|
| `표준` | 공식 표준 라이브러리(정본) | 원격 게시 **제한**(관리자) | 교과/예제의 기본 기반 |
| `나눔` | 커뮤니티 기여 | 원격 게시 **허용** | 공유/확장 생태계 |
| `내` | 작업터/프로젝트 내부 전용 | **게시 금지** | 로컬 실험/사내 전용 |
| `벌림` | 외부 의존을 로컬에 “복사(벤더링)”해 둔 것 | **게시 금지** | 재현성/감사(소스 봉인) |

- 레거시(입력) 별칭:
  - `std`, `standard` → `표준`
  - `community`, `contrib` → `나눔`
  - `local`, `private` → `내`
  - `vendor`, `third-party` → `벌림`
  - 단, **정본 출력(canon)에서는 위 영문 별칭을 생성하지 않는다.**
- 예:
  - `#가져오기 표준/물리/역학 (중력씨)`
  - `#가져오기 나눔/교육/탄성 (스프링씨)`
  - `#가져오기 내/도구 (기록씨)`

  - 해석: `스코프/꾸러미/모듬...` 형태로 쓸 때, **첫 2칸(`스코프/꾸러미`)이 꾸러미 ID**이고, 그 뒤는 **모듬(모듈) 경로**다. 버전은 잠금파일/해결기로 결정한다.
- 관련:
  - SSOT_TERMS: “스코프/이름@버전” 및 스코프 용어 정리
  - SSOT_TOOLCHAIN: 가져오기/해결기(resolver)에서 스코프별 해석 규칙
  - (참고) `docs/context/proposals/PROPOSAL_PACKAGE_REGISTRY_V1_20260217.md`
  - (참고) `docs/context/proposals/PROPOSAL_PACKAGE_SERVER_MVP_V1_20260217.md`

---

## DEC-REGEX-01: `정규식{}` 리터럴 + `정규*` API 채택(설계) — 호출 해석은 단계적

- 상태: 채택(설계)
- 날짜: 2026-02-17
- 선택: C(넓게 닫기) — 단, **구현은 단계적으로** 진행한다.
- 핵심:
  - 값 타입 **`정규식`** 과 리터럴 표기 **`정규식{ ... }`** 를 채택한다.
  - 정본(권장) API 이름은 동사 모호성을 줄이기 위해 **`정규*` 접두**로 고정한다.
    - 예: `정규찾기`, `정규맞추기`, `정규바꾸기`, `정규나누기`
  - 호출 해석(오버로드) 확장은 “기존 호출 바인딩(핀/이름/조사) + 다중 디스패치” 위에서 **추가 규칙을 최소화**하는 방식으로 단계적으로 도입한다.
- 단계:
  - Phase 1 (AGE2 목표):
    - `정규식{}` 파싱/정본화 + `정규*` 표준 라이브러리(최소) 제공
    - 동사형(`찾기/맞추기/바꾸기/나누기`)은 **레거시 별칭(입력 허용) 후보**로만 남기고, 정본 출력은 `정규*`를 사용한다.
  - Phase 2 (OI로 이월):
    - 동사형 API를 “정규식 인자 존재 시 정규 버전으로 해석”하는 편의 규칙을 추가할지 재검토
    - 필요 시, 모호성은 `:핀`/이름바인딩으로 강제 해소한다.
- 관련:
  - SSOT_LANG: `정규식{}` 리터럴 문법 + 타입 + 진단 코드
  - (참고) `docs/context/proposals/PROPOSAL_REGEX_LITERAL_AND_CALL_OVERLOAD_V1_20260217.md`

---

## DEC-CONTRACT-TIERS-01: 결정성 계약 등급(Contract Tiers) 4단계 채택 — Gate0는 `STRICT/OPEN`부터

- 상태: 채택
- 날짜: 2026-02-17
- 선택: C(4단계 유지)
- 등급(정본):
  - **D-STRICT**: 비트 단위 결정성(예: fixed64)
  - **D-SEALED**: “봉인된 결정성” (비결정 요소가 있어도 입력/테이프/거울로 봉인되어 재현 가능)
  - **D-APPROX**: 근사(오차) 허용(오차 경계/측정 방법 명시가 계약의 일부)
  - **D-OPEN**: 결정성 비보장(탐색/실험/개발 모드)
- Gate0 집행 범위(현실적 단계화):
  - Gate0/AGE1에서의 런타임 집행은 **D-STRICT / D-OPEN** 을 우선 지원한다.
  - D-SEALED/D-APPROX는 개념/문서/스키마만 선반영하고, 실제 집행은 AGE3 로드맵으로 이월한다.
  - Gate0에서 D-SEALED/D-APPROX를 “그럴듯하게 동작”시키지 않기 위해, 해당 등급을 **선언/요구**하면 `E_CONTRACT_TIER_UNSUPPORTED`로 즉시 실패(FATAL)한다. *(거짓 통과 방지)*
- 관련:
  - SSOT_PLATFORM: 계약 등급 표 + Gate0 지원 매트릭스
  - (참고) `docs/context/proposals/PROPOSAL_CONTRACT_TIERS_V1_20260217.md`
  - (참고) `docs/context/proposals/PROPOSAL_DETMATH_ROADMAP_V1_20260217.md`

---

## DEC-OBS-API-01 / DEC-OBS-SCHEMA-01: 관찰(Observation) 메타/스키마 확장(C) 채택 — 추가 필드 = 전부 MAY

- 상태: 채택(설계)
- 날짜: 2026-02-17
- 핵심:
  - “무엇을 관찰/행동/보상으로 읽을지”는 문법이 아니라, **상태기계/도구(보개·누리Gym)가 소비하는 메타데이터**로 정의한다.
  - 관찰 스키마(`ddn.observation_manifest.v0`)는 앞으로 필드가 늘어날 수 있으므로, **추가 필드는 전부 MAY(선택)** 로 두고,
    - 도구는 **unknown 필드를 무시**할 수 있어야 한다.
    - 단, round-trip(읽기→쓰기)에서는 unknown 필드를 **보존**하는 것을 권장한다.

- 채널/해시 원칙:
  - 관찰목록은 **보개메타(view_meta)** 로 취급한다.
  - 따라서 `state_hash`에는 영향을 주지 않는다.

- 역할(role) 원칙:
  - 역할은 1개의 축으로 잠그지 않고, **독립 태그**로 둔다(둘 다 선택):
    - `state_role`: `상태|파생` *(state_hash 관점 분류)*
    - `obs_role`: `obs|action|reward|terminal|aux` *(NuriGym 관점 분류)*

- 생성 경로(정본):
  - 엔진이 직접 생성해도 된다.
  - 또는 도구가 `columns()`(상태 테이블) + `meta.toml` + 길잡이말(`#...`) 스캔을 합쳐 생성해도 된다.
  - 어떤 경로든 **같은 최종 스키마**를 산출해야 한다.
- 호환성/해시:
  - 관찰 메타는 “상태(state_hash)”가 아니라 “메타(manifest)”로 취급한다.
  - 해시/골든 비교가 필요할 때는, “키 정렬 + 결정적 JSON 직렬화” 규칙으로 전체 JSON을 canonicalize하여 `manifest_hash`를 계산한다.  
    (알 수 없는 필드도 JSON으로는 그대로 포함되므로, **스키마 확장이 곧바로 호환성 파괴가 되지 않는다**.)
- 관련:
  - SSOT_TOOLCHAIN: `ddn.observation_manifest.v0`(v20.6.33 초안) 및 생성/저장 위치
  - SSOT_PLATFORM: NuriGym 관측/행동 계약과의 접점
  - (참고) `docs/context/proposals/PROPOSAL_OBSERVATION_PROTOCOL_V0_20260217.md`

---

## DEC-PRAGMA-LAYER-01: 길잡이말(`#...`)을 “도구 레이어 메타”로 채택 — 실행/해시와 분리

- 상태: 채택(설계)
- 날짜: 2026-02-17
- 결론:
  - `#...`로 시작하는 줄(길잡이말)은 **문법(누리) 실행**이 아니라, **도구 체인(보개/린트/팩/가져오기)** 이 소비하는 메타로 취급한다.
  - 길잡이말은 **보개메타(view_meta)** 로 분류되며, `state_hash`에 **MUST NOT** 영향을 준다.
  - Gate0에서는 `#말씨`류만 우선 구현해도 된다.
  - `#가져오기/#내보내기/#그래프/#조종/#관찰/#추적` 등은 **예약 이름**으로 두고, 의미는 AGE2+에서 단계적으로 연다.
- 관련:
  - SSOT_TOOLCHAIN: “길잡이말(Pragma) 스캔” 절
  - (참고) `docs/context/proposals/PROPOSAL_DDN_ARCHITECTURE_SYNTHESIS_V1_20260217.md`
  - (참고) `docs/context/proposals/PROPOSAL_IMPLEMENTATION_ROADMAP_V1_20260217.md`

---

## DEC-STORY-NURI-01: “이야기(.ddn) = 누리(결정론 모델) 정의” 용어 축 고정

- 상태: 채택(정리)
- 날짜: 2026-02-17
- 결론:
  - `.ddn` 파일은 **이야기(Story)** 이다.
  - 이야기의 본문(씨앗/마디/움직씨 등)은 곧 **누리(Nuri: 결정론 상태기계/모델)** 를 정의한다.
  - 재사용 라이브러리는 누리가 아니라 **꾸러미(표준/나눔/내/벌림)** 로 부른다.
  - **거울(Mirror)** 은 작성 대상이 아니라, 실행이 만들어내는 산출물(로그/리플레이)이다.
- 근거/효과:
  - “내가 쓰는 코드가 곧 세계를 만든다”는 교육/창작 직관을 유지한다.
  - `누리`를 “레지스트리/꾸러미” 의미로 재사용하지 않아 용어 충돌을 방지한다.

===== END SSOT_DECISIONS_v20.6.33.md =====
===== BEGIN SSOT_LANG_v20.6.33.md =====
- **AGE1 런타임 타입검사(타입 표기 있는 경우만)**: PinSpec/TypeRef에 타입이 명시된 항목은 실행 시 강제하며, 불일치는 `E_RUNTIME_TYPE_MISMATCH`로 통일한다. (DR-067)
- **차림 인덱싱 설탕(AGE1+)**: `a[i]`, `a[i] <- v`는 DR-084의 canon 전개로 정본화한다.
- **계약 모드 표면 문법(AGE1)**: `바탕으로(알림|중단)`, `다짐하고(알림|중단)` 및 기본값(중단)은 DR-085를 따른다.
- **키보드 한국어 별칭(샘 입력)**: `위/아래/왼쪽/오른쪽/스페이스/엔터/...` 등은 DR-086에 따라 정본 키로 치환한다.
- **보개 배경색 키**: 정본 `보개_바탕색`, 레거시 `bogae_bg`는 DR-087에 따라 표기 통일한다.
- **AI 친화 Phase 0**: 주석 힌트 규격 + Self-Documented Pack + 오류 코퍼스 구축을 Phase 0 정준 루프로 채택한다. (DR-068)
- **심볼릭 미분/적분 변환 v1**: `미분하기/적분하기`는 Gate0에서 `#ascii` 수식만 지원하며, 자유변수 자동 선택/오류 규칙 + 옵션(차수/상수포함) 키를 고정한다. 수치 미분/적분(근사)은 별도 규격으로 분리한다. (DR-081)
- **보개 목록 키 v1**: 입력 키 `보개_그림판_목록`으로 Rect/Text/Sprite 항목 목록을 결정적 순서로 렌더한다. (DR-082)
- **보개 키는 view-only**: `보개_*`는 UI(보개/셈그림) 전용 네임스페이스이며, `state_hash` 입력에서 제외한다. (DR-152)
- **BDL2 서브픽셀/AA v1**: Q24.8 좌표/두께 + AA 플래그에 따른 정준 스냅 규칙을 최소 확정한다. (DR-083)
- **토큰/표기 일관성 v1**: `그리고/또는/아님` ↔ `&&/||` 동치 + 예약어 처리로 함수 호출과 구분을 고정한다. (DR-132)
- **텐서V0 정준 표현 v0**: `tensor.v0`(DetJson) 스키마(밀집/희소) + 정렬/불변식/해시 규칙을 고정한다. (DR-133)
- **통합 선언 설탕 `채비:`**: 한 블록에서 `=`(붙박이) + `<-`(그릇) 혼합 선언을 허용하고, 정본 출력은 `그릇채비:` + `붙박이마련:`으로 분해 저장한다. (DR-148)




# 또니랑 SSOT — LANG (v20.6.33, Normative)

> 이 문서는 **또니랑(Ddonirang)**의 *정본(규범) 언어 명세*입니다.  
> **AGE0(구 Gate0, 최초 공개 구현)** 에서 **AI/구현체가 같은 결과를 내도록** “모호함을 금지”하고, **의미가 달라지는 표기**에 대해서만 “정본 표기 1개”를 강제합니다.  
> 로드맵/기획 관점의 1차 축은 **AGE1+** 이며, 이는 `SSOT_ROADMAP_CATALOG`/`SSOT_PLANS`를 따릅니다.
> *(꼬리 스타일/괄호 등 ‘스타일’ 영역은 린트/포매터 옵션에서 다룹니다.)*

## §0 v19.2.4 핵심 결정(요약)

- **문서/예시에서도 제네릭 꺾쇠 표기 금지**: `차림〈T〉` 같은 표기는 쓰지 않으며, 자리표시자는 `〈…〉/《…》`만 사용합니다.  
  - *이유:* AI가 문서 메타 표기를 코드 문법으로 오인하는 1순위 원인을 제거합니다.
- **말결 토큰은 `$` 정본**: `$매우` 등. 대괄호 `[]`는 Gate0에서 **예약(말결 용도로는 미사용)** 입니다.  
  - *이유:* `[]`는 인덱싱/패턴/슬라이스 및 **차림(결정적 배열) 리터럴** 등 “구조적 기능”에 쓰일 가치가 크고, 말결는 `$`가 더 명확합니다.
  - *추가(결정: DEC-20260121-CHARIM-LIT-01):* AGE1+부터 `[]`(빈 차림), `[v1, v2, ...]`(차림 리터럴)은 **값 위치에서만** 허용한다. `수[]` 같은 **타입 표기**로의 `[]` 사용은 계속 금지한다.
  - *추가(결정: DEC-20260121-TENSOR-CANON-01):* 중첩 차림 `[[...],[...]]`는 **텐서 입력 설탕**으로만 허용하며, canon은 `형상=[행,열]` + `자료(평탄, 가로먼저)`로 정본화한다(불규칙 금지). *(tensor.v0 정준 표현/순서는 DR-133을 따른다.)*
  - *추가(결정: DR-072):* 텐서 표준 함수 최소 범위를 AGE1 Phase 0로 고정한다(`텐서.값/바꾼값` 포함, 범위 정책 고정).

- **불변 훅 정본 키워드**: `늘지켜보고` (레거시 별칭: `검사할때`).  
  - *이유:* “상시 감시(읽기 전용, 커밋 직전)” 의미가 가장 정확합니다.
- **조사 자동 분리 유지**: 입력은 붙여 써도 되며, 정본 출력에는 `~`를 반드시 삽입합니다. 모호하면 오류입니다.  
  - *이유:* 한국어 네이티브와 결정성(추측 금지)을 동시에 만족합니다.
- **정의와 호출 분리**: 씨앗 이름(정의)에는 꼬리를 붙이지 않고, 실행/연결은 꼬리로 표현합니다. (예: `~기/~하기`, `~고/~하고`, `~면/~하면`)  
  - *이유:* “이름=정의, 꼬리=실행”을 분리해야 AI가 정의명에 꼬리를 섞지 않습니다.
- **씨앗(익명함수) 리터럴 표기(v1)**: `{x | 식}` 를 정본 표기로 채택한다. `->`는 타입 시그니처 화살표와 충돌하므로 씨앗 구분자로 사용하지 않는다. (DR-076)
- **`-서` 금지 + `}해서` 정본**: `-서`(예: `미분해서`, `A 서 B`)는 Gate0에서 **문법 오류**. 파이프는 `~기/~하기 해서`만, 토막(별칭: 안은문장) 결과를 파이프할 때는 `{ ... }해서`만 사용한다.
  - *이유:* 레가시가 없고, `}한것 해서` 같은 비문을 제거하면서 파이프 규칙을 단순화한다.
- **정본화(포매팅)에서 불필요한 괄호 제거**: 의미(파스 결과)가 변하지 않는 괄호는 제거합니다. 의미가 바뀌는 괄호(우선순위/결합이 달라지는 곳)는 유지합니다.  
  - *이유:* 덜 verbose 하면서도, 결정성과 안전성을 유지합니다.


## §0A AI/LLM 코드 생성 규칙 (MUST)

이 문서는 사람뿐 아니라 **코드를 쓰는 AI**의 오해를 줄이기 위해, 아래를 “출력 규칙”으로 고정합니다.  
(사람이 작성할 때는 별칭 입력을 허용할 수 있지만, **AI 출력은 정본만**을 목표로 합니다.)

- AI는 **정본(표준) 키워드만 출력**합니다.
  - 계약: `바탕으로` / `다짐하고` *(legacy: `전제하에` / `보장하고` 는 출력 금지)*
  - 파이프: `~기 해서` 또는 `~하기 해서` *(legacy: `-서` 출력 금지, Gate0에서는 문법 오류)*
  - 토막(별칭: 안은문장) 즉시평가: `}한것`, `}인것`, `}아닌것`, `}하고`, `}해서` *(legacy: `}것` 출력 금지)*
- AI는 호출식을 만들 때 **꼬리 없는 이름을 “호출”로 쓰지 않습니다.**
  - ✅ `(10) 증가하기.`
  - ❌ `(10) 증가.`  *(이것은 “호출”이 아니라 “이름(값)”로 해석됩니다)*


## §1 바닥 규칙(상식 없는 구현체/AI를 위한 최소 문법)

- 주석: `// ...`
- 글(문자열): `"..."` (이스케이프 `\"`, `\\`, `\n`, `\t`)
- 문장 경계: 기본은 줄바꿈. 한 줄에 여러 문장을 넣을 때만 `.`(종결점) 사용 가능.
- 대입(상태 변경): 정본 `<-` 한 가지. 입력 설탕 `->` 허용(정본 출력은 `<-`).
- 복합 갱신(설탕): `+<-`, `-<-` (정본 전개: `x <- x + y` 등). `+=`, `-=`는 미지원.
- 점 `.`: 소수점/접근점/종결점으로만 토큰화(§DOT-LEX).

---


## §V18 v19.2.4 통합 개정 (Gate0 기준)

이 절은 **v17.* 명세를 바탕으로** Gate0(최초 공개 구현)에서 **문법/평가/계약**을 더 단단하게 만들기 위해 추가·교체된 규정을 정의합니다.

- **원칙:** *기존 내용은 유지*하되, 아래 항목이 **충돌하는 경우 v18 규정이 우선**합니다.
- **목표:** 파서 단순화, 결정성 강화, “슬기” 협업 친화, 그리고 Gate0 구현 난이도 통제.
- **중요:** v18은 `}것` 같은 중간 표기를 **정본에서 제거**하고, **평가 표지(한것/인것/하고)**로 고정합니다.

- **추가(논의 반영):** 파이프(`~기 해서`/`~하기 해서`) 단계는 **호출식만 허용**한다. ([PIPE-CALL-ONLY-01])
- **추가(논의 반영):** 차원 불일치는 **정적 오류 우선**, 경계 입력은 런타임 안전망을 둔다. ([UNIT-VALID-TIME-01/02])



#### 계약 위반의 진단 기록 — SHOULD (Toolchain)

계약 위반은 LANG 의미론(알림/중단)을 따르되, **거울 진단(geoul.diag.jsonl)**에 구조화된 기록을 남긴다.

- 기록 방식: **Signal::Diag(진단 레코드) 1건**으로 기록한다. (별도 Signal::ContractFault는 두지 않는다.)
- 필드(권장):
  - `reason`: `CONTRACT_PRE` | `CONTRACT_POST`
  - `rule_id`: 정본 규칙 ID (예: `L0-CONTRACT-01`)
  - `contract_kind`: `pre` | `post`
  - `mode`: `알림` | `중단`
  - `origin`: (P0-ORIGIN 규약) “어떤 계약/어떤 씨앗에서 발생했는지”
  - `targets`: 영향 대상(임자/필드 등)
  - `source_span`: 가능하면 포함 (OI-AI-11 준수: line/col 권장)

※ 구체 포맷은 **SSOT_PLATFORM §P9.5**를 따른다.

### [V18-00] Gate0 어조·활용 제한 (문법 단순화)
- Gate0의 **표면 꼬리(어미/접미)**는 구현 단순화를 위해 아래만을 사용합니다.
  - 서술(문장 종결): `~다.`  
  - 호출/연결 꼬리: `~기/~고/~면` 그리고 동치 표기 `~하기/~하고/~하면`
    - `기 ↔ 하기`, `고 ↔ 하고`, `면 ↔ 하면` 은 **동일 의미(AST 동일)** 입니다.
    - **정본화(Formatter)는 두 스타일을 서로 치환하지 않습니다.** *(입력 스타일 유지)*
  - 파이프 단계 꼬리: `~기 해서` 또는 `~하기 해서` *(둘 다 허용)*
- 꼬리 동치성은 **표면 표기만**의 문제이며, 의미/해석/상태 해시는 동일해야 합니다.
- Gate0는 한국어 형태소 분석(하다류 판별/불규칙 활용 등)을 하지 않습니다. *(심볼 테이블 + 꼬리 규칙만)*

### [V18-00C] 실행 꼬리(호출 어미) 동치 — MUST
**규칙 ID: `CALL-TAIL-EQUIV-01`**

Gate0는 씨앗 이름의 품사(명사/동사)를 추정하지 않는다.  
대신 **호출 표면형의 “꼬리”만**을 보고 문장 겹에서 “실행/연쇄/조건”을 표현한다.

- **동치 꼬리 집합**
  - **실행(명사화 실행):** `~기` 및 별칭 `~하기`
  - **연쇄(다음 문장으로 연결):** `~고` 및 별칭 `~하고`
  - **조건(분기 표지):** `~면` 및 별칭 `~하면`
- **동치 의미**
  - 위 꼬리 쌍은 **정본 AST가 동일**하며, `state_hash`/재현성에 영향을 주지 않는다.
  - 형식 차이는 **표기(겉모습)만**의 문제이다.
  - **정본화(Formatter)는 입력 꼬리 스타일을 유지**한다. (기/고/면 ↔ 하기/하고/하면 자동 치환 금지)
  - 프로젝트 스타일 통일은 **린트 규칙**으로만 권고한다.

- **추가(표준화, DR-069):** 계약 위반 진단 레코드는 `level/code/message`를 포함한 표준 필드를 사용한다.
- **추가(슬기 훅, DR-070):** AGE1에서는 계약 위반 발생 시 `슬기.계약위반` 훅을 **실행하지 않고 기록만** 남긴다.

#### 해석 규칙(결정적) — MUST
**규칙 ID: `CALL-TAIL-RESOLVE-01`**

표면 토큰 `W`가 위 꼬리 중 하나로 끝날 때, 정본화기는 다음 절차로 호출 대상을 확정한다.

1. `W`에 대해 가능한 `(stem, tail)` 분해 후보를 만든다.  
   - 예: `회복하기` → (`회복`, `하기`) / (`회복하`, `기`)  
   - 예: `회복하고` → (`회복`, `하고`) / (`회복하`, `고`)  
   - 예: `회복하면` → (`회복`, `하면`) / (`회복하`, `면`)
2. 각 후보 `stem`이 **현재 스코프의 씨앗 표(Symbol Table)에 존재하는지** 조회한다.
3. 일치 후보가 **정확히 1개**면 그 씨앗 호출로 확정한다.
4. 일치 후보가 **0개**면 문법 오류: `E_CALL_TAIL_NO_SEED`
5. 일치 후보가 **2개 이상**이면 모호성 오류: `E_CALL_TAIL_AMBIGUOUS`

> 구현 팁(비규범): 후보 생성은 “긴 꼬리 우선”으로 시도하되, **최종 결정은 ‘심볼 테이블 일치 개수’**로만 한다.

#### 예시
```ddn
(대상:플겹) 회복:움직씨 = {
    대상.HP <- 대상.HP + 10.
}

(나) 회복하기.        // OK (권장)
(나) 회복기.          // OK (별칭; '회복기'가 일반 명사와 헷갈리면 린트로 금지 권장)
(나) 회복하고 이동기. // OK (회복고 이동기와 동치)
```

```ddn
(대상:플겹) 회복하:움직씨 = {
    대상.HP <- 대상.HP + 10.
}

(나) 회복하기.  // OK: '회복'이 없으므로 (회복하, 기)로 해석
```
> **중요 (인자 vs 몸통):**  
> - `()`는 **인자/매개변수(입력)** 를 적는 곳이다.  
> - `{}`는 **정의 몸통(토막)** 으로, 관련 씨앗 정의/본문 로직을 담는 곳이다.  
> - 따라서 `{}`를 “인자 목록”으로 해석하지 않는다. 인자를 `{}`로 넘기는 표기(예: `풀기{ x=3 }`)는 SSOT 정본이 아니다.
>
> ✅ 올바른 정의(매개변수는 `()`):  
> ` (x:수, y:수) 직선:수식씨 = { ... } `  
>
> ✅ 올바른 호출(인자는 `()`/핀/조사로):  
> ` (x=3, y=4) 직선 풀기. `  
>
> ❌ 자주 나오는 오해(금지/오류):  
> ` 직선:수식씨 = { x:수, y:수 } `  // 이는 “인자”가 아니라 “직선 안에 x,y라는 씨앗을 정의”하는 뜻  
> ` 풀기{ x=3, y=4 } `               // `{}`는 인자 목록이 아님


---

### [V18-00D] `X` vs `X하` 이름 충돌 금지 — MUST
**규칙 ID: `SEED-NAME-CONFLICT-01`**

같은 스코프에서 **`X`와 `X하`를 서로 다른 씨앗으로 동시에 정의할 수 없다.**

- **이유(결정성):** `X하기/하고/하면`은 (1) `X+하기/하고/하면` 또는 (2) `X하+기/고/면`으로 **동시에 분해**될 수 있다.
- **처리:** 정본화기 단계에서 오류로 실행을 거부한다.  
  - 오류 코드: `E_SEED_NAME_CONFLICT_HA`
- **해결책:**
  1) 둘 중 하나를 다른 이름으로 바꾼다.  
  2) (AGE2) “별칭(동일 구현)” 문법이 도입되면, `X하`를 `X`의 별칭으로만 허용한다.

```text
(대상:플겹) 회복:움직씨 = { ... }
(대상:플겹) 회복하:움직씨 = { ... }  // ❌ E_SEED_NAME_CONFLICT_HA
```


### [V18-00A] 정본 어휘·별칭 정책 (순우리말 우선) — MUST
- 또니랑 SSOT의 **정본 표기**는 가능한 한 **순우리말**을 우선한다.
- 다만 Gate0의 학습 장벽과 생태계 관용어를 고려하여, 영어/한자어/관용어는 **별칭(Alias)** 으로 병행한다.
- 정본화기/린트(`ssot-lint`)는 별칭을 감지하면 **정본 용어로 교정 출력**하거나, 문서에서는 **교정 제안**을 제공한다.
- 승격 정책:
  - **정본 승격(별칭→정본)** 은 메이저 버전에서만 수행한다.
  - **정본 금지(별칭→MUST NOT)** 는 최소 1개 메이저 버전의 유예 기간 뒤에만 가능하다.
- v18에서 확정된 핵심 용어(문서 정본):
  - **곳간(Registry)**: 목록/레지스트리/등록부
  - **쓸감(쓸감)**: 파일/쓸감
  - **바탕(Resource)**: 터바탕씨/자원(ECS 전역 상태)
  - **샘(Source/Actor)**: 원천/액터/주체
- 흔히 쓰이는 CS 용어(변수/상수 등)는 Gate0에서 **기존 표기 유지**를 허용하며, 순우리말(예: **그릇/말뚝**)은 **별칭**으로 제공한다(향후 승격 가능).

#### 용어 정책 (순우리말 정본 + 별칭 허용) — MUST
- Gate0의 정본 문서/정본화 출력은 **순우리말 정본(곳간/쓸감/바탕/샘)**을 사용합니다.
- 영어/한자 용어는 **별칭**으로 입력에서만 허용되며, 정본화기는 항상 정본으로 수렴합니다.
- 혼동을 막기 위해 `자원.`은 비정본(Deprecated)로 두고, `쓸감.`/`바탕.`으로 분리합니다.

## §TERM 순우리말 정본/별칭(말모이) — MUST

원칙:
- **정본(문서/예시/포매터 출력)은 1개**만 둔다. (MUST)
- 별칭(한자어/외래어/과거 표기)은 **입력으로만 허용**할 수 있다. (MAY)
- 정본화기는 소스를 자동 수정하지 않는다. 변경은 덧댐 제안 + 승인으로만. (MUST NOT)

핵심 용어(정본 → 별칭):
- 불변 훅: `늘지켜보고` → `검사할때`
- 전제(Pre): `바탕으로` → `전제하에`
- 보장(Post): `다짐하고` → `보장하고`
- 수선(Repair): `바로잡기/바로잡는다` → `고치기/고친다`, `수선`
- 구조화 진단: `살핌말` → `진단`, `diag`
- 자유 출력/로그: `남김글` → `출력`, `로그`, `print`
- AI 협업: `묻기/대답` → (세계관 별칭) `울림/비나리` *(플랫폼/데모 문맥에서만 사용)*

호출 표기 권장:
- 정의는 `살핌말:움직씨`, 호출은 `살핌말하기.`처럼 **꼬리로 실행**한다.
- 명사형 씨앗 호출은 문서/예시에서 `~하기`를 권장한다. (SHOULD)

---





### [V18-00A-1] TERM-MAP(정본 용어 맵) — MUST (단일 소스 / Gate0 린트의 근거)

Gate0의 **TERM-LINT/NAME-LINT**는 아래 **TERM-MAP**을 유일한 근거(SSOT Single Source of Truth)로 삼습니다.

- **FATAL(치명 금지어)**: 파서(lexer/parser) 단계에서 **즉시 오류(MUST)**.
- **LEGACY(레거시 별칭)**: 정본화기(Canonicalizer)에서 **경고/추천(SHOULD)**. 자동 치환은 **금지(MUST NOT)**.
- **Patch 승인(MUST)**: 레거시 치환은 `ddn.patch.json`(선언적 고침)으로 제안되고, 사용자의 **승인 후에만** 적용됩니다(§T15 참조).

#### 1) 변경 정책(Versioning)
TERM-MAP은 **용어가 안정될수록 점진적으로 확장**될 수 있습니다.

- **FATAL/LEGACY 목록 변경**: **MINOR(y) 증가 시에만 허용** (예: v18.(y+1).12)
- **PATCH(z) 업데이트**: 오탈자/설명 보강만 허용. **목록 의미 변경 금지**
- 변경 시에는 `SSOT_ROADMAP_CATALOG`의 “용어 변화 로그”에 요약을 남깁니다.

#### 2) FATAL(치명 금지어) — 초기 5~20개 권장
아래 목록은 **Gate0 초기 세트**입니다. (추가/조정은 위 변경 정책을 따릅니다.)

| 코드 | 입력(금지) | 정본(추천) | 요지 |
|---|---|---|---|
| TERM-FATAL-001 | 자산 | 쓸감 | 프로젝트 “asset” 개념 정본화 |
| TERM-FATAL-002 | 객체 | 임자 | 세계의 주체/대상을 하나로 고정 |
| TERM-FATAL-003 | 리소스 | 바탕 | 전역/공유 상태(Resource) 정본화 |
| TERM-FATAL-004 | 프레임 | 마디 | 결정적 시간 단위 정본화(렌더 프레임과 구분) |
| TERM-FATAL-005 | 입력 | 샘 | 결정적 입력/관측 개념 정본화 |
| TERM-FATAL-006 | 가드 | 지킴이 | 규칙/불변식(Guardian) 정본화 |
| TERM-FATAL-007 | 에러 | 고장 | 실패/위반의 표준 용어 정본화 |
| TERM-FATAL-008 | 랜덤 | 주사위 | 결정성 모드(무쇠/주사위) 혼동 방지 |
| TERM-FATAL-009 | 디버그 | 거울 | TOOLCHAIN 관측/질의 영역 정본화 |
| TERM-FATAL-010 | 상태 | 누리 | state_hash/누리 의미론 고정 |
| TERM-FATAL-011 | 로그 | 진단말 | diag/trace 시스템과 용어 충돌 방지 |
| TERM-FATAL-012 | 덧댐 | 고침 | ddn.patch.json(수선/고침)과 용어 충돌 방지 |

> 참고: `자원` 같은 한국어 일반어는 **FATAL로 두지 않습니다.** (초기 혼란을 줄이기 위해 LEGACY 경고 후보로만 다룸)

#### 3) LEGACY(레거시 별칭) — SHOULD (경고/추천)
아래는 다른 언어 습관에서 넘어오는 사용자를 위한 **경고/추천**입니다.

| 코드 | 입력(레거시) | 추천(정본) | 비고 |
|---|---|---|---|
| TERM-WARN-001 | 변수 | 이름 / 이름씨 | 문맥에 따라 선택 |
| TERM-WARN-002 | 함수 | 움직씨 | ‘함수씨’는 타입 맥락에서 사용 |
| TERM-WARN-003 | 클래스 | 이름씨 | 구조/이름씨로 유도 |
| TERM-WARN-004 | 이벤트 | 알림씨 | ‘알림’ 계열로 유도 |
| TERM-LEGACY-004 | 모양 | 생김새 | 상태 키/이름씨(보개 표현) 정본화 |
| TERM-LEGACY-005 | 트레잇 | 특성 | `생김새.특성` 필드명 정본화 |
| TERM-LEGACY-006 | bogae_canvas_w | 보개_바탕_가로 | 보개 캔버스 가로(px) 키 정본화 |
| TERM-LEGACY-007 | bogae_canvas_h | 보개_바탕_세로 | 보개 캔버스 세로(px) 키 정본화 |
| TERM-LEGACY-008 | bogae_bg | 보개_바탕색 | 보개 캔버스 배경색 키 정본화 |
| TERM-LEGACY-009 | 관계씨 | 맞물림씨 | 씨앗 종류(관계→맞물림) 정본화 |
| TERM-LEGACY-010 | 반복 | 되풀이 | 루프 키워드 정본화(입력 별칭) |
| TERM-LEGACY-011 | 반환 | 되돌림 | return 키워드 정본화(입력 별칭) |
| TERM-LEGACY-012 | 감사 | 톺아보기 | audit/trace 용어 정본화(입력 별칭) |
| TERM-LEGACY-013 | 텐서 | 겹차림 | tensor 용어 정본화(입력 별칭) |
| TERM-LEGACY-014 | 정본 | 바른꼴 | canon 용어 정본화(입력 별칭) |
| TERM-LEGACY-015 | 시험줄 | 해봄줄 | test line 용어 정본화(입력 별칭) |
| TERM-LEGACY-016 | 차림표 | 차림판 | table/list 표기 혼선 완화(입력 별칭) |


#### 4) 기계 판독용 TERM-MAP 블록 — MUST
아래 JSON 블록은 TOOLCHAIN이 **그대로 추출하여** 린트 상수/테이블을 생성(codegen)합니다.  
(이 블록의 해시가 TermMap 해시의 근거가 됩니다.)

```json
{
  "term_map_version": "tm-1",
  "fatal_terms": [
    {
      "code": "TERM-FATAL-001",
      "input": "자산",
      "canonical": "쓸감"
    },
    {
      "code": "TERM-FATAL-002",
      "input": "객체",
      "canonical": "임자"
    },
    {
      "code": "TERM-FATAL-003",
      "input": "리소스",
      "canonical": "바탕"
    },
    {
      "code": "TERM-FATAL-004",
      "input": "프레임",
      "canonical": "마디"
    },
    {
      "code": "TERM-FATAL-005",
      "input": "입력",
      "canonical": "샘"
    },
    {
      "code": "TERM-FATAL-006",
      "input": "가드",
      "canonical": "지킴이"
    },
    {
      "code": "TERM-FATAL-007",
      "input": "에러",
      "canonical": "고장"
    },
    {
      "code": "TERM-FATAL-008",
      "input": "랜덤",
      "canonical": "주사위"
    },
    {
      "code": "TERM-FATAL-009",
      "input": "디버그",
      "canonical": "거울"
    },
    {
      "code": "TERM-FATAL-010",
      "input": "상태",
      "canonical": "누리"
    },
    {
      "code": "TERM-FATAL-011",
      "input": "로그",
      "canonical": "진단말"
    },
    {
      "code": "TERM-FATAL-012",
      "input": "덧댐",
      "canonical": "고침"
    },
    {
      "code": "TERM-FATAL-013",
      "input": "world",
      "canonical": "누리"
    },
    {
      "code": "TERM-FATAL-014",
      "input": "scene",
      "canonical": "마당"
    },
    {
      "code": "TERM-FATAL-015",
      "input": "level",
      "canonical": "판"
    },
    {
      "code": "TERM-FATAL-016",
      "input": "월드",
      "canonical": "누리"
    },
    {
      "code": "TERM-FATAL-017",
      "input": "씬",
      "canonical": "마당"
    },
    {
      "code": "TERM-FATAL-018",
      "input": "레벨",
      "canonical": "판"
    },
    {
      "code": "TERM-FATAL-019",
      "input": "toolchain",
      "canonical": "연장줄"
    },
    {
      "code": "TERM-FATAL-020",
      "input": "platform",
      "canonical": "틀"
    },
    {
      "code": "TERM-FATAL-021",
      "input": "runtime",
      "canonical": "틀"
    },
    {
      "code": "TERM-FATAL-022",
      "input": "realm",
      "canonical": "터"
    },
    {
      "code": "TERM-FATAL-023",
      "input": "adapter",
      "canonical": "끼우개"
    },
    {
      "code": "TERM-FATAL-024",
      "input": "manifest",
      "canonical": "차림표"
    },
    {
      "code": "TERM-FATAL-025",
      "input": "filter",
      "canonical": "체"
    },
    {
      "code": "TERM-FATAL-026",
      "input": "q-chain",
      "canonical": "솎음줄"
    },
    {
      "code": "TERM-FATAL-027",
      "input": "qchain",
      "canonical": "솎음줄"
    },
    {
      "code": "TERM-FATAL-028",
      "input": "q chain",
      "canonical": "솎음줄"
    },
    {
      "code": "TERM-FATAL-029",
      "input": "q줄",
      "canonical": "솎음줄"
    },
    {
      "code": "TERM-FATAL-030",
      "input": "큐체인",
      "canonical": "솎음줄"
    },
    {
      "code": "TERM-FATAL-031",
      "input": "manim",
      "canonical": "움직이는 셈그림"
    },
    {
      "code": "TERM-FATAL-032",
      "input": "만임",
      "canonical": "움직이는 셈그림"
    },
    {
      "code": "TERM-FATAL-033",
      "input": "capability",
      "canonical": "할힘"
    },
    {
      "code": "TERM-FATAL-034",
      "input": "permission",
      "canonical": "할힘"
    },
    {
      "code": "TERM-FATAL-035",
      "input": "wordbinding",
      "canonical": "말힘누리"
    },
    {
      "code": "TERM-FATAL-036",
      "input": "incantation",
      "canonical": "말힘"
    },
    {
      "code": "TERM-FATAL-037",
      "input": "쿼리",
      "canonical": "여기에서_찾기"
    },
    {
      "code": "TERM-FATAL-038",
      "input": "필터",
      "canonical": "체"
    },
    {
      "code": "TERM-FATAL-039",
      "input": "forEach",
      "canonical": "각각_돌며"
    }
  ],
  "legacy_terms": [
    {
      "code": "TERM-WARN-001",
      "input": "변수",
      "canonical": "이름/이름씨"
    },
    {
      "code": "TERM-WARN-010",
      "input": "query",
      "canonical": "여기에서_찾기"
    },
    {
      "code": "TERM-WARN-012",
      "input": "for_each",
      "canonical": "각각_돌며"
    },
    {
      "code": "TERM-WARN-002",
      "input": "함수",
      "canonical": "움직씨"
    },
    {
      "code": "TERM-WARN-003",
      "input": "클래스",
      "canonical": "이름씨"
    },
    {
      "code": "TERM-WARN-004",
      "input": "이벤트",
      "canonical": "알림씨"
    },
    {
      "code": "TERM-LEGACY-001",
      "input": "stage",
      "canonical": "마당"
    },
    {
      "code": "TERM-LEGACY-002",
      "input": "스테이지",
      "canonical": "마당"
    },
    {
      "code": "TERM-LEGACY-003",
      "input": "언령게임",
      "canonical": "말힘누리"
    },
    {
      "code": "TERM-LEGACY-004",
      "input": "모양",
      "canonical": "생김새"
    },
    {
      "code": "TERM-LEGACY-005",
      "input": "트레잇",
      "canonical": "특성"
    },
    {
      "code": "TERM-LEGACY-006",
      "input": "bogae_canvas_w",
      "canonical": "보개_바탕_가로"
    },
    {
      "code": "TERM-LEGACY-007",
      "input": "bogae_canvas_h",
      "canonical": "보개_바탕_세로"
    },
    {
      "code": "TERM-LEGACY-008",
      "input": "bogae_bg",
      "canonical": "보개_바탕색"
    },
    {
      "code": "TERM-LEGACY-009",
      "input": "관계씨",
      "canonical": "맞물림씨"
    },
    {
      "code": "TERM-LEGACY-010",
      "input": "반복",
      "canonical": "되풀이"
    },
    {
      "code": "TERM-LEGACY-011",
      "input": "반환",
      "canonical": "되돌림"
    },
    {
      "code": "TERM-LEGACY-012",
      "input": "감사",
      "canonical": "톺아보기"
    },
    {
      "code": "TERM-LEGACY-013",
      "input": "텐서",
      "canonical": "겹차림"
    },
    {
      "code": "TERM-LEGACY-014",
      "input": "정본",
      "canonical": "바른꼴"
    },
    {
      "code": "TERM-LEGACY-015",
      "input": "시험줄",
      "canonical": "해봄줄"
    },
    {
      "code": "TERM-LEGACY-016",
      "input": "차림표",
      "canonical": "차림판"
    }
  ],
  "josa_only": [
    "이",
    "가",
    "을",
    "를",
    "은",
    "는",
    "에",
    "로",
    "의",
    "도",
    "만",
    "와",
    "과",
    "에서",
    "에게",
    "께",
    "부터",
    "까지",
    "ob",
    "sb",
    "tp",
    "at",
    "by",
    "fr",
    "to",
    "fm",
    "un"
  ],
  "reserved_words": [
    "마디",
    "샘",
    "임자",
    "누리",
    "지킴이",
    "고장",
    "거울",
    "쓸감",
    "바탕",
    "진단말",
    "고침"
  ]
}
```



### [V18-00B] 버전 표기 정책 — MUST
- **리비전 표기(r1, r2 …)**는 사용하지 않는다.
- 문서 보강/명세 명료화/오류 수정/호환 유지 변경은 **PATCH(+1)** 로만 올린다. (예: v18.0.10 → v19.2.4)
- 문법·의미론의 **하위호환 파괴**가 생기면 **MAJOR**를 올린다. (예: v18.x → v19.2.4)
- 호환을 유지한 기능 추가(새 문법/새 표준 기능)는 **MINOR**를 올린다. (예: v18.0 → v18.1)


---

### [V18-01] 토막(별칭: 안은문장) `{ }`과 평가/파이프 표지 `}한것 / }인것 / }아닌것 / }하고 / }해서`

> 메모: 이 SSOT에서 **토막**은 ‘글–마디’ 사이(또는 마디 안)의 더 작은 묶음 단위로도 쓰인다.  
> - 사람에게는 “여기만 고치자” 단위  
> - AI에게는 “덧댐 최소 단위”  
> 용어/역할은 `SSOT_TERMS_v20.6.33.md`와 `SSOT_DECISIONS_v20.6.33.md (DR-002)`를 함께 본다.



### [V18-01A] 움직씨(동작) 호출과 `}하고`의 경계 — MUST
- **움직씨(동작) 문장** `먹기.` `점프하기.` 처럼 **문장으로 끝나면 즉시 실행**이다. (Gate0의 기본 “부작용 실행” 형태)
- **`{ ... }`는 언제나 일묶음씨(Thunk)** 이므로, `{ 먹기 }`만으로는 실행되지 않는다.
- `{ ... }하고.`는 **Thunk를 즉시 실행(do)** 하는 표지이며, **단일 움직씨 문장**은 다음과 동치인 **문법 설탕**으로 본다.
  - `먹기.`  ≡  `{ 먹기 }하고.`
- 따라서 Gate0 파서는 다음 두 겹을 분리한다.
  1) **문장 겹:** `...하기.` / `...하기 해서 ...하기.` (즉시 실행)
  2) **표현식 겹:** `{ ... }` (지연) + `}한것/}인것/}아닌것/}하고` (즉시 평가)
- **정본화(Canonicalize) 권고:** 단일 움직씨는 `먹기.` 형태로 내보내고, 여러 줄/복합 Thunk 실행만 `{ ... }하고.`로 유지한다.

**움직씨(Action) 호출 vs 일묶음씨(Thunk) 실행: MUST**
- `움직씨` 호출(예: `먹기.` `이동하기.`)은 **문장 겹**에서 **즉시 실행**됩니다. `{ }`로 감싸지 않아도 됩니다.
- `{ ... }`는 언제나 **일묶음씨(Thunk, 지연)** 입니다. 즉시 실행하려면 반드시 **평가 표지**를 붙입니다.
  - `{ ... }하고` : **부작용을 위해 실행**(반환값은 버림/없음)  
  - `{ ... }한것` : **값을 얻기 위해 실행**(마지막 값 반환)  
  - `{ ... }인것 / }아닌것` : **판정**(불리언)
- 움직씨를 “값처럼” 다루거나(보관/전달/약속/계약) 파이프에 태우려면: **`{ 움직씨호출 }`로 싸서 Thunk로 만든 뒤** 평가 표지를 사용합니다.
  - 예: `{ 먹기 }하고` / `{ 이동하기 }하고`
- 따라서 다음은 **의미는 비슷하지만 계층이 다릅니다**:
  - `먹기 해서 배부르기.`  → 움직씨 연쇄(문장)  
  - `{ 먹기 }하고 { 배부르기 }하고.` → 일묶음씨를 명시 실행(표현식/제어구문에 쓰기 쉬움)



#### 1) `{ ... }`의 정체
- `{ ... }`는 **항상 일묶음씨(Thunk, 지연 보따리)**를 만든다. (기본은 “실행되지 않은 코드 덩어리”)
- Gate0에서 `{ ... }` 내부의 **동작(움직씨) 호출/연쇄**는 **반드시 `~기` 형태**로만 기술한다. (`~다.` 종결 금지; 셈씨/값 표현식은 그대로 허용)

#### 2) 즉시 평가(실행) 표지 — 정본
- `}한것` : Thunk를 **즉시 실행**하여 **값(Value)**을 얻는다.
- `}해서` : Thunk를 즉시 실행해 **값(Value)**을 얻고, 그 값을 **즉시 다음 CallExpr로 파이프**한다. (`}한것 해서`는 금지; fix-it: `}해서`)
- `}인것` : Thunk를 **즉시 실행**하여 결과를 **참/거짓(Bool)**로 해석한다.
- `}아닌것` : `}인것`의 부정. (`NOT`)
- `}하고` : Thunk를 **즉시 실행**하되 결과값은 버린다. (부작용/행동 실행)

**선택 가이드(빠른 판단)**

| 표지 | 의미 | 반환/용도 | 비고 |
|---|---|---|---|
| `}한것` | 평가 | 값(대입/저장) | “값 만들기” |
| `}인것` | 평가 | 참/거짓(조건) | “판정” |
| `}아닌것` | 평가 | 참/거짓(부정 조건) | “부정 판정” |
| `}하고` | 실행 | 반환값 무시(부작용) | “행동만” |
| `}해서` | 평가+파이프 | 값을 다음 CallExpr로 전달 | 단독 종결/대입 불가 |

- `}것`은 **타입이 불명확**하므로 Gate0에서 금지(FATAL)입니다.
- `}한것 해서`는 한국어로도 비문이고, 의미도 중복이어서 금지합니다. (fix-it: `}해서`)

> 정본 원칙: **“즉시 평가 의도”는 반드시 표지로 드러나야** 한다.

#### 3) Gate0 순수성(부작용) 규정
- `}인것` 내부에서는 **상태 대입(`< -`)을 MUST 금지**한다. (관찰은 세계를 바꾸면 안 됨)
- `}한것` 내부 상태 대입은 Gate0에서 **MUST 금지**로 두고, 필요 시 AGE2에서 “허용 구역”을 별도로 정의한다.
- `}하고`는 “행동 실행”이므로 부작용 가능. 다만 **결정성 규칙(순서/운 소비)**을 따라야 한다.

4) 동시성/병렬 실행 (예약 / Gate0 비지원)
- Gate0에서 `{ ... }` 는 **병렬 묶음**이 아니라 **Thunk(블록)**이다. “두 블록을 동시에 실행”하는 문법은 없다.
- 다음 표지는 **미래 확장용으로 예약**만 해두고, Gate0에서는 사용 불가(파싱 에러)로 둔다:
  - `}하며` : (예약) 병렬/동시 수행 혹은 “하면서” 연결자 후보
  - `}한채` : (예약) “~한 채로/동안” 상태-유지 연결자 후보
  - `}하자마자` : (예약) “완료 직후” 트리거 연결자 후보
- 병렬/동시성은 AGE3에서 **구조화 동시성(취소/오류 전파/합성 규칙 포함)**으로 별도 설계한다.

---

### [V18-02] 상태 대조 `~해보고:` + 분기 `고르기:` (아니면 MUST)

#### 1) `~해보고:` (Try-and-bind)
- 문법: `〈동작〉 해보고:`  
  - 해당 동작을 **1회 실행**하고, 결과(또는 관측치)를 **그것**에 바인딩한다.
- `그것`의 유효 범위: **해보고: 블록 내부(및 하위 블록)**로 한정한다.

#### 2) `고르기:` (Case) — 총망라성 강제
- `고르기:`는 **반드시 `아니면:` 갈래를 가져야** 한다. (MUST)
- 이유: Gate0는 결정적이어야 하며, “빠진 경우”가 곧 버그/재현성 파괴가 되기 쉽다.

---

### [V18-03] 선택 분기 `고르기:` — Gate0 MUST

`고르기:`는 “조건 목록 + 기본값(아니면)”의 **결정적 분기**이다.

```ddn
고르기:
  { (조건1) }인것: 
    (문장A).
    (문장B).
  { (조건2) }인것:
    (문장C).
  아니면:
    (문장D).
```

- `고르기:` 아래에는 **0개 이상의 조건 분기 + 반드시 1개의 `아니면:`**이 온다.
- `아니면:`은 **반드시 마지막**에 있어야 하며, Gate0에서는 생략할 수 없다.
- 조건 분기는 Gate0에서 **반드시** `{ ... }인것:` 형태를 사용한다. *(패턴/매칭 분기는 AGE2)*
- **평가 규칙(결정적):**
  1) 위에서 아래로 조건을 평가한다.  
  2) 최초로 참이 되는 분기의 본문만 실행한다.  
  3) 나머지 분기의 조건/본문은 평가하지 않는다.
- **순수 조건 제약(Gate0 MUST):** 조건 `{...}인것` 안에는 `<-`, `}하고`, I/O, 운(Random) 등 **부작용/소비**가 금지된다. (위반 시 오류)

---

### [V18-04] 계약(전제/보장) — Gate0 기본형(명시적 비상구 + 수선)

Gate0에서는 계약을 **“명세(규정)로서 먼저 고정”**하고, 구현은 최소 훅부터 시작한다.

#### 1) 정본 문법(MUST; 권장 순서: 아니면 → 맞으면)

- 바탕으로/다짐하고 블록에서는 `아니면` 절이 **MUST**이다. (명시적 실패 경로 강제)
- `맞으면` 절은 **선택**이며, 생략 시 "그대로 진행"으로 해석한다.
```ddn
{ P }인것 바탕으로
  아니면 { E }하고.
  맞으면 { B }하고.
{ Q }인것 다짐하고
  아니면 { R }로 고친다.
```

- **전제(pre):** `P`가 거짓이면 `E`를 실행하고, 해당 계약 구역을 **거부(Reject)**한다. (기본: 안전 종료)
- **맞으면:** `B` 실행 후 다음 단계로 진행.
- **보장(post):** `Q`가 거짓이면 `R`을 실행하여 **수선(Repair)**한다.
  - 수선 후 `Q`를 **1회 재검사**한다.
  - 재검사 단계는 **순수 검증**이며, 재검사 실패 시에는 **`아니면`/`수선` 블록을 다시 실행하지 않고 즉시 중단**한다. (수선은 최대 1회)
  - 재검사에도 실패하면 Gate0 기본은 **중단(Abort)**한다. (결정성/안전성)

#### 2) 단계별 엄격도(AGE2 확장 예고)
- `전제(알림)` / `보장(알림)` : 기록만 남기고 계속
- `전제(중단)` / `보장(중단)` : 기본값
- `... 슬기에게: "..."` : 계약 위반 시 ‘슬기’ 협업 훅 (AGE3)
  - 이는 **밖일(효과) 계열**이며, AGE3에서 **밖일갈래/할힘(권한)** 체계로 관리한다.

---

### [V18-05] 운(Random) 소비 규칙 — “리플레이가 절대 깨지지 않게” (Gate0 MUST)

- 모든 `마디`는 **난수 소비 카운터**를 가진다. RNG는 *마디 단위*로 결정적이다.
- Gate0는 RNG 소비가 **제어 흐름/단락 평가**에 의해 “숨겨지지” 않도록 아래를 강제한다.

1) **판정(검증) 영역에서 RNG 금지 — MUST**  
   - `{...}인것`(조건/검증) 내부, `고르기:`의 조건, `계약`의 전제/보장 검증(P/Q)에는 **운(Random) 사용 금지**.  
   - RNG가 필요하면 먼저 값으로 뽑아 변수에 담고, 그 변수를 조건에 사용한다.

2) **표현식 평가 순서 고정 — MUST**  
   - 함수 인자/연산자/표현식은 **좌→우**로 평가한다.  
   - 컴파일러 최적화는 평가 순서를 바꿀 수 없다.

3) **`그리고/또는`의 단락 평가 금지(검증 영역) — MUST**  
   - Gate0에서 `{...}인것` 내부의 `그리고/또는`는 **양쪽을 모두 평가**한 뒤 결합한다.  
   - (AGE2에서 필요 시 단락 평가를 별도 키워드로 도입 가능)

---


### [V18-05A] 머릿말(HeadSpec) — 블록을 여는 말의 통합 — MUST

또니랑은 “블록을 여는 말(머릿말)”을 **닫힌 집합**으로 고정합니다.  
즉, `{ ... }` 블록 앞에 올 수 있는 ‘머릿말씨’는 언어가 정한 목록만 허용되며, 사용자가 임의로 새 머릿말을 정의할 수 없습니다.

**이유(설계 목표):**

- 교육/가독성: “이 줄이 블록을 연다”가 한눈에 보이도록.
- 결정성: 같은 표면을 항상 같은 AST로 고정.
- 도구화: LSP/정본화기가 머릿말을 정확히 인식해 자동 도움(스니펫/QuickFix)을 제공.

#### 1) 머릿말씨의 공통 모양

머릿말은 크게 두 부류입니다.

1) **콜론 머릿말**: `이름:` 처럼 끝이 `:`인 형태 (문장 단위 제어)  
2) **꼬리 머릿말**: `...할때` 처럼 꼬리(말끝) 자체가 “블록 열기”인 형태 (이벤트/훅)

두 경우 모두 뒤에 **블록**이 따라옵니다.

```ddn
고르기:
  { (x > 0) }인것:
    "양수" 보여주기.
  아니면:
    "0 이하" 보여주기.

(#레벨업)할때 {
  "레벨업!" 보여주기.
}.
```

#### 2) 대표 머릿말 목록(99걸음 완료 기준)

| 분류 | 말머릿말(정본) | `:`(콜론 문장형) | 뒤에 오는 것(요약) | 예 |
|---|---|:--:|---|---|
| 제어(분기) | `고르기:` | O | 가지 목록(조건들 + `아니면:`) | `고르기: ...` |
| 제어(시도/바인딩) | `~해보고:` | O | 블록 + `그것` 바인딩 | `(... ) 해보고: ...` |
| 반복(무한) | `반복:` | O | 블록 | `반복: ...` |
| 반복(조건) | `~동안:` | O | 블록 | `{조건}인것 동안: ...` |
| 반복(순회) | `~에 대해:` | O | 블록 | `목록에 대해: ...` |
※ 위 표의 `:` 열은 **콜론 문장형(예: `고르기:`)** 사용 여부를 뜻합니다. `X`는 “해당 문법이 미지원”이라는 뜻이 아닙니다. 예: `(매마디)마다 { ... }`는 **지원 문법**이며, `매마디`는 임자(바인더) 예시 이름입니다. (DR-077)
#### 2.1) 임자(바인더)로 지역 변수 만들기(바탕.* 최소화)

- `(임자)마다 { ... }`, `(임자) 모두 { ... }`에서 괄호 안 `임자`는 블록 내부의 **지역 변수**입니다. (DR-077)
- `바탕.*`은 명시적 전역을 가리킬 때만 쓰는 것을 권장합니다.
- 괄호 임자를 생략하면 정본 임자는 `매마디`이며, 블록 안에서 `그것`은 현재 임자와 동치인 짧은 별칭입니다.


| 군집(설탕) | `모두 {}` | O | 블록 | `(임자) 대상차림 모두 { ... }.` → `(임자) 대상차림에 대해: { ... }.` || 계약(전제) | `{P}인것 바탕으로` | X | `맞으면 { ... }하고.` / `아니면 { ... }하고.` | `{P}인것 바탕으로 ...` |
| 계약(사후) | `{Q}인것 다짐하고` | X | `아니면 { ... }로 고친다.` | `{Q}인것 다짐하고 ...` |
| 검사(불변) | `(조건) 늘지켜보고 { ... }` | X | `{ ... }` 블록 | `(x<0) 늘지켜보고 { ... }` |
| 훅(알림) | `(#태그)할때 { ... }.` | X | `{ ... }` 블록 | `(#레벨업)할때 { ... }.` |
| 훅(수명주기) | `(시작)할때 { ... }.` / `(끝)할때 { ... }.` | X | `{ ... }` 블록 | `(시작)할때 { ... }.` |
| 훅(시스템 반복) | `(매마디)마다 { ... }` | X | `{ ... }` 블록 | `(매마디)마다 { ... }` |
| (예약) 동시성 | `함께:` / `나란히:` | O | 블록(동시 실행) | `함께: ...` |
| (예약) 예외 | `시도:` / `붙잡기:` | O | 가지 목록 | `시도: ...` |

> `:`가 붙는 말머릿말은 “가지 목록/여럿 블록”을 여는 문장형 제어에 씁니다.  
> `:`가 없는 말머릿말은 뒤에 `{ ... }` 블록이 붙거나(훅/검사), `바탕으로/다짐하고`처럼 이어말 규칙으로 블록을 엮습니다.

> NOTE: 머릿말 목록은 SSOT에서 명시된 것만 유효하며, “비슷한 한글 표현”은 자동 추측하지 않습니다.
> 필요하면 별칭(정본화 입력 설탕)을 추가하되, **정본 출력은 항상 하나**로 고정합니다.


### [V18-05B] 순회/반복 머릿말씨 — `~에 대해:` / `~동안:` / `반복:` — MUST

반복/순회는 **머릿말씨**로 제공됩니다. (문법 확장 없이도 “한국어스러운 제어”를 얻기 위함)

#### 1) `반복:` (무한 반복)

```ddn
반복:
  "계속 돈다" 보여주기.
  { 멈출조건 }인것 이면:
    멈추기.
```

- `멈추기.`는 가장 가까운 반복 블록을 종료한다. (MUST)

#### 2) `~동안:` (조건 반복)

```ddn
{ (x < 10) }인것 동안:
  x <- x + 1.
```

- `동안:` 머릿말의 조건은 `}인것`/`}아닌것`으로 참거짓이 확정돼야 한다. (MUST)

#### 3) `~에 대해:` (순회/열거)

```ddn
(항목:수) (목록:수열~에 대해):
  "값=" 글무늬{항목} 채우기(항목=항목) 보여주기.
```

- `~에 대해:`는 “열거 가능한 값(수열/목록/범위 등)”을 순회한다. (MUST)
- 순회 변수(위 예의 `항목`)는 블록 내부에서만 유효한 새 살림이다. (MUST)

> NOTE: 구체적인 “열거 가능(Iterable)” 프로토콜은 표준 모듬(예: `표준.열거`)에서 정의한다. (SHOULD)
---

## 3. 기호 규칙: "생김새가 기능을 정의한다" — MUST

파서 구현의 복잡도를 낮추고 사용자 혼동을 줄이기 위해 다음 기호 규칙을 엄수합니다.

| 기호 | 용도 | 상세 |
|------|------|------|
| `{ }` | **로직과 범위(Scope)** | 정의부 뒤 = 본문(Body), 식 위치 = 일묶음씨(Thunk) |
| `( )` | **데이터와 설정(Data)** | 정의부 앞 = 타입/인자 설정, 식 위치 = 튜플/값 생성 |
| `$` | **말결/부사 토큰** | `$꽤`, `$매우` 등 퍼지 가중치 |
| `~` | **조사 접미(표면 바인딩/PinSpec 조사목록)** | `~을~를`, `~이~가` |
| `@` | **단위/쓸감 접미(단위 postfix / 쓸감 literal)** | `10@cm`, `@"그림/주인공.png"` |
| `:` | **핀 고정 접미(호출 인자에서만)** | `100@m:거리~에서`, `사과:대상~를` |

> 주의: `{}`는 JSON/사전/레코드 리터럴이 아닙니다. 데이터/구조 값은 `( )`로 만듭니다.

---

## 4. 어휘 및 구문 규칙 (Lexical & Syntax)

### 4.1 파일 및 인코딩

- **확장자:** `.ddn`
- **인코딩:** UTF-8 (BOM 없는 형식 권장, 파서는 BOM을 무시해야 함)

### 4.2 식별자와 리터럴

- **식별자:** 한글, 영문, 숫자, 밑줄(`_`) 조합. 숫자로 시작할 수 없습니다.
- **원자(Atom):** `#`으로 시작하는 식별자 (예: `#대기`, `#공격`)
  - *구현 노트:* 컴파일 타임에 유일한 **정수 ID(Interned String)**로 변환되어야 합니다.
- **주석:**
  - 한 줄: `// ...` (줄바꿈까지)
  - 블록: `/* ... */` (중첩 금지 — MUST)



#### 4.2.1 시스템 예약 “자음 식별자”(단자음) — MUST

또니랑은 `바탕.` 같은 **엔진 뿌리(root) 이름**을 초반부터 자주 쓰게 됩니다.  
하지만 데모/학습 코드에서 너무 길어지면 “읽는 순간 이해”와 “쓰는 순간 즐거움”이 떨어질 수 있으므로, **자음(ㄱ-ㅎ)만으로 된 토큰**을 **시스템 예약 약칭**으로 남겨 둡니다.

- **정의(자음식별자, JamoConsonantIdent)**: 아래 문자들만으로 1글자 이상 구성된 토큰
  - `ㄱ ㄲ ㄴ ㄷ ㄸ ㄹ ㅁ ㅂ ㅃ ㅅ ㅆ ㅇ ㅈ ㅉ ㅊ ㅋ ㅌ ㅍ ㅎ`
- **사용자 정의 금지:** 사용자는 씨앗/그릇/타입/핀 이름을 위 “자음식별자”로 정의할 수 없습니다. (MUST)  
  - 위반 진단(예시): `E_IDENT_JAMO_RESERVED`
- **허용 위치(시스템 뿌리 별칭):** 자음식별자는 아래 조건을 **둘 다** 만족할 때만 “값처럼” 등장할 수 있습니다. (MUST)
  1) 자음식별자 **바로 뒤에 접근점 `.`** 이 붙어야 함 (공백 금지)  
  2) 해당 자음식별자가 **시스템 뿌리 별칭표(SystemRootAlias)** 에 등록되어 있어야 함  
  - 위반 진단(예시): `E_SYS_JAMO_UNKNOWN`

##### 시스템 뿌리 별칭표 (초기 채택)

| 약칭 | 정본 | 뜻 |
|---|---|---|
| 약칭 | 정본 | 뜻 |
|---|---|---|
| `ㅂ.` | `바탕.` | 루트 바탕(상태/자원) |
| `ㅅ.` | `살림.` | (레거시 별칭) 루트 바탕 |

> 나머지 단자음/복자음은 **예약**만 하고, 의미 부여(할당)는 추후 SSOT 결정으로 추가합니다.  
> (예약의 목적: 사용자가 실수로 `ㄱ` 같은 이름을 쓰는 것을 막고, 시스템이 안정적으로 “짧은 뿌리”를 쓸 자리를 확보)

##### 예시

```ddn
바탕.중력 <- 9.8@mps2.
ㅂ.중력 <- 9.8@mps2.        // 동일 의미(별칭)
ㅅ.중력 <- 9.8@mps2.        // 레거시 별칭(입력만)
```

- 문서/튜토리얼의 기본 표기는 `바탕.`을 권장합니다.  
- `ㅅ.`은 “숙련/압축 표기”로 두며, 포매터는 사용자가 쓴 스타일을 자동으로 바꾸지 않습니다. (MAY)

### [ROOT-HIDE-01] 바탕 숨김(`#바탕숨김`) — SHOULD (교육/예제 가독성)

목적:
- 사용자 입력에서 `바탕.`(루트) 접두를 **생략**하여 예제/학습 코드의 시각적 잡음을 줄인다.
- 결정성/감사를 위해 **정본 출력(포매터)은 항상 `바탕.`을 드러내어** 저장한다.

규칙:
- 파일 머리에서 `#바탕숨김.`을 선언하면, 아래 두 형태를 동치로 해석할 수 있다(구현체 옵션으로 지원 가능).
  - `바탕.<이름>`  ≡  `<이름>`  *(단, “변수 참조/대입” 자리에서만; 머릿말/가지/트레잇 슬롯에는 적용 금지)*
- 안전장치(권장):
  - 선언되지 않은 새 바탕 칸(필드)을 “조용히 생성”하는 것을 금지하거나, 최소한 **오류/강경고**로 진단한다.
  - 바인더(지역) 이름이 있으면 지역이 우선이며, 루트 승격은 그 다음이다.

정본화 출력:
- 포매터는 `#바탕숨김`을 해제한 형태로 저장해도 된다(정본에서 접두를 항상 드러내기 위함).
- 입력 호환 별칭(레거시):
  - `#암묵살림` (deprecated) → `#바탕숨김` 권장





### [ROOT-HIDE-02] 바탕 숨김에서 “쓰기(대입)”는 미리 등록된 바탕칸만 허용 — SHOULD

배경:
- `#바탕숨김`은 접두(`바탕.`)를 생략해 가독성을 높이지만, 오타가 **새 바탕 칸 생성**으로 이어지면 디버깅이 매우 어렵다.

규칙(권장):
- `#바탕숨김` 모드에서 `<이름> <- ...` (쓰기/대입) 는 **미리 등록된 바탕칸**의 이름만 허용한다.
- 등록되지 않은 이름에 대한 쓰기는 오류(권장): `E-ROOT-HIDE-NEWFIELD`.
- 읽기(참조) 정책은 구현체 선택이나, 최소한 “없는 칸 참조”는 오류로 진단해야 한다.

연계:
- 바탕칸 등록은 [ROOT-DECL-01]을 사용한다.


### [GUREUT-DECL-01] 그릇채비 / 붙박이채비 — SHOULD (선언의 정본)

정의:
- `그릇채비:`는 **그릇(변수)** 을 채비(선언)한다.
- `붙박이마련:`는 **붙박이(상수)** 를 채비(선언)한다.

형태(정본 예):
```ddn
그릇채비: {
  점수:수.
  중력:수.
}.

붙박이마련: {
  원주율:수 = 3.141592.
}..
```

붙박이 규칙:
- `붙박이마련:` 안의 각 항목은 **반드시 알맹이(초기값)** 를 함께 제공해야 한다.
  - 정본 표기(권장): `이름:형 = 식.`
  - 예: `원주율:수 = 3.141592.`


스코프(중요):
- **전역 자리(파일 최상위)**에서의 `그릇채비/붙박이마련`는 **전역 그릇/붙박이 선언**이다.
- **셈씨/움직씨 본문(블록 내부)**에서의 `그릇채비/붙박이마련`는 **지역 그릇/붙박이 선언**이다.

연계(바탕숨김 안전장치):
- `#바탕숨김` 모드에서의 “쓰기(대입)”는
  - (1) 이미 존재하는 지역 그릇/붙박이
  - 또는 (2) 전역에서 `그릇채비`로 채비된 이름
  에 한해서만 허용하는 것을 권장한다.
- 선언 없이 `점수 <- ...`로 새 전역을 “조용히 생성”하는 동작은 금지/오류가 정본에 가깝다.





### [GUREUT-DECL-02] 그릇채비 항목은 “형만” 또는 “형+첫 넣기” — MUST

정의:
- 그릇(변수)은 바뀔 수 있으므로, **그릇채비는 “정의(=)”가 아니다.**
- 그릇채비는 “칸의 형식을 갖추는 행위(채비)”이며, 초기 알맹이를 주고 싶다면 “첫 넣기(초기 대입)”를 함께 둘 수 있다.

형태(정본):
1) 형만 채비:
```ddn
그릇채비: { 점수:수. }.
```

2) 형+첫 넣기(초기 대입) 채비:
```ddn
그릇채비: { 점수:수 <- 0. }.
```

규칙:
- `그릇채비:` 항목에서 `=` 사용은 금지(오류 권장: `E-EQUAL-IN-GUREUT`).
- `그릇채비:` 항목의 `<-`는 “첫 넣기(초기 대입)”로 취급한다.
  - 이후 일반 문장에서도 같은 그릇에 `<-`로 얼마든지 다시 넣을 수 있다.







### [GUREUT-DECL-03] `채비:` — 변수/붙박이 혼합 선언 입력 설탕 — SHOULD

목적:
- 예제/교육 문서에서 “선언 머릿말을 2개(그릇채비/붙박이마련) 외우는 부담”을 줄인다.
- 한 블록에서 `=`(붙박이)와 `<-`(첫 넣기)로 구분해 선언을 한눈에 보이게 한다.

규칙:
- `채비:`는 **입력 설탕**이다.
  - 정본 출력(포매터/정본화기)은 `그릇채비:` + `붙박이마련:` 두 블록으로 **분해하여 저장**한다.
- `채비:` 블록 안 항목 해석:
  - `이름:형.` 또는 `이름:형 <- 식.`  → **그릇(변수) 채비** 항목(= `그릇채비:`)
  - `이름:형 = 식.` → **붙박이(상수) 마련** 항목(= `붙박이마련:`)

금지(오류 권장/강제):
- 같은 이름이 `채비:` 블록 내부에서 **변수/붙박이로 중복 선언**되면 오류(FATAL 권장): `E-DECL-DUP-IN-CHAEVI`.
- `이름:형 =` 처럼 알맹이 없는 붙박이는 오류(FATAL). *(붙박이마련 규칙과 동일)*

예(입력 설탕):
```ddn
채비: {
  점수:수.
  중력:수 <- 9.8.
  원주율:수 = 3.141592.
}.
```

정본화(출력) 예:
```ddn
그릇채비: {
  점수:수.
  중력:수 <- 9.8.
}.

붙박이마련: {
  원주율:수 = 3.141592.
}.
```

스코프:
- `채비:`의 스코프/동작은 `그릇채비`/`붙박이마련`과 동일하게, 등장 위치(전역/지역)를 따른다.
- `#바탕숨김`의 “미리 등록된 바탕칸” 판정에서는, `채비:`에서 선언된 이름(변수/붙박이 모두)을 **등록된 것으로 취급**한다(권장).

### [EQUAL-DEF-01] `=`는 “정의(Definition)” 전용 — MUST

정의:
- `=`는 **정의(Definition)** 에서만 사용한다.
- “정의”란, 해당 이름의 의미/알맹이가 **그 자리에서 확정**되며, 이후에 `←`로 바뀌지 않는 문맥을 말한다.

허용되는 대표 문맥(정본):
1) 셈씨/움직씨 정의:
```ddn
(가:수~를, 나:수~에)더:수:셈씨 = { 더 <- 가 + 나 }.
```

2) 붙박이 마련(상수 정의 + 초기 알맹이 포함):
```ddn
붙박이마련: {
  원주율:수 = 3.141592.
}.
```

금지:
- 위 “정의 문맥”이 아닌 곳에서 `=` 사용은 금지(오류 권장: `E-EQUAL-NOT-DEF`).
- 특히 `그릇채비:`(변수 채비) 항목에서는 `=`를 쓰지 않는다. (변수는 정의가 아니라 채비/대입의 대상)


### [ASSIGN-ARROW-01] `<-`는 “대입(Assignment)” 전용 — MUST

정의:
- `<-`는 **대입(Assignment)** 에서만 사용한다.
- 대입은 “이미 존재하는 그릇(변수) 또는 결과칸에 알맹이를 넣거나 바꾸는 행위”이다.


추가(입력 설탕):
- 입력에서는 `값 -> 대상`(우향 대입)을 허용할 수 있다. 이는 `대상 <- 값`과 동치이다. (DR-154)
- 정본 출력(canon/골든)은 항상 `<-`만 사용한다. (대입용 `->` 출력 금지)
예(정본):
```ddn
점수 <- 점수 + 1.
더 <- 가 + 나.          // 셈씨 결과칸(결과 이름) 대입
```

금지:
- 정의 문맥(셈씨/움직씨 헤더, 붙박이마련 항목)에서 `<-` 사용은 금지(오류 권장).




### [ASSIGN-ARROW-RIGHT-01] `->` 우향 대입은 “입력 설탕”, 정본은 `<-` — MUST

정의:
- `식 -> 자리.` 는 **우향 대입**이다. (Source → Destination)
- 의미는 항상 `자리 <- 식.` 과 동일하다.
- 따라서 정본화기는 `A -> B.` 를 **반드시** `B <- A.` 로 정본화한다.

파싱/의미 규칙(MUST):
- `->` 우항은 **L-Value(대입 가능한 자리)** 여야 한다.
  - 예: 이름(그릇), 결과칸(셈씨 결과 이름), 접근점(`바탕.중력`), 인덱싱 설탕(AGE1+) 등
  - 비예: `1+2 -> 3` (오류)
- 결합/우선순위:
  - 대입은 문장 내 **가장 낮은 우선순위**를 가진다.
  - 즉, `a + 1 -> b.` 는 `(a + 1) -> b.` 로 해석한다.

예(입력 허용):
```ddn
점수 + 1 -> 점수.
입력 |>> 더하기하고 제곱하기 -> 결과.
```

예(정본 출력):
```ddn
점수 <- 점수 + 1.
결과 <- 입력 |>> 더하기하고 제곱하기.
```

충돌 회피(MUST):
- `->`는 타입 시그니처(예: `T -> U`)에도 쓰이므로, **정본 출력에서는 대입용 `->`를 사용하지 않는다.**
- 말결/통신 화살표는 `~~>`로 예약한다. (DR-156, 문맥 판정 금지)




### [SIGNAL-ARROW-RESERVE-01] `~~>` 말결/통신 화살표 토큰 예약 — MUST (Gate0)

정의:
- `~~>`는 말결/통신(에이전트 메시지, 사건(Event) 방출 등) 표현을 위한 **예약 토큰**이다. *(DR-156)*
- `~~>`는 **대입이 아니다.** `->`/`<-`와 의미적으로 연결하지 않는다. (문맥 판정 금지)

Gate0 규칙(MUST):
- Gate0는 `~~>`의 의미론/런타임을 아직 제공하지 않는다.
- 따라서 `~~>`가 등장하면 즉시 실패한다: `E_SIGNAL_ARROW_UNSUPPORTED` (FATAL)

비고:
- 의미론/프로토콜은 관측(Observation)·거울(리플레이)·샘 입력 기록과 함께 후속으로 확정한다.

### [ROOT-DECL-01] 바탕칸 선언(등록) — SHOULD

목적:
- 바탕(루트 상태)에 존재 가능한 칸(필드) 목록을 **파일 단위로 명시**하여, `#바탕숨김`에서의 안전한 생략을 가능하게 한다.

형태(정본 예):
```ddn
그릇채비: {
  점수:수.
  중력:수.
}.
```

의미:
- 위 선언은 “이 파일(또는 이 모듈)에서 바탕에 접근 가능한 칸”의 최소 집합을 정의한다.
- `#바탕숨김` 모드에서 `점수 <- ...` 같은 쓰기가 가능해진다.

추가 규칙(권장 정본화):
- 선언 키워드 정본은 `그릇채비:`이다. (의미: “바탕 칸 목록/표”)
- 레거시 별칭으로 `바탕칸:`(레거시)을 입력에서 허용할 수 있다.
- 정본 출력(포매터)은 `그릇채비:`로 수렴한다.

비고:
- `바탕.칸만들기(…)` 같은 “점 표기 + 괄호 호출”은 우리 호출 규칙(인자 앞, `~기/~하기` 꼬리)과 맞지 않으므로 **정본 문법으로 채택하지 않는다.**



### 4.3 문장 경계 (Statement Boundary) — MUST

| 상황 | 규칙 |
|------|------|
| **기본** | **줄바꿈(Newline)**이 문장의 끝. 세미콜론 사용 안 함 |
| **명시적 종결** | 한 줄에 여러 문장을 쓸 때는 마침표 `.` 사용 |
| **이어쓰기** | 줄 끝이 연산자(`+`, `-`), 콤마(`,`), 여는 괄호(`(`, `{`, `[`)면 다음 줄로 이어짐 |
| **엄격 모드** | 구현체 옵션(MAY)으로 "항상 `.` 강제" 가능 (CI/린트 용도) |

#### 4.3.1 점(`.`)의 2중 역할(접근 vs 종결) — MUST (Gate0)

또니랑에서 `.`은 **문장 종결 표지**이면서 동시에 **경로/속성 접근 표지**로도 쓰입니다.  
Gate0는 아래 규칙으로 **결정적으로** 해석합니다.

- **접근점(AccessDot)**: 점 뒤에 **식별자(이름씨)**가 즉시 이어지면, 이는 **접근**입니다.  
  - 예: `바탕.중력`, `샘.마우스.위치`, `임자.위치`
- **종결점(TermDot)**: 점 뒤에 식별자가 이어지지 않으면, 이는 **문장 종결**입니다.  
  - 예: `먹기.`, `{ ... }하고.`, `x <- 1.`

**렉서(문자 수준) 결정 규칙**
- `.`를 읽은 직후, 다음 글자가 “식별자 시작 글자(한글/영문/`_`)”이면 **AccessDot**으로 토큰화합니다.
- 그 외에는 **TermDot**으로 토큰화합니다. (문장 종결)

**금지**
- AccessDot은 “앞뒤 공백”이 있으면 성립하지 않습니다. (공백이 개입하면 TermDot으로 봅니다)

- 예: `바탕. 중력` 은 `바탕.` 로 문장이 끝난 것으로 취급되어 이후 토큰에서 파싱 오류가 발생합니다.  
  fix-it: 공백 제거 → `바탕.중력`
- AccessDot이 필요한 자리에 TermDot을 쓰면 문법 오류입니다.



### [MAP-DOT-READ-01] `짝맞춤` 점(`.`) 접근 Step A(읽기) — MUST (Gate0)

목적:
- `바탕.중력` 같은 “경로 접근”과 같은 모양을 이용해,
  `짝맞춤`(dict/map)에서도 `m.열쇠`로 **읽기**를 할 수 있게 한다. *(DR-155)*
- 그래프/보개/표에서 `("x",..., "y",...) 짝맞춤.` 같은 구조를 다룰 때 배관을 줄인다.

정의(MUST):
- `m.열쇠`는 `짝맞춤`의 **열쇠 조회(읽기)** 이다.
- 이 규칙은 `m`이 `(글 V)짝맞춤`인 경우에만 적용한다. *(점 접근으로는 글(문자열) 열쇠만 지원)*
- 조회 열쇠의 정본은 **식별자 텍스트 그대로**이다.  
  예: `m.에너지`는 글 열쇠 `"에너지"` 조회와 동치.
- 결과는 **값(Value)** 이다. Gate0에서 `m.열쇠`는 L-Value가 아니다. *(쓰기/참조는 Step B/C 이월)*

실패(MUST):
- 열쇠가 없으면 즉시 실패한다: `E_MAP_DOT_KEY_MISSING` (FATAL)

예(읽기):
```ddn
상자 <- ("x", 1, "y", 2) 짝맞춤.
x <- 상자.x.
y <- 상자.y.
```

금지(Gate0):
```text
상자.x <- 3.      // Step B/C (쓰기) 이월
```

### 4.4 예약어 (Keywords)

다음 단어들은 식별자로 사용할 수 없습니다:

```
이름씨, 움직씨, 셈씨, 이음씨, 일묶음씨, 흐름씨, 흐름, 샘, 일때씨, 어찌씨, 고름씨, 맞물림씨, 관계씨
일때, 올때, 바뀔때, 마다, 수, 글, 참거짓, 없음, 값꾸러미, 차림, 모음, 짝맞춤
이면, 아니면, 따라, 되풀이, 반복, 되돌림, 반환, D-STRICT, D-FAST, 마디, 톺아보기, 감사, 늘지켜보고
나, 그것, 저마다, 하나하나
그리고, 또는, 아님
그릇채비
붙박이마련
채비
```

> LEGACY 입력(정본화됨): `목록` → `차림`, `관계씨` → `맞물림씨`, `반복` → `되풀이`, `반환` → `되돌림`, `감사` → `톺아보기`


---

## 5. 타입 시스템

### 5.1 기본 알 타입 (Primitives)

또니랑은 "동적 스크립트처럼 보이지만, 실제로는 정적(Static) 비용 모델을 갖는 언어"를 목표로 합니다.
기본 타입은 컴파일 타임에 크기/표현이 확정됩니다.

| 타입 | 설명 |
|------|------|
| **글** | UTF-8 문자열. 불변(Immutable), 내부 인터닝 가능 |
| **참거짓** | `참` \| `거짓` |
| **없음** | 반환값이 없는 경우, 또는 "값 없음" 표현 |
| **수** | 숫자 패밀리. 수치 정책에 따라 구체 타입 결정 |

### 5.1.1 복합 알 타입 (Composites)

아래 타입 이름은 SSOT에서 **정본 용어로 예약**합니다.  
(AGE0 구현은 *파서/정본화/진단*이 이 타입 표기를 다룰 수 있으면 충분하며, 실제 컨테이너 구현은 AGE1+로 미룰 수 있습니다.)

| 타입 | 별칭 | 설명 | 결정성 노트 |
|------|------|------|-------------|
| **값꾸러미** | tuple/record | 여러 값을 **고정 길이**로 묶은 값. `(수 글 참거짓)값꾸러미` 처럼 쓸 수 있음 | 요소 순서가 곧 정본 |
| **차림** | list/sequence | 값들의 **순서 있는** 차림. `(T)차림` | 순서가 곧 정본 |
| **모음** | set | 값들의 **중복 없는** 모아둠. `(T)모음` | 정본 반복 순서는 “정본화된 값의 바이트열” 기준 오름차순 |
| **짝맞춤** | dict/map | `열쇠→값` 짝의 모음. `(K V)짝맞춤` | 정본 반복 순서는 “정본화된 열쇠” 기준 오름차순 |
| **흐름** | stream | 최근 N개를 보존하는 **상태형 링버퍼**. `(T)흐름(N)` | 정본 반복/직렬화 순서는 “오래된→새로운” 고정, 용량 N은 규격에 포함 |

> 주의: `모음/짝맞춤`은 “저장 순서/해시”에 기대면 결정성이 깨질 수 있으므로, **반복(순회) 순서를 규격으로 고정**합니다.





### 5.1.2 흐름(Stream) 값 타입 — SHOULD (AGE1+)

`흐름(N)`은 최근 N개의 값을 보존하는 **상태형 링버퍼** 값 타입이다. *(DR-150)*

- 용도: 시계열(그래프), 최근 값 창(window), 관측(Observation) 히스토리
- 직렬화/정본 순서: **오래된 값 → 새로운 값**
- 결정성:
  - 흐름의 내용(버퍼)은 “세계 상태”이므로 state_hash에 포함된다(단, `보개_*` 뷰 키는 제외; DR-152).

표면 규범(권장, v1):
- 선언: `이름:흐름(N).`
- 초기화(빈 버퍼): `이름:흐름(N) <- () 차림.`
- 갱신(push): `이름 <- 값.`
- 리셋/일괄 지정: `이름 <- (값들)차림.` *(길이가 N을 넘으면 오래된 것부터 버린다)*

> 주의: 이 규칙은 **값 타입 `흐름`**에만 적용된다. 씨앗 `흐름씨`의 `<<-`와 혼동하지 않는다.

### 5.2 수(숫자) 구체 타입

| 타입명 | 비트폭 | 개념 | 결정성 메모 |
|--------|-------:|------|-------------|
| **정수32** | 32 | signed int | 빠름. 플랫폼 차이 거의 없음 |
| **정수64** | 64 | signed int | 기본 정수형 권장 |
| **부호없는32** | 32 | unsigned int | 해시/비트연산에 유용 |
| **부호없는64** | 64 | unsigned int | 난수 시드/마디 번호에 적합 |
| **실수32** | 32 | IEEE-754 float | **크로스 플랫폼 bit-exact 보장 어려움** |
| **실수64** | 64 | IEEE-754 double | D-STRICT에선 사용 금지 |
| **고정64** | 64 | fixed-point Q32.32 | **결정성 확보 용이**. 연산은 정수 기반 |


#### 5.2.1 확장 수치 타입(표준 가지) — SHOULD (AGE2+)

Gate0 코어는 `Fixed64(Q32.32)` 중심으로 최소화한다. 다만 **수학적 엄밀성**(조합/정수론/정확한 분수)을 위해, 아래 타입을 **표준 가지(STDLIB)** 로 제공하는 것을 권장한다.

> 표준 가지(STDLIB)는 코어에 고정 내장하지 않고, **gaji 패키지 단위로 분할**하여 제공한다. (DR-089)
> 정본 패키지: `gaji/std_text`, `gaji/std_charim`, `gaji/std_math`, `gaji/std_map`, `gaji/std_logic`.

| 타입명 | 별칭 | 개념 | 정본/결정성 규칙 |
|--------|------|------|------------------|
| **큰정수** | BigInt | 임의 정밀도 정수 | 직렬화는 “부호 + 리틀엔디언 limb(2^32) + 무선행0” 정규형 MUST |
| **유리수** | Rational, BigRational | (큰정수/큰정수) 분수 | `gcd` 기약분수 + 분모>0 + 0은 0/1 정규형 MUST |

- 표준 위치(권장): `수학.큰정수`, `수학.유리수`

**규칙:**
- 큰정수/유리수는 **표준 가지**에 속한다. 언어 코어 문법을 늘리지 않는다. (MUST)
- 연산 의미론은 수학적 정수/유리수와 동일하다. 오버플로는 없다. (MUST)
  - 단, 구현체가 정한 메모리/시간 한도를 넘으면 `diag`를 남기고 중단할 수 있다. (MAY)
- Fixed64/정수64 ↔ 유리수 변환은 **명시적 함수**로만 허용한다. (MUST)
  - 반올림/절삭/오버플로 규칙은 표준으로 고정한다. (MUST)
- `det_tier=D-STRICT`에서도 큰정수/유리수는 결정적으로 동작해야 한다. (MUST)
  - 단, “물리 틱(마디) 루프의 num_backend”는 여전히 `FIXED64_Q32_32`가 정본이다. (MUST)


### 5.3 수치 정책(det_tier) + 추적 정책(trace_tier) — MUST

결정성은 “수치 정책(det_tier)”과 “추적 정책(trace_tier)”이 **직교(orthogonal)** 합니다.

#### 5.3.1 det_tier (수치 정책)

| det_tier | 허용 num_backend | 보장 |
|----------|------------------|------|
| **D-STRICT** | FIXED64_Q32_32 | **크로스플랫폼 Bit-exact** |
| **D-FAST** | NATIVE_FLOAT64 *(또는 구현체 지정)* | 동일 HW/OS/빌드 내 재현 목표 |
| **D-ULTRA** | NATIVE_FLOAT32/SIMD *(v14+)* | 성능 우선 (결정성 약화 가능) |

> **중요:** `D-STRICT`에서 `NATIVE_FLOAT64`는 **금지**한다 — MUST NOT

#### 5.3.2 trace_tier (추적/로깅 정책)

| trace_tier | 목적 | 기록 범위 |
|------------|------|----------|
| **T-OFF** | 최소 오버헤드 | 해시/체크포인트만 |
| **T-PATCH** | 디버그 기본 | 커밋 덧댐(변경분) + 최소 메타 |
| **T-alrim** | 원인 추적 | 덧댐 + 트리거/알림(알리기/흐름) 경로 |
| **T-FULL** | 완전 감사/학습 | 덧댐 + 알림 + (선택) 전/후 스냅샷 |

#### 5.3.3 프리셋(D-LOG) — MAY

- **D-LOG**는 det_tier가 아니라 **프리셋 이름**입니다.  
  `D-LOG = { det_tier=D-STRICT, trace_tier=T-FULL }`

#### 5.3.4 실행 중 전환 금지 — MUST

- det_tier/trace_tier는 **세계(Realm) 시작 시 고정**되며 실행 중 변경할 수 없습니다 — MUST NOT

### 5.4 FIXED64_Q32_32 정의

```
저장: signed 64-bit 정수 raw
해석: value = raw / 2^32
범위: 약 ±2^31 (±2,147,483,648) 정수부 + 소수 32비트
반올림: 은행가 반올림(Nearest-even)
```

### 5.5 리터럴과 승격 규칙 — MUST

#### 5.5.1 정수 리터럴

```ddn
42         // 기본: 정수64 (또는 월드 설정에 따라 정수32)
42i32      // 명시: 정수32
42u64      // 명시: 부호없는64
```

#### 5.5.2 실수 리터럴

```ddn
3.14       // 기본: 수치 정책에 따라 고정64 또는 실수64
3.14f32    // 명시: 실수32 (D-STRICT에서 경고)
3.14fixed  // 명시: 고정64
```

#### 5.5.3 승격 규칙

산술 연산 시 다음 우선순위로 승격:

```
정수32 < 정수64 < 부호없는32 < 부호없는64 < 고정64 < 실수32 < 실수64
```

**규칙:**
- 정수 + 실수 → 실수
- 정수 + 고정 → 고정
- 고정 + 실수 → 컴파일 경고 (D-STRICT에서 에러)

### 5.6 이름씨 (Struct) 정의

```ddn
(이름:글, HP:수=100) 몬스터:이름씨 = { ... }
```


**규칙(오해 방지) — MUST:**

- `이름씨`의 **필드 선언**(예: `이름:글`, `HP:수=100`)은 반드시 **정의 머리의 `()` 안에만** 둔다.
- `{}`는 **토막(본문/스코프)** 이다. `{}` 안에 `이름:타입`을 늘어놓아 "구조(레코드)를 만든 것처럼" 쓰지 않는다.
  - `{}` 안에는 보통 (1) 관련 씨앗(움직씨/셈씨/심판씨 등) 정의, (2) 지킴이/계약 토막, (3) 실행 로직을 둔다.

금지 예:

```ddn
몬스터:이름씨 = {
  이름:글,
  HP:수=100
}
```

올바른 예:

```ddn
(이름:글, HP:수=100) 몬스터:이름씨 = { ... }
```

**연결된 움직씨/셈씨(메서드) — SHOULD:**

- `이름씨` 본문 `{}` 안에는 해당 타입과 "자연스럽게 붙는" 움직씨/셈씨를 함께 정의할 수 있다.
  - 예: `(몬스터~을~를) 공격:움직씨`, `(몬스터~의) 방어력:셈씨`

> 참고(권고): `{}`는 사전/레코드 리터럴이 아니다. 레코드 값은 `(필드:값, ...)` 형태로 만든다. 예: `(이름:"슬라임", HP:50)`

**메모리 구조:**
- `이름씨`의 인스턴스는 ECS의 **엔티티(Entity)**이자 **컴포넌트(Component)**
- 동일 구성의 엔티티들은 **아키타입(Archetype)**으로 분류, **청크(Chunk)** 단위 연속 메모리
- 가능한 경우 **SoA (Structure of Arrays)** 형태로 필드별 분리 저장

#### ECS 메모리 레이아웃 상세

**아키타입 (Archetype):**
- 동일한 컴포넌트 집합을 가진 엔티티들의 그룹
- 예: `(Position, Velocity)` vs `(Position, Velocity, Health)`는 별도 아키타입

**청크 (Chunk):**
- 각 아키타입은 16KB 청크 단위로 할당
- 하나의 청크에 동일 아키타입 엔티티들이 연속 배치
- 캐시 지역성(Cache Locality) 최적화

**SoA vs AoS:**
```
// AoS (Array of Structures) - 기본
struct Entity { x, y, vx, vy, hp };
Entity×1000;

// SoA (Structure of Arrays) - 최적화 옵션
struct Archetype {
    x×1000, y×1000,      // Position 컴포넌트
    vx×1000, vy×1000,    // Velocity 컴포넌트
    hp×1000               // Health 컴포넌트
}
```

**권고:** 시스템(System)이 Position만 읽는 경우 SoA가 SIMD 친화적



#### 5.6.4 자기 참조 `나` — MUST

`나`는 “현재 객체(인스턴스)”를 가리키는 **특별 식별자**입니다.  
(다른 언어의 `this`, `self`와 동일한 역할)

### 규칙

- `나`는 `이름씨`(엔티티/객체 타입) 본문 블록 안에서 자동으로 바인딩된다. (MUST)
- `나`의 타입은 해당 `이름씨`다. (MUST)
- `나`는 **읽기 전용**이며 재바인딩할 수 없다. (MUST)
- `나`는 값으로 전달/저장(토막 캡처 포함)할 수 있다. (MUST)
- `나`는 `이름씨` 본문 밖에서는 존재하지 않는다. (MUST)  
  밖에서 ‘자기’를 표현하려면 인자로 명시해야 한다.

### 예시

```ddn
(속도:수 = 1.0) 걷기:움직씨 = {
  // 나 = 이 엔티티(인스턴스)
  나.위치 <- 나.위치 + (속도, 0).
}.

(속도:수 = 3.0) 달리기:움직씨 = {
  나 걷기(속도=속도).
}.
```

## 5.7 값꾸러미 (Value Bundle)

여러 값을 하나로 묶어 다루는 1급 값.

```ddn
(2, 2, 수) 값꾸러미  // 2x2 행렬 생성자 타입
```

**구현:**
- 힙 할당이지만 값 의미론(Value Semantics) 유지
- **COW (Copy-on-Write):** `RC == 1`이면 In-place 업데이트, `RC > 1`이면 깊은 복사

### 5.8 묶음씨(레코드/구조체) — MUST

`묶음씨`는 **이름이 있는 값 타입(레코드/구조체)**입니다.  
목표는 “수학/물리/경제 시뮬레이션에서 자주 쓰는 좌표·벡터·상태” 같은 자료구조를 **가볍고 명확하게** 표현하는 것입니다.

### 5.8.1 정의(선언)

필드(이름:타입) 목록을 선언해 묶음 타입을 만든다.

```ddn
(x:수, y:수) 위치:묶음씨 = { }.
(vx:수, vy:수) 속도:묶음씨 = { }.
```

규칙:

- 필드 이름은 핀 이름과 동일한 방식으로 쓰인다. (MUST)
- 필드 순서는 ABI/정본/해시의 일부다. (MUST)
- 본문 `{ }`는 비워 둘 수 있다. (MUST)  
  (향후 확장: 생성자 계약/상수/관련 씨앗을 배치하는 네임스페이스로도 사용 가능)

### 5.8.2 값 만들기(구성/형변환)

`값꾸러미`(5.7)의 레코드 형식을 **묶음씨로 “태우는”** 표기를 제공한다.

```ddn
p <- (x=1, y=2) 위치.
v <- (vx=3, vy=4) 속도.
```

- `(x=1, y=2)`는 레코드 값꾸러미이고,
- 뒤의 `위치`는 “이 레코드를 `위치` 타입으로 확정”한다. (MUST)

검사:

- 필드 이름/개수/타입이 맞지 않으면 오류. (MUST)
- 필드 값이 생략된 경우:
  - 기본값이 정의돼 있으면 채운다. (MAY)
  - 아니면 오류. (MUST)

### 5.8.3 필드 접근

묶음 값의 필드는 점 접근으로 읽는다.

```ddn
x0 <- p.x.
y0 <- p.y.
```

### 5.8.4 패턴 분해(선택)

묶음씨 값은 `~에 따라`(매치)에서 분해할 수 있다. (SHOULD)

```ddn
p에 따라 {
  위치(x, y)이면 x + y
  아니면 0
}.
```

### 5.9 튜플 정규화 — MUST

단일 원소 튜플 `(A)`와 스칼라 `A`는 컴파일러 내부 AST에서 **동일하게 취급**됩니다.

**이유:** 제네릭이나 함수 인자 처리 시 `f(x)`와 `f((x))`를 구분하지 않음으로써 타입 시스템의 복잡도를 낮춤.

**예외:** 명시적 튜플 생성 시 `(x, )`처럼 trailing comma 사용 시 튜플로 취급 (MAY)

### 5.10 고름씨 (Tag Union) 정의 — MUST

`고름씨`는 **유한(닫힌) 태그 집합**(합 타입)입니다.  
`~에 따라`의 분기 대상이 될 수 있도록, 컴파일 타임에 **모든 변형(variant)과 필드 타입**이 확정되어야 합니다.

#### 5.10.1 정의 문법 (MUST)

```ddn
행동:고름씨 = {
  #대기
  #이동(방향:벡터, 속도:수)
  #공격(대상:임자, 피해:수)
}.
```

- 변형 이름은 항상 `#원자` 형태여야 합니다. (`#대기`, `#공격` …)
- 괄호 안은 **필드(이름:타입)** 목록이며, **정의된 순서가 곧 ABI(저장/전송/해시) 순서**입니다.
- 필드에 `=기본값`을 줄 수 있습니다. (생성 시 생략 가능)

#### 5.10.2 생성 문법 (MUST)

- 필드 없는 태그: `#대기`
- 필드 있는 태그(정의 순서대로 **위치 인자**): `#공격(주인공, 10)`
- 필드 있는 태그(**이름 인자**): `#공격(대상=주인공, 피해=10)`

문법(요약):
- `#태그(값1, 값2, ...)`  (위치 인자)
- `#태그(필드1=값1, 필드2=값2, ...)`  (이름 인자)
- **혼합 금지**: `#태그(값, 필드=값)` 형태는 금지.

> Gate0(기준)에서는 **이름 인자(예: `대상=...`)도 실제로 허용**합니다.  
> 규칙: **혼합 금지**(위치+이름), 이름 인자는 **정의된 ABI 순서로 정본화(재배치)** 되며 전송/해시는 항상 ABI 순서를 따릅니다.  
> (IDE는 위치 인자 입력 시에도 필드명을 Ghost Text로 표시하는 것을 권장)

#### 5.10.3 전역 유일성 규칙 (v15, MUST)

v15에서는 `#태그` 변형 이름이 프로그램 전체에서 **전역 유일**해야 합니다.  
(서로 다른 고름씨에서 같은 `#대기`를 정의하면 컴파일 에러)

- 목적: 태그 리터럴/패턴을 **모호성 없이** AOT로 숫자화하고 점프 테이블을 사전 계산하기 위함.

#### 5.10.4 정본화 규칙 (MUST)

- 정본화기는 `고름씨` 정의 내부의 변형 목록을 **정의 순서 그대로 유지**해야 합니다. (순서 변경 금지)
- 컴파일러는 각 변형에 대해 `(고름씨ID, 변형Index)`를 부여하고, 런타임 표현은 이 정수쌍을 사용해야 합니다.
#### 5.10.5 표준 색 `#색(...)` 정본화 — SHOULD (Gate0)

> 목적: 보개/그래프/UI에서 “색”을 사람이 읽기 좋은 입력으로 쓰되, 정본/해시/직렬화는 항상 **결정적 표현**으로 고정한다. *(DR-054)*

**형태(권장):**
- `#색("#rrggbbaa")`  (hex8, 소문자)
- `#색("white")`      (이름 → hex8로 정본화, 선택)

**[COLOR-LIT-01] (MUST)**  
색의 정본 문자열은 항상 `#rrggbbaa`(hex8, 소문자)이다.  
- `#rrggbb` 입력은 `aa=ff`를 붙여 `#rrggbbff`로 정본화한다.
- 대문자 hex는 소문자로 정본화한다.

**[COLOR-LIT-02] (MUST)**  
색 문자열이 `#`로 시작하면 “hex 색”으로 해석한다.  
- 길이 7(`#rrggbb`) 또는 9(`#rrggbbaa`)만 허용한다.
- 그 외 길이/문자 포함 시 컴파일 오류.

**[COLOR-LIT-03] (SHOULD)**  
색 문자열이 `#`로 시작하지 않으면 “이름 색”으로 해석할 수 있다.  
- 해석은 **ColorNamePack/CSS4/V1**(표준 색 이름 팩)을 사용한다.
- 영문 CSS4 이름 + (선택) 한국어 별칭을 지원한다.
- 이름 해석을 지원하지 않는 구현은 Gate0에서 **hex만 허용**해도 된다. (Gate0 최소)

**[COLOR-LIT-04] (NOTE)**  
`currentColor`처럼 문맥 의존 키워드는 “이름 팩”에 포함하지 않는다.  
- 이런 값은 스타일 시스템/상속 규칙이 확정된 뒤 별도 태그/필드로 다룬다.





---

## 6. 함수, 연산, 표현식

### 6.1 함수 정의

**수식어 선행:** 인자 정의가 함수 이름 앞에 옵니다.

```ddn
(x:수, y:수) 더하기:셈씨 = { ... }
```

**반환:**
- `함수명 <- 값.` 문법으로 명시적 반환값 설정
- 일묶음씨 블록의 마지막 식 값은 암시적 반환

### 6.2 이음씨 (중위연산) 정의

이음씨는 `A <연산자> B` 형태의 **중위 연산**을 정의합니다.  
이음씨 정의는 항상 다음을 함께 명시합니다.

- 좌항 이름/타입
- 연산자 토큰(기호 또는 말)
- 반환 타입
- 메타타입 `이음씨`
- (선택) 우선순위

#### 6.2.1 정의 헤더 공통 문법 — MUST

정본 헤더(요약):

```text
[우선순위(N)] <좌이름>:<좌타입> <연산자>:<반환타입>:이음씨 <우이름>:<우타입> = { ... }.
```

- `:<반환타입>:이음씨`의 **콜론 연쇄는 붙여 씁니다.**  
  (포매터는 `: 수 : 이음씨` 같은 공백을 제거합니다.)
- `우선순위(N)`는 **정의문에서만** 쓸 수 있습니다. (표현식에 끼워 넣지 않습니다.)
- 정의 바디는 토막 `{ ... }`이며, 반환은 `이음씨명 <- 값.` 또는 마지막 식 값입니다.

#### 6.2.2 말 이음씨 (기호 없는 중위연산) — MUST

말 이음씨는 연산자 자리에 **식별자(한글/영문 이름)** 를 씁니다.

```ddn
A:수 비교:참거짓:이음씨 B:수 = {
    비교 <- A < B.
}.
```

- 사용: `3 비교 5`  *(비교가 스코프에 이음씨로 정의되어 있을 때)*
- 말 이음씨는 “입력 다리(브리지)”가 아니라 **언어 자체 기능**입니다.
- 같은 스코프에서 `비교`를 이음씨와 다른 씨앗(셈씨/움직씨/값)으로 중복 정의하면 **모호성 오류**입니다. (MUST)

#### 6.2.3 기호 이음씨 (확장 이음기호) — MUST

기호 이음씨는 연산자 자리에 **이음기호(OperatorSymbol)** 를 씁니다.

```ddn
A:수 +:수:이음씨 B:수 = {
    더하기 <- A + B.
}.
```

**(선택) 기호 이음씨에 말별칭 달기 — MAY (정의 헤더 전용)**

```ddn
A:수 +~더하기:수:이음씨 B:수 = {
    더하기 <- A + B.
}.
```

- `+~더하기` 표기는 **정의 헤더에서만** 허용합니다.
- 이 표기는 의미를 바꾸지 않으며, 정본화기는 별칭을 메타로만 기록하고  
  정본 출력에서는 `A:수 +:수:이음씨 B:수`처럼 `~별칭`을 제거합니다. (MUST)
- 별칭이 등록돼 있으면, 표현식에서도 말 이음씨로 사용할 수 있습니다: `3 더하기 5`  
  *(입력 허용, 정본 표기는 `3 + 5` 권장)*

#### 6.2.4 확장 이음기호 집합 — MUST (렉서)

또니랑은 결정성을 위해 “아무 기호나”를 연산자로 허용하지 않습니다.  
대신 **고정된 후보 문자 집합(EXT_OPCHAR)** 을 제공하고, 그 안에서 1~3글자 조합으로 “빈 기호(정의 전에는 의미 없음)”를 만들 수 있게 합니다.

- **길이:** 1~3 글자(유니코드 코드포인트 기준) — MUST
- **스캔:** 렉서는 **최장 일치(가장 긴 토큰 우선)** 로 토큰을 만듭니다. — MUST
- **사용:** 이 기호는 해당 스코프(또는 모듬)에서 이음씨로 정의된 경우에만 의미가 있습니다. — MUST

**EXT_OPCHAR (정본 후보 문자 집합)**

- 수학/공학: `· × ÷ ⊙ ⊗ ⊕ ⊖ ⊘ ∘ ∥ ∩ ∪`
- 그래프/AI/일반: `◇ ◆ ○ ● □ ■ ☆ ★ ⟪ ⟫`
- 장난감/경제(선택): `♤ ♡ ♧ ♢ € £ ¥ ¤ ▪ ° ¡ ¿`

> **금지(문서 메타 충돌):** `〈〉《》`는 문서 자리표시자 전용이므로 코드 토큰으로 금지합니다. (MUST)

**예약 토큰(발췌) — MUST NOT**

- 주석: `//`, `/*`, `*/`
- 대입/흐름대입: `<-`, `<<-`
- 비교/논리 내장: `<=`, `>=`, `==`, `!=`, `&&`, `||`
- 시프트: `<<`, `>>`

> 구현 메모(비규범): `▪︎`처럼 variation selector가 섞인 입력은 정본화기에서 `▪`로 정규화하거나 오류로 처리하는 것을 권장합니다.

#### 6.2.5 사용자 정의 이음씨 우선순위 — MUST

- 기본 우선순위: 5 (곱셈급)
- 명시: `우선순위(8)` 처럼 정의 헤더 **앞**에 둡니다.
- 범위: `3..13` (1~2는 접근/호출 전용이므로 금지) — MUST

예)

```ddn
우선순위(8) A:수 ◇:참거짓:이음씨 B:수 = {
    ◇ <- A < B.
}.
```

#### 6.2.6 확장 이음기호 추천 기본 10 (물리/수학/AI) — SHOULD

| 기호 | 권장 우선순위 | 권장 말별칭 | 대표 사용 예 |
|---|---:|---|---|
| `·` | 5 | 내적 | `힘 · 변위` |
| `×` | 5 | 외적 | `각속도 × 위치` |
| `⊙` | 5 | 원소곱 | `가중치 ⊙ 입력` |
| `⊗` | 5 | 텐서곱 | `A ⊗ B` |
| `∘` | 4 | 합성 | `f ∘ g` |
| `⊕` | 6 | 합치기 | `정책 ⊕ 힌트` |
| `∪` | 6 | 합집합 | `A ∪ B` |
| `∩` | 6 | 교집합 | `A ∩ B` |
| `◇` | 6 | 연결 | `노드1 ◇ 노드2` |
| `☆` | 6 | 강화 | `행동 ☆ 보상` |

> 위 표는 “기본 세트 추천”일 뿐이며, 실제 의미는 각 이음씨 정의가 결정합니다.

**다중 디스덧댐:** 좌항/우항의 타입 조합에 따라 다른 구현체 호출. 컴파일 타임 결정 권장.

### 6.3 표현식 우선순위 (높은 순위부터) — MUST

| 순위 | 연산자 | 결합성 | 설명 |
|:---:|--------|:------:|------|
| 1 | `.` | 좌 | 멤버 접근 |
| 2 | `( )` | 좌 | 함수 호출, 그룹 |
| 3 | `^` | **우** | 거듭제곱 |
| 4 | `-`, `!` | 우 | 단항 부호, 부정 |
| 5 | `*`, `/`, `%` | 좌 | 곱셈, 나눗셈, 나머지 |
| 6 | `+`, `-` | 좌 | 덧셈, 뺄셈 |
| 7 | `<<`, `>>` | 좌 | 비트 시프트 |
| 8 | `<`, `>`, `<=`, `>=` | 좌 | 비교 |
| 9 | `==`, `!=` | 좌 | 동등성 |
| 10 | `&` | 좌 | 비트 AND |
| 11 | `\|` | 좌 | 비트 OR |
| 12 | `&&` | 좌 | 논리 AND |
| 13 | `\|\|` | 좌 | 논리 OR |
| N/A | `<-`, `<<-` | - | 문장 전용. 식에 포함 불가 |

**한국어 동치 표기(AND/OR, DR-132):**
- 논리 AND: `그리고` ≡ `&&`
- 논리 OR: `또는` ≡ `||`
- 논리 NOT: `아님` *(Gate0/AGE1 정본)*  
  - 기호 `!`는 예약(RESERVED)이지만 Gate0/AGE1 문법에는 도입하지 않는다(사용 시 진단).

**사용자 정의 이음씨:**
- 기본 우선순위: 5 (곱셈/나눗셈급)
- 명시적 우선순위 지정: `우선순위(8) A:수 비교:참거짓:이음씨 B:수` (MAY)

---

## 7. 흐름씨와 일때씨 (Reactive Model)

> 주의: 여기서의 `흐름씨`는 “씨앗(실행 블록)”이다. 값 타입 `흐름(N)`(상태형 링버퍼)와 혼동하지 않는다. (DR-150)


### 7.1 흐름씨 (Stream)

```ddn
속도 <<- 거리 / 시간.
```

**의미:** `속도`는 `거리`나 `시간`이 변할 때마다 자동으로 재계산됩니다.

**제약:**
- **순환 금지 (No Cycles):** `A <<- B`, `B <<- A`는 컴파일 에러 — MUST
- **위상 정렬:** 컴파일러는 흐름씨들의 의존성 그래프를 분석하여 런타임 갱신 순서를 미리 확정

### 7.2 피드백과 시간 지연: `이전값보기` — MUST

`<<-`는 "지금은 흐름씨이고, 값을 계속 흘려보낸다"를 표현하는 전용 연산자입니다.

예)

```ddn
// 가속도는 현재 속도와 "이전 속도"의 차이로 계산
가속도 <<- (속도 - (대상=속도, 초기=0) 이전값보기) / dt.
```

`이전값보기`는 지정한 표현의 **바로 직전 마디의 값**을 반환합니다.

- `초기=`: 첫 마디에는 이전이 없으므로 초기값을 사용합니다. (MUST)
- `대상=`: 이전 값을 보고 싶은 표현(보통 같은 흐름씨/변수)을 지정합니다.

### 7.3 일때씨 (Trigger)

```ddn
(HP < 30) 일때 { ... }
```

**평가 시점:** 매 마디의 **커밋(Commit) 단계 직후**에만 평가됩니다.

**최적화 (Dirty Bitset):**
- 이번 마디에 값이 변경된 컴포넌트 ID를 비트셋으로 관리
- 변경된 컴포넌트에 의존하는 트리거만 선별하여 조건 검사

---

## 8. 진입점 및 이벤트 기반 실행 모델 — MUST

### 8.1 표준 진입점(시스템 훅)

```ddn
(시작)할때 { ... }      // Startup System: 월드 초기화
(매마디)마다 { ... }      // Update System: 매 마디 반복
(끝)할때 { ... }        // Shutdown System: 종료 직전 정리 (99걸음 완성판)
```

- 위 3개는 **내장(예약) 훅**이다. 사용자는 같은 이름의 씨앗을 정의할 수 없다.
- 각 훅 블록은 “시스템(System)”이며, 실행 순서는 **결정적 정렬** 규칙을 따른다. (8.4)

### 8.2 알림(이벤트) — 닫힌 집합 + 패턴 기반 훅

또니랑의 이벤트는 **문자열이 아니라 `고름씨`(닫힌 집합) 값**으로 표현한다.  
즉, “오타가 런타임 버그가 되는 문자열 이벤트”를 원천 차단한다.

#### 8.2.1 알림목록 선언(프로젝트/의존 모듬 포함)

프로젝트는 사용할 알림(이벤트) 변형을 아래처럼 선언한다.

```ddn
알림목록:고름씨 = {
  #레벨업(새레벨:수)
  #충돌(대상:임자, 다른:임자)
  #종료
}.
```

- `알림목록`은 “알림 전용 고름씨”의 **표준 이름**이다.
  - 프로젝트/의존 모듬 어디에서든 `알림목록:고름씨 = { ... }.` 를 여러 번 선언할 수 있으며,
    툴체인이 이를 **합집합(merge)** 으로 정본화한다. (레지스트리)
- 각 `#알림태그`는 컴파일 시 내부 `SignalId`로 인턴되며, **정본화된 알림 레지스트리의 정렬 순서(태그 UTF-8 오름차순)**로 값이 결정된다. (결정적)
- `#변형(필드...)`의 **필드 순서**는 ABI/해시/저장 순서다. (5.10 규칙)
- 동일 프로젝트에서 `#태그` 이름은 전역 유일이어야 한다. (5.10.3)

#### 8.2.2 알림 발생: `알리기`

알림을 발생시키려면, 알림값을 만들고 `알리기`를 호출한다.

```ddn
(#레벨업(새레벨=5)) 알리기.
(#충돌(대상=철수, 다른=영희)) 알리기.
(#종료) 알리기.
```

> 입력 설탕(별칭)으로 `"레벨업"` 같은 **문자열 알림**을 허용할 수 있으나, 정본은 항상 `#레벨업` 같은 **원자 알림**으로 출력한다. (도구가 fix-it 제공)

#### 8.2.3 알림 반응: `할때` 훅 (패턴)

알림을 잡아 반응하는 훅은 다음 꼴이다.

```ddn
(#레벨업)할때 { ... }               // 태그만 매칭 (필드 무시)
(#레벨업(새레벨))할때 { ... }       // 필드 바인딩(패턴)
(#충돌(대상, 다른))할때 { ... }     // 여러 필드 바인딩
```

- `할때`의 괄호 안은 **알림 패턴**이다. (고름씨 패턴과 동일 문법)
- 훅 블록 내부에서는 다음 바인딩이 제공된다. (정본)
  - `그것`: 이번에 매칭된 **알림값 전체**
  - (선택) 패턴에 적은 이름들: 각 필드 값

### 8.3 알림 디스패치(처리) 순서 — MUST (Deterministic)

알림 처리는 **Reactive 패스 모델**을 따른다.

1) Update 단계(각 시스템)에서 `알리기` 호출 → 알림 큐에 append
2) Update 커밋 후 Reactive 단계 시작
3) 한 번의 Reactive 패스에서:
   - 큐를 고정된 정렬 기준으로 스캔한다: `알림` 태그(SignalId) 오름차순, 같은 태그는 발생 순서 유지 (MUST)
   - 매칭되는 `(... )할때` 훅들을 결정적 정렬(8.4)로 실행
4) 패스 중 새로 발생한 알림은 큐에 append되며, **다음 패스**에서 처리된다. (MUST)
5) 큐가 빌 때까지 패스를 반복하되, 최대 패스 수는 `ReactiveMaxPass`로 제한한다. (초과 시 진단 알림) (MUST)

### 8.4 시스템/훅 실행 순서 (Deterministic Sort) — MUST

1. 파일 경로 알파벳 순
2. 같은 파일 내 라인 번호(등장 순)

**목적:** 크로스 플랫폼 결정적 실행 보장


---

## 9. 단위 시스템 — MUST

### 9.1 목적

`@단위`는 수치 값/타입에 붙는 **정적 단위(Units of Measure)** 표기이다.
컴파일 타임 차원 검증 + (선택) 자동 환산의 기반.

### 9.2 표기

```ddn
수@m              // 타입에 단위 부착
10@m              // 리터럴에 단위
m/s, m^2, (m/s)^2 // 단위식
```

### 9.3 단위 정의

```ddn
단위 cm = 0.01 * m.
단위 km = 1000 * m.
```

### 9.4 차원 대수 (Dimensional Analysis) — MUST

컴파일러는 단위 간 연산 규칙을 이해하고, 차원 불일치를 컴파일 오류로 처리해야 합니다.

**[UNIT-VALID-TIME-01] (MUST) 정적 차원 검증 우선**
- 리터럴/상수/명시적 단위가 포함되어 **정적으로 차원을 확정할 수 있는** `+`, `-`, 대입(`<-)`, 비교 연산에서,
  차원 불일치가 있으면 **컴파일 오류**로 처리한다.

**[UNIT-VALID-TIME-02] (MAY) 경계 입력(샘/호스트) 런타임 안전망**
- `샘(Sam)` 입력이나 호스트(FFI) 경계처럼 **정적으로 단위를 확정할 수 없는 값**에 대해서는,
  런타임에 차원을 판정/검증할 수 있다.
- 실행 중 차원 불일치가 관측되면, 이는 **산술 고장 계열**로 취급하고 다음을 적용한다:
  - 해당 대입(`<-)` 문장은 **무효화**한다. (MUST)  *(참조: [MATH-DIV-01]의 “대입 무효화” 정책과 동일 계열)*
  - 실행 주체 엔티티에 `#고장`을 부착한다. (MUST)
  - 추가로 `#차원고장`을 부착할 수 있다. (SHOULD, 디버깅/학습)
  - 거울(Geoul)에 “차원 불일치” 사유와 관측 단위를 기록할 수 있다. (SHOULD)

```ddn
길이(m) / 시간(s) = 속도(m/s)  // OK
길이(m) + 시간(s)              // 컴파일 에러!
```

**최소 지원 범위:**
- `+`, `-`, 대입, 비교에서 "동일 차원" 강제
- `*`, `/`, `^`에서 차원 합성/분해

**[UNIT-EXP-01] (MUST) 단위식 지수 제한(관문 0)**
- 단위식의 `^` 지수는 **컴파일타임 정수 리터럴**만 허용한다. (예: `m^2`, `(m/s)^2`)
- `m^(1/2)` 같은 **분수 지수 단위식은 금지**한다.
- 제곱근/세제곱근 등은 단위식이 아니라 **수치 함수(DetMath) 설탕**으로 제공한다. (예: `루트(x)`)

### 9.5 자동 환산 — MUST

```ddn
100@cm + 1@m  // 컴파일 타임에 2@m로 정규화
```

원칙:
1. 내부 캐노니컬 단위(m, s, kg)로 정규화 후 연산 — SHOULD
2. 리터럴/상수는 상수접기로 변환 — MUST
3. 비상수 값의 환산은 스케일 팩터 삽입 가능 — MAY

---

## 10. 조사/별칭 시스템 — MUST

### 10.1 매개변수 별칭 선언

```ddn
// A는 '을'/'를' 별칭, B는 '이'/'가' 별칭
(A:수@m~을~를, B:수@s~이~가) 속도구하기:셈씨:수@m/s = {
    속도구하기 <- A / B.
}
```

### 10.2 세 가지 호출 바인딩 모드

#### 10.2.1 이름 바인딩 (네임드 인자) — 기본, MUST

```ddn
A=56 B=23 속도구하기
```
순서는 자유.

#### 10.2.2 별칭 바인딩 (조사형) — 권장, SHOULD

```ddn
56을 23가 속도구하기
```
내부적으로 `A=56, B=23`으로 바인딩됨.

**조건:** 별칭→매개변수 매핑이 유일해야 함. 아니면 컴파일 오류.

#### 10.2.3 위치 바인딩 — 병행 권장, SHOULD

```ddn
(56, 23) 속도구하기
```
매개변수 선언 순서를 따름.

#### 10.2.4 정본 출력(표면) 우선순위 — MUST (canon)

호출(CallExpr)은 같은 의미를 여러 표면형으로 적을 수 있다.  
저장/공유/문서/골든 테스트에 들어가는 **정본 DDN(canon 출력)** 에서는, 바인딩 표면을 다음 우선순위로 수렴시킨다.

**[CANON-CALL-BINDING-ORDER-01] (MUST, canon)**

1) **별칭 바인딩(조사형)**
   - PinSpec에 핀 조사가 정의되어 있고, 각 인자가 **유일하게** 핀으로 결정될 수 있으면 정본 출력은 조사형을 우선한다.
   - 조사형은 **괄호 `()`를 쓰지 않는다.**  
     예: `100@m~를 3@s~동안 이동하기.`
   - 단위/쓸감 표기(`@...`)나 핀 고정(`:핀`)이 포함된 인자에서 조사를 붙일 때는, 경계 고정을 위해 **반드시 `~조사`를 쓴다.**  
     예: `100@m~를`, `@"그림.png"~을`, `사과:대상~를`

2) **핀 고정 바인딩(`:핀`)**
   - `:핀`은 **모호성 해소용 옵션**이다. 조사형 바인딩이 유일하면 정본 출력에서 `:핀`을 제거한다.
   - 조사형이 불가능(별칭 없음/충돌/중의)하거나, 정본 출력에서 더 안전하게 핀을 봉인해야 하면 `:핀`을 사용한다.
   - `:핀` 바인딩도 **괄호 없이** 나열할 수 있다.  
     예: `100@m:거리 3@s:시간 이동하기.`
   - 조사를 **함께 병기**할 수 있으나(가독성), 의미 확정은 `:핀`이 우선한다. (PARSER-LOOKUP-02)

3) **위치 바인딩(괄호 `()` )**
   - 위 둘이 불가하거나, 인자 표현이 복잡해 “인자 경계”를 안정적으로 잡기 어려울 때만 `( … )` 위치 바인딩으로 폴백한다.
   - 예: `(100@m, 3@s) 이동하기.`

**정본화/진단(추가 규정):**

- 정본화기는 조사형이 성립하면 그 형태를 우선하며, 불필요한 `:핀`과 불필요한 괄호(`()`)를 제거한다.
  - 예: `3@초:시간~동안` → `3@초~동안`
  - (권장 진단) `LINT-REDUNDANT-PIN` (별칭: `L_CALL_PIN_REDUNDANT`)
- 인자 바인딩이 모호하여(핀/조사 생략 상태에서) 단일 해석이 불가능하면 실패한다. (MUST)
  - 진단 코드: `E_CALL_PIN_REQUIRED`
  - 권장 수정: `:핀` 추가를 우선 제안, 또는 `~조사` 추가


**Loose 입력(편집기/대화용)**
- 조사형/핀고정형 인자 나열에서 `,`는 “읽기 쉼표”로 **허용할 수 있다(MAY)**.  
  단, 정본 출력에서는 `,`를 제거하고 공백 구분으로 수렴한다.

### 10.3 바인딩 스타일 통일 — MUST

하나의 호출문 안에서 바인딩 방식은 **한 가지로만** 통일해야 합니다.

- `핀=값`(이름 바인딩)과 `:핀`/`~조사`(조사/위치 바인딩)는 **혼합 금지**.
- 단, 조사/위치 바인딩 안에서는 필요할 때 `:핀`을 추가해 **모호성만 해소**할 수 있다(여전히 조사/위치 바인딩으로 취급).

```ddn
56을 B=23 속도구하기  // 오류! 혼합 금지
```

### 10.4 조사/별칭 토큰화 알고리즘 — MUST

> 이 알고리즘은 **어절 내부(체언+조사)**에서만 적용된다. 어절 간 경계는 반드시 띄어쓰기(SPACING-01)로 표시해야 한다(MUST).

**JOSA-SPLIT-01 조사 접미사 자동 분리: MUST (Gate0)**  
조사 글자 자체를 금지하지 않습니다. `~`가 있으면 경계가 고정됩니다. `~`가 없으면 [JOSA-SPLIT-01]의 우선순위(전체 어절 이름 우선 → 접미사 분리)를 적용합니다.  
의도 강제가 필요할 때는 `~`로 조사 경계를 명시합니다. (예: `사과~를`, `도~로`)  

**권장/린트(혼선 방지)**

- 정의(선언) 이름에 조사를 붙이는(예: `사과를:이름씨`) 것은 **강하게 비권장**합니다.  
  한국어 문장처럼 쓰는 순간 “조사 분리”와 충돌하기 쉬워서, Gate0 기본 린트는 이를 경고합니다.
- 같은 스코프에 `사과`와 `사과를`이 공존하면, `사과를` 토큰은 **전체 이름을 우선**으로 해석됩니다.  
  이때 “조사 분리”를 **확정**하고 싶으면 `사과~를`처럼 `~`를 써서 경계를 명시합니다.
- teul-ide(LSP)는 타이핑 중에도 “전체이름”/“조사분리” 해석을 **고스트 텍스트**로 즉시 표시해야 합니다.



붙임형 토큰(예: `오리가`, `철수를`, `도로를`, `사과를~`)을 만났을 때:

1. **물결 경계 우선:** `X~Y` → `X`(이름) + `Y`(조사). `X~` → **보호된 이름** `X` (조사 분리 금지).
2. **접미사 분리(긴 조사 우선):** 물결이 없으면, 허용 조사 집합에서 끝에서부터(최장) `T = S + J`를 시도한다. `S`가 현재 스코프에서 유효하면 분리한다.
3. **단독 식별자:** 분리 불가이면 `T` 전체를 식별자로 유지한다. *(이후 “정의되지 않음” 오류가 날 수 있음)*
4. **모호성:** `T`가 식별자로도 유효하고 동시에 `S+J`도 성립하면 **컴파일 오류**. 사용자가 `S~J` 또는 `T~`로 의도를 명시한다.


#### 10.4.1 숫자 리터럴 접미 분리 — MUST

```ddn
100을     // 100 + 별칭 '을'
100cm를   // 100@cm + 별칭 '를'
```

**알고리즘:**
1. 숫자 리터럴 뒤 즉시 한글이 오면
2. 단위 접미사(`cm`, `m`, `s` 등) 먼저 시도
3. 단위가 아니면 조사 분리 시도

#### 10.4.2 블루프린트/노드 핀 매핑 (설계 가이드)

```ddn
// 블루프린트 툴에서:
// "거리를 시간이 나누기" → 노드 3개 + 와이어 2개
// - 거리(출력 핀 '을')
// - 시간(출력 핀 '이')
// - 나누기(입력 핀 '을', '이')
```

**권장:**
- 조사는 핀 레이블로 표시
- 와이어 연결 시 핀 타입 + 조사 매칭 검증

### 10.5 명시적 접미 접착자 (`@`, `:`, `~`) — MUST

모호함 방지 및 **경계(토큰 분리) 고정**을 위해, 호출 인자(값) 뒤에 다음 접미 접착자를 쓸 수 있다.

- `@` : **단위/쓸감** (예: `100@cm`, `@"그림/주인공.png"`)
- `:` : **핀 고정** (예: `사과:대상`)
- `~` : **조사(붙임) 표기** (예: `사과~를`, `문~에서`)

> 주의: 선언부의 `돕~도우` 같은 **어간 별칭**의 `~`는 이름 내부 표기이며, 호출 인자 접미의 `~조사`와 문법 위치가 다르다.
> 또한 선언부의 `이름:이름씨`에서 `:`는 타입 구분자이고, 호출 인자 접미의 `:핀`은 **핀 고정자**다.

**접미 체인 순서(정본):**  
`〈값〉 [@〈단위〉|@"〈자원경로〉"] [:〈핀〉] [~〈조사〉]`  
예: `100@m:거리~에서`

**규칙(MUST):**
- 접미 접착자는 **인자 접미 위치**에서만 의미를 갖는다. (`@핀` 같은 표기는 **금지**: 핀 고정은 반드시 `:핀` 사용)
- `@`(단위/쓸감)·`:`(핀)·`~`(조사)는 **각각 최대 1회**만 사용할 수 있다. (중복/역순이면 오류)
- `:핀` 또는 `~조사`는 **상황에 따라 생략 가능**하다.  
  - 생략 시에도 규칙만으로 단일 매핑이 가능해야 하며, 불가하면 오류(`E_CALL_PIN_REQUIRED`) + `:핀`(우선) 또는 `~조사` 요구.
- 이 접미들은 **공백 없는 붙임**에서 경계를 강제로 고정한다. (예: `사과를먹기` 대신 `사과~를 먹기`)

**예시:**
```ddn
가을~을                 // 값 '가을' + 목적격 조사(을)
100@cm                  // 값 100 + 단위 cm
100@m:거리~에서          // 값 100 + m + '거리' 핀에 고정 + '에서' 조사
사과:대상~를 먹기.       // '대상' 핀에 고정 + 목적격
```


#### 10.5.1 접미 체인 파싱 알고리즘(결정) — MUST

**목표:** `100@m:거리~에서` 같은 **접미 체인**을 “한 토큰”으로 받아도, 모든 플랫폼에서 **동일한 파싱 결과(정본 AST)** 를 얻는다.

**입력:** 인자 원자 토큰(공백으로 분리된 1개 토큰)  
**출력:** `ArgAtom` 구조체(정본)

```text
ArgAtom {
  core: ValueAtom,            // 수/글/식별자/쓸감핸들 등
  unit_or_res: UnitOrRes?,     // @m 또는 @"경로"
  pin_fix: PinId?,             // :거리
  particle: ParticleId?,       // ~에서
}
```

**정본 순서:** `〈값〉 [@단위|@"자원경로"] [:핀] [~조사]`  
- 역순/중복은 **오류(MUST)**

**파서(의사코드, 결정):**
```pseudo
fn parse_arg_atom(token: str) -> Result〈ArgAtom, Diag〉 {
  // 0) 초기
  let s = token
  let particle = None
  let pin_fix  = None
  let unit_or_res = None

  // 1) ~조사: 가장 오른쪽의 '~' 1회만 허용
  if s contains '~' {
    (lhs, rhs) = split_last(s, '~')
    if rhs is empty -> error("PARTICLE_EMPTY")
    if rhs not in ParticleRegistry -> error("PARTICLE_UNKNOWN", rhs)
    particle = Some(rhs)
    s = lhs
    if s contains '~' -> error("PARTICLE_DUP")
  }

  // 2) :핀: 가장 오른쪽의 ':' 1회만 허용
  if s contains ':' {
    (lhs, rhs) = split_last(s, ':')
    if rhs is empty -> error("PIN_EMPTY")
    if rhs is not Identifier -> error("PIN_NOT_IDENTIFIER", rhs)
    pin_fix = Some(rhs)
    s = lhs
    if s contains ':' -> error("PIN_DUP")
  }

  // 3) @단위/쓸감: 가장 오른쪽의 '@' 1회만 허용
  if s contains '@' {
    (lhs, rhs) = split_last(s, '@')
    if rhs is empty -> error("AT_EMPTY")

    if rhs starts_with '\"' {
      // @"...": 자원 접미 (따옴표 포함은 어휘단에서 보장)
      // 여기서는 rhs가 "\"...\"" 형태라고 가정(닫는 따옴표 필수)
      let path = parse_quoted(rhs)?      // 실패 시 RESOURCE_QUOTE
      unit_or_res = Some(Resource(path))
    } else {
      // @m: 단위 접미
      if rhs not in UnitRegistry -> error("UNIT_UNKNOWN", rhs)
      unit_or_res = Some(Unit(rhs))
    }

    s = lhs
    if s contains '@' -> error("AT_DUP")
  }

  // 4) 코어 값(ValueAtom) 파싱
  let core = parse_value_atom(s)?        // 수/글/"문자열"/식별자/@"자원" 등 기존 규칙

  // 5) 충돌 방지(선택)
  if pin_fix is Some(x) and x in UnitRegistry -> error("PIN_NAME_COLLIDES_WITH_UNIT", x)
  if pin_fix is Some(x) and x in ParticleRegistry -> error("PIN_NAME_COLLIDES_WITH_PARTICLE", x)

  Ok(ArgAtom{ core, unit_or_res, pin_fix, particle })
}
```

**중요(MUST):** `@"...경로..."` 내부의 `:`/`~`/`@` 문자는 **접미 체인 구문**으로 해석하지 않는다. (따옴표 내부는 문자 그대로)

---

#### 10.5.2 바인딩 모호성 진단 + LSP QuickFix — MUST

접미 체인 파싱은 **토큰 내부 형태**만 결정한다. 이후 “어떤 핀에 꽂히는가”는 **PinSpec 바인딩 규칙**에 따라 결정된다.

**바인딩 규칙(요약, MUST):**
1. `:핀`이 있으면 **해당 핀으로 고정**한다. (타입/조사 호환 검증 후 불일치면 오류)
2. `:핀`이 없으면, 후보 핀 집합을 만든다:
   - 타입 호환(필수)
   - `~조사`가 있으면 **조사 허용 목록**에 포함(필수)
3. 후보가 1개면 그 핀으로 결정한다.
4. 후보가 2개 이상이면 **추측 금지**: 오류 `PIN_AMBIGUOUS` + QuickFix 제공

**LSP QuickFix 우선순위(MUST):**
- (1) `:핀` 추가/교체(가장 강함)  
- (2) `~조사` 추가/교체(조사로만 분리 가능한 경우)  
- (3) 그래도 안 되면 “문장 구조(자리/띄어쓰기) 재작성” 제안

**예시(모호성):**
- 시그니처: `(시작:수~에서, 끝:수~에서) 이동하기.`
- 입력: `100@m~에서 이동하기.`
- 결과: 후보 2개(시작/끝) → 오류 + QuickFix: `100@m:시작~에서` 또는 `100@m:끝~에서`

**`@` 오용 QuickFix(MUST):**
- 입력: `사과@대상~를 먹기.` (`대상`은 단위가 아님)
- 진단: `UNIT_UNKNOWN("대상")`
- QuickFix: `사과:대상~를 먹기.` (사용자가 “핀 고정” 의도였다고 보고 교정 제안)


---

### 10.5 표기 스타일(style): canon / pretty

이 절은 “같은 의미를 여러 모양으로 쓸 수 있을 때”의 **출력 규칙(정본화)**과 **사람용 표기**를 분리한다.

#### [STYLE-CANON-01] 정본 출력(canon) — MUST
- 정본화 출력은 조사 경계 `~`를 **필요한 곳에 반드시 삽입**하여 해석이 흔들리지 않게 한다.
- 호출 인자 표기는 `값~조사`가 정본이며, `값:핀~조사`는 **모호성 해소용 옵션**이다.
- 유일 바인딩이면 정본화 출력에서 **불필요한 `:핀`을 제거**한다.
- `sym3/en` 등 말씨(별칭)로 입력이 들어와도, **canon 출력은 ko 정본 표기**로 복원한다.

#### [STYLE-PRETTY-01] 사람용 출력(pretty) — SHOULD
- 사람용 출력(pretty)은 기본 조사에 한해 `~`를 **생략할 수 있다**.
- 단, 생략 결과를 다시 파싱했을 때 **동일 AST가 유일하게 복원되는 경우에만** 제거한다(왕복 가능).
- 애매해지면 `~`를 유지한다.

---

### 10.6 말씨(dialect): ko + sym3 + (선택한 1개 말씨)

> 말씨는 “의미(=AST)”를 바꾸지 않고, **표기(토큰/별칭)와 린트/포매터 기본값**만 바꾼다.

#### [DIALECT-HEADER-01] 파일 말씨 헤더 — SHOULD
- 파일 머리 메타 헤더로 `#말씨: <tag>` 를 둘 수 있다. (`#사투리:`는 별칭)
- `<tag>`는 레지스트리 태그 중 1개다: `ko|en|sym3|ja|mn|tr|qu|ay|ne|ta|te|kn|eu`
- **활성 키워드 집합(active token set)**:
  - 항상 활성: `ko_canon` + `sym3`
  - 조건부 활성: `#말씨: <tag>` 로 선택한 말씨 1개
- `#말씨`가 없으면 기본은 `ko`이며, 활성 집합은 `ko_canon + sym3`만이다.
- 비활성 말씨 토큰이 등장하면:
  - (MUST) **키워드로 인식하지 말고 식별자**로 토큰화한다. (크래시 금지)
  - (SHOULD) lint 경고 `DIALECT_TOKEN_NOT_ACTIVE` 를 낸다.
- 한 파일에서 “말씨 A + 말씨 B” 혼용은 권장하지 않으며, 위 규칙에 의해 B는 식별자로 처리된다.
  - 단, **ko 정본은 언제나 허용**된다(학습/디버깅/정본화 힌트).

#### [DIALECT-REGISTRY-01] Registry(전수 등록) vs Certification(보증) — SHOULD
- 레지스트리(표 등록)는 “입력 표면 후보”를 뜻하며, **동치 보증을 뜻하지 않는다.**
- 보증(Certified) 표기는 **pack으로 동치가 확인된 말씨**에만 부여한다.
  - 예: `docs/ssot/pack/lang/dialect_equiv_v2`
  - 예: `docs/ssot/pack/lang/dialect_equiv_ne_v1` (ne: 데바나가리 입력, AST 동치 + state_hash 동치(확장))
- Experimental 말씨는 `#말씨:`로 선택하면 **입력/정본화는 가능**하되, pack 동치 보증은 없다.  
  *(대신 스모크 팩 + 문서/교육 “표시(render)”에서 우선 사용한다.)*

#### [DIALECT-TAGSET-01] 말씨 태그 집합(레지스트리) — SHOULD
- 핵심(구현 기준, Certified): `ko`, `en`, `sym3`
- 입력 별칭(Certified by pack): `ja`, `mn`, `tr`
- Registry/Experimental(표 + 선택 입력 가능): `qu`, `ay`, `ne`, `ta`, `te`, `kn`, `eu`
- ne(네पाली)는 데바나가리 표기 우선이며, 일부 셀은 `देवनागरी/roman`처럼 `/`로 복수 별칭을 병기한다.
  - 기준표 v4 (로마자 중심, 자연스러움 리뷰 기준)
    - `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v4_20260215.tsv`
    - `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v4_20260215.detjson`
  - 개선표 v8 (문법 용어 정합성 + 간소 별칭 병기, 셀의 `/`는 복수 별칭을 뜻함)
    - `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v8_20260215.tsv`
    - `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v8_20260215.detjson`
    - (보기용) `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v8_20260215.md`
    - (변경로그) `docs/context/notes/dialect/DDONIRANG_dialect_keywords_full_v8_20260215_CHANGELOG.md`

#### [DIALECT-SURFACE-VARIATION-01] 언어별 표면 차이 포용 — SHOULD

말씨는 **표면 토큰**이 달라도 된다.

- 모든 말씨 입력은 **동일 AST**로 정규화되어야 한다. (의미 동일)
- `canon` 출력은 항상 **ko 정본 표기**로 수렴한다. (감사/리플레이/팩 비교용)

포용 범위(허용):
- 동일 역할(role)을 표현하는 **여러 형태(이형태/동의 표지)** 를 허용할 수 있다.
- 언어 특성상 자연스러운 **무표(∅)** 가 존재하는 경우, *표시(render) 층* 또는 *제한된 입력(예: 괄호식)* 에서 허용할 수 있다.
- 허용형(accepted)을 받아도, fmt는 말씨별 **권장형(preferred)** 으로 정리할 수 있다.

금지:
- 말씨가 의미(평가 순서/스코프/결정성)에 차이를 만들면 안 된다.
- 모호성은 추측하지 않는다. 후보가 2개 이상이면 **결정적 오류**로 보고하며, `:핀` 등 명시 표기를 요구한다.

권장형/허용형:
- 각 말씨/각 role에 대해 **권장형(preferred)** 과 **허용형(accepted)** 을 구분해 문서화한다.
- pack/golden은 권장형 중심으로 작성하되, 허용형도 별도 케이스로 동치 검증한다.

추가 가이드(“부품 vs 문장”):

- **sym3 토큰셋**은 *키보드/도구를 위한 “부품”* 이다. (짧게 치고, 패턴을 맞추기 좋음)
- **word‑dialect 토큰셋**(ne/ta/te/kn/eu/qu/ay 등)은 *사람이 읽는 “문장”* 이다. (교육/창작/자기 언어 감각)

따라서 아래를 권장한다.

- (SHOULD) `#말씨: X`(X≠sym3) 예제/팩은 **sym3 기호를 섞지 않고**, 해당 말씨의 **권장형(preferred)** 으로만 쓴다.
- (MAY) 입력에서 sym3를 *compat* 로 허용하더라도, `fmt`/문서 예제는 **word‑dialect의 권장형**으로만 출력한다.

파이프(pipe) 권장형(요약):
- en: `|>` *(권장)*
- ko: `해서` *(권장)*
- ne: `-एर` *(권장; 허용형: `|>`)*

호출(call) 권장형(요약):
- en/ja/mn/tr: `()` — **비어있는 호출 표지** *(괄호 안 인자 금지; MUST empty)*
  - 인자 전달은 `~ob/~sb/~tp` 등의 조사 별칭 또는 `:핀`을 사용한다.
- ko: `~기/~하기`
- ne: `~नु` *(권장; 허용형: `()`)*

주의:
- `foo()`의 괄호 안에는 인자를 넣지 않는다. 또니랑은 **조사/핀 기반 인자 전달**이 정본이다.

#### [DIALECT-EXAMPLE-STYLE-01] 말씨 예제 작성 원칙 — SHOULD

말씨는 “키워드 별칭”이며, **문법/공백 규칙 자체를 분기시키지 않는다.**

- (SHOULD) `#말씨: X` 예제는 **X 말씨의 키워드 + ko 정본 키워드**만으로 작성한다.
  - sym3 토큰(예: `|>>`, `!()`)은 “sym3 절”에서만 소개한다.
  - 이유: 학습자에게 “한 파일에 규칙이 2개”로 보이는 인지 부하를 줄이기 위함.
- (SHOULD) 함수/변수 **식별자(identifier)** 도 가능하면 해당 언어권에서 자연스러운 표기(자기 문자)를 쓴다.
  - 예: `#말씨: ne` 예제에서 `add`, `sum` 같은 영어 식별자는 피한다.
  - 단, 동치 검증(pack)처럼 **식별자 동일성**이 필요한 테스트에서는 중립 식별자를 사용한다.
- (SHOULD) 표준 라이브러리(stdlib)의 **식별자**는 기본적으로 ko 정본을 유지한다.
  - 말씨는 “예약어/조사/꼬리” 중심이다. stdlib 번역은 **별도 레이어(확장)** 로 다룬다.
  - 필요 시 `stdlib_alias_<dialect>` 테이블로 “자국어 별칭”을 추가 지원할 수 있다(권장: 핵심 20개부터).
- (SHOULD) word‑dialect 예제에서는 `|>`/`()` 같은 기호 표기를 섞지 않는다(compat는 허용).
  - linter는 `DIALECT_SYMBOL_MIX`(가칭) 경고를 낼 수 있다.
- (MUST) 정본화(`canon`)와 fmt는 언제나 **ko 정본 공백/줄바꿈 규칙**으로 수렴한다.
  - 말씨는 “토큰 사전”이고, “문법”이 아니다.

#### [DIALECT-KO-01] ko 정본 — MUST
- 문서/예시/AI 출력의 기본 말씨는 **ko 정본**이다.
- 정본 키워드(순우리말):
  - `되풀이/되돌림/톺아보기/맞물림씨` 등
- legacy alias(입력 허용, 정본화는 ko 권장):
  - `반복/반환/감사/관계씨`

#### [DIALECT-EN-01] en 별칭 — MAY
- en 말씨는 “한국어를 모르는 사용자”를 위한 입력 별칭이다(정본 아님).
- 권장 en 별칭(예):
  - `if/else/match/then`
  - `and/or/not`
  - `loop/return/audit`
- 파이프(ko `해서`)의 en 표면형:
  - `|>`  *(권장; canon에서는 `해서`로 복원)*
- 호출 꼬리(ko의 `~기/~하기`)의 en 표면형:
  - `()`  *(비어있는 호출 표지; 괄호 안 인자 금지(MUST empty). 인자 전달은 조사(아래 10.8) 또는 `:핀`을 권장)*

#### [DIALECT-SYM3-01] sym3 별칭 — MUST(말씨가 sym3로 고정된 경우)
- sym3는 아래 10.7의 토큰셋을 정본으로 한다.
- sym3 파이프(ko `해서`)는 `|>>`만 허용한다. (`|>`는 금지 또는 compat 경고+정규화)
- 호출 꼬리(sym3 표면형): `!()`  *(3글자, 호출 표지)*

#### [DIALECT-JA-01] ja 별칭(입력) — MAY (v1 최소 셋)
- 목적: 일본어 사용자가 “제어/논리/흐름”을 **자기 언어로** 적을 수 있게 한다(정본 아님).
- v1 범위: **조건/분기/논리/되풀이/되돌림/톺아보기** 최소 키워드만 지원한다.
- 파이프(ko `해서`)는 ja 입력에서 `|>`를 권장한다. (단, ko 및 일부 단어 기반 말씨는 word 파이프를 권장하며 `|>`는 compat)
- 호출 꼬리: `()`.

권장 키워드 매핑(v1):
- `もし` → `일때`
- `でなければ` → `아니면`
- `一致` → `따라`   *(match/switch)*
- `なら` → `이면`   *(then/arm)*
- `繰返` → `되풀이` *(loop; “繰り返し”의 축약 코드 토큰)*
- `返す` → `되돌림` *(return)*
- `かつ` → `그리고` *(and)*
- `または` → `또는` *(or)*
- `ではない` → `아님` *(not)*
- `点検` → `톺아보기` *(audit/inspect)*

#### [DIALECT-MN-01] mn 별칭(입력) — MAY (v1 최소 셋)
- 목적: 몽골어 사용자가 “제어/논리/흐름”을 자기 언어로 적을 수 있게 한다(정본 아님).
- v1 범위: **조건/분기/논리/되풀이/되돌림/톺아보기** 최소 키워드만 지원한다.
- 파이프(ko `해서`)는 `|>`를 권장한다.
- 호출 꼬리: `()`.

권장 키워드 매핑(v1):
- `хэрэв` → `일때`     *(if)*
- `үгүйбол` → `아니면`  *(else; 코드 토큰은 공백 없이 붙여쓴다)*
- `тааруул` → `따라`   *(match/switch; “맞추다/맞추기” 의미)*
- `бол` → `이면`        *(then/arm)*
- `давтах` → `되풀이`   *(loop)*
- `буцаах` → `되돌림`   *(return)*
- `мөн` → `그리고`      *(and)*
- `эсвэл` → `또는`      *(or)*
- `биш` → `아님`        *(not)*
- `шалгах` → `톺아보기` *(audit/check)*

#### [DIALECT-TR-01] tr 별칭(입력) — MAY (v1 최소 셋)
- 목적: 터키어 사용자가 “제어/논리/흐름”을 자기 언어로 적을 수 있게 한다(정본 아님).
- v1 범위: **조건/분기/논리/되풀이/되돌림/톺아보기** 최소 키워드만 지원한다.
- 파이프(ko `해서`)는 `|>`를 권장한다.
- 호출 꼬리: `()`.

권장 키워드 매핑(v1):
- `eger`/`eğer` → `일때`   *(if; 구현체는 둘 다 허용 가능)*
- `yoksa` → `아니면`       *(else)*
- `esle`/`eşle` → `따라`   *(match/switch; “eşle”=match)*
- `ise` → `이면`            *(then/arm)*
- `tekrar` → `되풀이`       *(loop)*
- `dondur`/`döndür` → `되돌림` *(return)*
- `ve` → `그리고`           *(and)*
- `veya` → `또는`           *(or)*
- `degil`/`değil` → `아님`  *(not)*
- `denetle` → `톺아보기`    *(audit/inspect)*

#### [DIALECT-I18N-01] i18n(다국어) 읽기 렌더링 — MAY
- 목적: 문서/교육에서 ko 정본 코드를 여러 언어로 “읽기 좋게” 표시한다.
- `ja/mn/tr` 말씨는 **파서 입력(제한된 키워드)** 으로 채택했지만,
  `i18n-*`는 그보다 더 넓은 번역(설명/표지/문장/라이브러리 이름까지)을 할 수 있는 “표시(render)” 층이다.
- `i18n-*` 출력은 왕복 파싱을 요구하지 않으며, pack/golden 저장에 사용하면 안 된다.

### 10.7 SYM3 토큰셋(정본)

> 원칙: **2~3글자 토큰** + **최장일치(맥스먼치)**.  
> sym3는 “기호만으로” 쓰고 싶은 사용자를 위한 별칭 말씨이며, ko 정본을 대체하지 않는다.

| ko | 의미 | sym3 |
|---|---|---|
| `일때` | if | `?=>` |
| `아니면` | else | `;=>` |
| `따라` | match/switch | `|=|` |
| `이면` | then/arm | `=>>` |
| `되풀이` | loop | `<*>` |
| `되돌림` | return | `=<<` |
| `그리고` | and | `&^&` |
| `또는` | or | `|^|` |
| `아님` | not | `^^^` |
| `해서` | pipe | `|>>` |
| `}한것` | thunk/value | `}=>` |
| `}인것` | thunk/bool | `}==` |
| `}아닌것` | thunk/not-bool | `}!=` |
| `}하고` | thunk/do | `}&>` |
| `}해서` | thunk/pipe | `}|>` |

---

### 10.8 조사(role) 말씨별 표면형: preferred / accepted

목적:
- ko 정본의 `값~조사` 호출 구조를 유지하면서, en/ja/mn/tr/sym3 사용자도 **자기 언어(또는 짧은 코드)** 로 인자 역할을 표시할 수 있게 한다.
- 말씨별 표면형이 달라도 **정본화(canon)** 는 항상 ko 조사로 수렴한다.

정본화 원칙:
- 내부(바인딩/AST)는 “표면 조사 문자열”이 아니라 **role**(SB/OB/…)로 정규화해 다룬다.
- 말씨 입력에서 role 후보가 2개 이상이면 **추측 금지**: 오류 + `:핀`(또는 더 구체적인 조사 표기)로 해소한다.

#### [JOSA-ROLE-01] role 집합 — MUST

| role | 뜻(요약) |
|---|---|
| SB | 주격(대상) |
| OB | 목적격(대상) |
| TP | 주제(화제) |
| AT | 처소/방향/시간(에) |
| BY | 수단/방식(로/으로) |
| FR | 위치/출발(에서) |
| TO | 수혜/대상(에게/께) |
| FM | 시작(부터) |
| UN | 한계(까지) |

#### [JOSA-ROLE-02] 말씨별 권장형/허용형 — MUST

표기:
- `preferred` = fmt가 기본으로 정리해 출력하는 형태
- `accepted` = 입력으로 허용하는 추가 형태(이형태/동의 표지)

| role | ko preferred | en/sym3 preferred | ja preferred | ja accepted | mn preferred | mn accepted | tr preferred | tr accepted |
|---|---|---|---|---|---|---|---|---|
| SB | `~이/~가` | `~sb` | `~が` | `~が` | `~sb` | `~sb` *(무표는 표시 전용)* | `~sb` | `~sb` *(무표는 표시 전용)* |
| OB | `~을/~를` | `~ob` | `~を` | `~を` | `~ыг` | `~ыг/~ийг` | `~ı` | `~ı/~i/~u/~ü` |
| TP | `~은/~는` | `~tp` | `~は` | `~は` | `~бол` | `~бол/~нь` | `~tp` | `~tp` *(또는 accepted: `ise` 계열은 추후 확장)* |
| AT | `~에` | `~at` | `~に` | `~に/へ` | `~д` | `~д` | `~a` | `~a/~e` |
| BY | `~로/~으로` | `~by` | `~で` | `~で` | `~аар` | `~аар/~ээр` | `~la` | `~la/~le` |
| FR | `~에서` | `~fr` | `~から` | `~で/~から` | `~аас` | `~аас/~ээс` | `~da` | `~da/~de` |
| TO | `~에게/~께` | `~to` | `~に` | `~に` | `~д` | `~д` | `~a` | `~a/~e` |
| FM | `~부터` | `~fm` | `~から` | `~から` | `~аас` | `~аас/~ээс` | `~dan` | `~dan/~den` |
| UN | `~까지` | `~un` | `~まで` | `~まで` | `~хүртэл` | `~хүртэл` | `~kadar` | `~kadar` |

#### [JOSA-ROLE-03] “무표(∅)” 처리 — MUST(제한)

- mn/tr에서 주격(SB)은 현실 언어에서 무표(∅)가 자연스럽지만,
  **AGE0(Gate0) 입력에서 “조사 완전 생략”은 기본 지원하지 않는다.**
- 무표는:
  - `i18n-*` 표시(render) 층에서의 출력,
  - 또는 괄호식 호출 `( ... )` 등 “구분자가 이미 있는 형식”
  에서만 허용한다.
- josa 스타일 입력에서 SB를 생략하고 싶다면, 말씨별 `~sb`(명시형)을 사용한다.

#### [JOSA-ROLE-04] fmt/lint 권장 — SHOULD

- fmt는 말씨별 `accepted` 입력을 `preferred`로 정리할 수 있다.
- `canon` 출력은 언제나 ko preferred(ko 조사)로 복원한다.
- `ja`에서 `~に`(AT/TO), `~から`(FR/FM)처럼 **역할이 겹칠 수 있는 표면형**은,
  후보가 2개 이상이면 오류로 보고하고 `:핀`을 요구한다.


### 10.9 `}` 토막 꼬리 예약(선점)

아래 꼬리는 **예약어로 선점**한다(추후 의미 부여).

- `}하며`
- `}한채`
- `}하자마자`


## 11. 실행 어미 (Execution Endings)

### 11.1 기본 어미 — MUST

| 어미 | 의미 | 실행 정책 |
|------|------|-----------|
| `-다.` | 완료/종결 | 문장 종결 |
| `-고` | 순차 | 순차 실행 강제 |
| `-며` | 병행 | 동시 실행 허용 |

### 11.2 확장 어미 — MAY (점진 도입)

| 어미 | 의미 | 실행 정책 |
|------|------|-----------|
| `-거나` | 선택 | Race/Select |
| `-다가` | 중단 | Interrupt |
| `-려다` | 실패시 | Fallback |
| `-채` | 상태 유지 | State Hold |
| `-자마자` | 즉시 | Immediate |
| `-도록` | 목표 | Goal 등록 |

### 11.3 용언 활용 (어간 별칭) — SHOULD

> 목표: **사용자는 짧게 쓰고**, **엔진은 엄격하게 해석**한다. 내부 정규형은 1개로 고정(결정성), 표면 출력은 한국어 관습을 따른다.

#### 11.3.1 원칙 — MUST
- **내부 정규형 1개**: 활용/축약/표기 차이는 모두 내부 정규형으로 정규화한다.
- **표면은 추천/출력 겹에서**: 도우미(LSP) 및 표면화기에서 자연스러운 표면형을 추천/출력한다.
- **모호성은 추측 금지**: 표면형→원형 역추적에서 후보가 2개 이상이면 오류로 처리하고 `:핀` 고정을 요구한다.

#### 11.3.2 어간 별칭 `~` — MUST
불규칙 활용/어간 교대가 필요한 움직씨는 `어간~교대형`으로 선언한다.

```ddn
// 불규칙(교대) 예시
(대상:사람~을~를) 돕~도우:움직씨 = { ... }
(대상:사람~을~를) 듣~들:움직씨 = { ... }
( ) 걷~걸:움직씨 = { ... }

// 정규 예시(별칭 불필요)
(대상:사람~을~를) 먹:움직씨 = { ... }
```

> 주: `먹 + (으)니 → 먹으니`는 **불규칙 교대가 아니라 “짝어미 선택” 결과**로 취급한다. 따라서 `먹~먹으` 같은 별칭을 요구하지 않는다.

#### 11.3.3 교대 트리거(기본) — MUST
어간 교대는 기본적으로 아래 결합에서 적용한다.
- (a) **모음으로 시작하는 어미**와 결합할 때 (`아/어`, `았/었`, `아서/어서` 등)
- (b) **모음 끼움 짝어미 계열**과 결합할 때
  - 정의: 받침 유무에 따라 `'으'` 등의 모음이 끼는 쌍
  - 예: `니/으니`, `면/으면`, `니까/으니까`, `며/으며`, `면서/으면서`

구현 메모: 트리거 판정은 **표면 문자열의 첫 글자**가 아니라, 어미 토큰의 **정본 분류(모음시작/짝어미계열)**에 의해 이뤄진다. 예를 들어 `-으며`처럼 첫 음절 초성이 `ㅇ`인 경우도 **모음시작**으로 취급한다.

**보수 규칙:** 트리거가 모호하거나 미지정이면 **교대를 적용하지 않는다**. (결정성/예측가능성 우선)

#### 11.3.4 정본 처리 파이프라인 — MUST (3-Step)
모든 움직씨(어간)와 형태소 결합은 아래 순서를 **엄격히** 따른다.

1) **어간 교대 (Stem Alternation)**
   - `~` 별칭과 트리거 규칙에 따라 어간을 확정한다.
   - 예: `돕` → `도우`

2) **어미 결정 (Suffix Selection)**
   - (a) **모음 끼움 짝어미 선택(으-끼움 쌍)**: 받침 유무에 따라 `니/으니`, `면/으면`, `니까/으니까` 등을 선택한다.
     - 예: `도우 + 니`, `먹 + 으니`
   - (b) **관형/미래 계열 쌍어미 선택(ㄹ/을)**: 받침 유무에 따라 `ㄹ/을(어미)`을 선택한다.
     - 예: `가 + ㄹ → 갈`, `먹 + 을 → 먹을`
   - (c) **아/어(및 았/었) 선택 규칙**: 어간의 어휘 규칙에 따라 `아/어`, `았/었` 등을 선택한다.
     - 예외는 태그/사전으로 관리한다(추측 금지).

3) **축약 및 표기 정리 + 후행 형태소 결합 (Contraction & Cleanup)**
   - 표면 출력 단계에서 관습적 축약/표기 규칙을 적용한다.
     - v0 핵심 예: `ㅣ+ㅓ→ㅕ`, `ㅜ+ㅏ→ㅘ`, `ㅗ+ㅏ→ㅘ`, `하+여→해`, `가+았→갔`
   - 필요 시 **후행 형태소(예: 종결 `다`)**를 결합한다.
     - 예: `갔 + 다 → 갔다`

#### 11.3.5 조사 vs 어미 구분 — MUST
- `을/를`은 **목적격 조사**의 쌍으로 취급하며, 도우미(LSP)는 받침 유무에 따른 교정/추천을 제공한다.
- `ㄹ/을`은 **관형/미래 계열 어미**의 쌍으로 취급하며, 파이프라인 2단계(어미 결정)에서 처리한다.
- 문법 위치로도 모호하면 추측하지 않고 **`:핀`(우선) 또는 `~조사`로 명시**하도록 요구한다. (`10.5 명시적 접미 접착자(@,: ,~)` 참조)

#### 11.3.6 관문 0 골든 데이터 — MUST
이 규칙의 최소 집합(먹/돌리/돕/듣/가/하 등) 표면화 결과는 **관문 0(DoD) 골든 데이터**로 고정한다.
- 기준 표는 `GATE0_IMPLEMENTATION_CHECKLIST §6.6`에 둔다.

(과거 설계의 `-서` 파이프/연결 표기는 **폐기**. 입력으로도 금지. `~기 해서`/`~하기 해서`만 허용한다.)

Gate0의 파이프는 **`~기 해서`/`~하기 해서`** 형태를 허용한다.  

```ddn
(값A)만들기 해서 (값B)바꾸기 해서 (값C)쓰기.
```

**[PIPE-CALL-ONLY-01] (MUST) 파이프 단계는 호출식(CallExpr)만 허용**
- 파이프(`...기 해서 ...` 또는 `...하기 해서 ...`) 체인의 각 단계는 반드시 **PinSpec(핀 명세)이 정의된 씨앗(움직씨/셈씨/일때씨 등)의 호출식**이어야 한다.
- `해서` 뒤에는 **식별자(씨앗 이름) + (필요 시) 인자 바인딩**만 올 수 있다.
- `+`, `-`, `*`, `/` 등 **연산자 기반 임의 표현식**을 `해서` 뒤에 직접 둘 수 없다. (예: `해서 + 1`, `해서 x + 1`)  
- 위반 시: **정본화 실패(컴파일 오류)**로 처리한다.

**대체 방법(허용):**
- 단순 산술/변환은 **표준 씨앗 호출**로 표현한다.
- 복잡한 식이 필요하면 `{ ... }해서`로 값으로 만든 뒤 다음 단계 호출로 넘긴다. (값을 변수로 들고 있어야 하면 `{ ... }한것`을 사용)

예:
```text
# OK: 단계마다 "호출식"만 사용
(10)만들기 해서 오른=5 더하기 해서 오른=2 곱하기.

# OK: 복잡식은 }해서로 값화 후 호출
  { (a + b) * 3 }해서 오른=1 더하기.   # OK: 복잡식은 }해서로 값화 후 호출

# NG: 연산자/임의식을 파이프 단계에 직접 배치
(10)만들기 해서 + 5 해서 곱하기.  // ❌ PIPE-CALL-ONLY-01
```

#### 11.4.1 흐름값(Flow Value) 결정 규칙 — MUST
- 체인은 **좌→우** 순서로 실행한다.
- 각 단계가 값을 반환하면, 그 값이 다음 단계의 흐름값이 된다.
- 단계가 `void`(반환 없음)이면, 흐름값은 **변하지 않고 유지**된다.

#### 11.4.2 핀 주입(Target Injection) 규칙 — MUST
- **명시 핀 우선:** 문장 안에서 핀(조사) 바인딩이 이미 제공되면 그것이 우선이다.
- 다음 단계 호출에서 **아직 채워지지 않은** 핀에만 흐름값을 주입할 수 있다.

주입 알고리즘(결정적):
1) 다음 단계가 목적격 핀(`~을/를`)을 정의하고, 그 핀이 미충족이면 → 흐름값을 그 핀에 주입한다.
2) 그렇지 않으면 → “첫 번째 미충족 필수핀”(PinSpec 선언 순서)을 찾아 흐름값을 주입한다.
3) 주입 후보가 2개 이상이면 → **오류** (사용자가 핀을 명시해야 한다)
4) 다음 단계의 필수핀이 이미 모두 채워져 있으면 → 주입하지 않는다. (흐름값은 유지되지만 무시될 수 있다)

#### 11.4.3 의미론: 결정적 스케줄링 — MUST
- 컴파일러/런타임은 파이프 단계의 실행/평가 순서를 바꿀 수 없다.
- 정본화기는 파서가 `...해서` 체인을 인식하면, 내부 IR에 단계 경계 및 주입 결과를 명시한다.

---

## 12. 알림/자원/목표 ID화 — MUST

### 12.1 정규화 규칙 (컴파일 타임)

모든 아래 항목은 정규화된 문자열을 기반으로 `u64` ID로 변환됩니다.

**대상:** 함수명, 시스템명, 컴포넌트명, 태그, 알림명, 목표명, 쓸감 경로

**규칙 순서:**
1. **공백 제거:** 모든 유니코드 공백 삭제 (Trim이 아님, 내부 공백도 전부)
2. **소문자화:** 영문 → 소문자 (`toLowercase`)
3. **NFC 정규화:** 유니코드 NFC

### 12.2 ID 생성 — MUST

- **알고리즘:** XXH3 64-bit
- **시드:** 0 고정
- **입력:** 정규화된 UTF-8 바이트

### 12.3 표준 ID 타입

```rust
IdentId: u64   // 식별자
SignalId: u64  // 알림
GoalId: u64    // 목표
쓸감번호: u64   // 쓸감
```

**런타임 문자열 비교 금지** — MUST

---

## 13. 출력 규칙: 상태 기반 — MUST

### 13.1 핵심 원칙

- **이야기(Iyagi)는 `print/draw` 같은 직접 출력을 호출하지 않는다** — MUST NOT
- **`"문장" 보여주기.`는 "출력 함수"가 아니라 컴포넌트 생성 Sugar** — MUST

### 13.2 표준 해석

```ddn
"안녕" 보여주기.
// → LogComponent(text="안녕") 생성 (Transient)
// → 보개가 관찰하여 화면/콘솔에 표현
// → 거울이 생성 사실 기록
```

### 13.3 컴포넌트 수명

| 분류 | 수명 | 예시 |
|------|------|------|
| **Transient** | 마디 종료 시 자동 삭제 | Log, Sound, VFX, Alrim |
| **Persistent** | 명시적 삭제까지 유지 | Position, HP, Emotion |

---

## 14. 다중 디스덧댐 — MUST

### 14.1 규칙

1. 후보가 여러 개면 **"가장 구체적인 타입"** 우선 — MUST
2. 구체성 동률(비교 불가 포함)이면 **컴파일 오류** — MUST
3. 선언 순서 기반 타이브레이크는 **금지** — MUST NOT

### 14.2 구체성 판정 알고리즘

```
타입 A가 타입 B보다 구체적 ⟺ A ⊆ B (A는 B의 부분집합)
```

**예:**
- `정수32` > `수` (정수32는 수의 부분집합)
- `플겹` > `엔티티` (플겹은 엔티티의 부분집합)
- `정수32` vs `정수64` → 비교 불가 (동률)

### 14.3 애매모호 처리

```ddn
// 두 후보:
A:정수32 +  B:정수32  // 후보 1
A:정수64 +  B:정수64  // 후보 2

// 호출:
(10 + 20)  // 10, 20의 타입이 정수32라면 → 후보 1 선택
```

**애매한 경우:**
```ddn
A:정수32 +  B:정수64  // 후보 1
A:정수64 +  B:정수32  // 후보 2

// 호출:
(x:정수32) + (y:정수64)  // 어느 후보도 더 구체적이지 않음 → 컴파일 오류
```

---

## 15. 비목표 (Non-Goals) — MUST

- 이 언어/엔진은 **클래스/상속 기반 OOP를 표준 패러다임으로 채택하지 않는다**
- 상태는 Nuri(ECS)로, 행위는 Iyagi(System)로 모델링한다
- "객체"라는 단어는 교육적 편의를 위해 사용될 수 있으나, 컴파일/런타임 모델은 ECS를 기준으로 한다
- **Rust식 고유권/빌림검사(borrow checker)** 는 AGE0의 비목표다.
  - 대신 AGE0~AGE2에서는 **Patch/Commit(부수효과 격리)** 와 **지킴이/diag**로 안전성을 확보한다.
  - 정적 빌림검사(예: 바탕 단위 읽기/쓰기 집합 선언)는 AGE3+에서 별도 기능으로 검토한다.

---

## 16. 검사 훅: `늘지켜보고` — MUST

### 16.1 목적

커밋이 일어나기 전에 **불변식(invariant)**을 검사하고, 위반 시 커밋을 거부한다.

**예:** "HP는 0 미만이 될 수 없다", "재고는 음수가 될 수 없다", "좌표는 월드 경계 밖으로 나갈 수 없다"

### 16.2 문법 — MUST

```ddn
(조건) 늘지켜보고 {
    // 검사 로직
}
```

### 16.3 실행 시점 — MUST

마디 파이프라인에서 **Patch가 생성된 뒤, Commit 직전**에 실행한다.

```
Stage 3: 시스템 실행 (Patch 생성)
  ↓
Stage 3.5: 늘지켜보고 평가  ← 여기
  ↓
Stage 4: Commit (Patch 적용)
```

엔진은 검사를 위해 "가상 적용된 다음 상태 $S'_n$"를 내부적으로 구성할 수 있다(MAY).

### 16.4 제약 (읽기 전용) — MUST

검사 블록 내부에서는 다음이 **금지**된다:

- 상태 변경 연산자 `<-` 사용 — MUST NOT
- 외부 I/O (파일/네트워크/시간/난수/호스트 호출) — MUST NOT
- 다음 마디 예약/명령 큐 삽입 — MUST NOT

**허용**되는 것:
- 현재 상태/가상 다음 상태의 읽기
- `단언(assert)` / `중단(panic)` / `"사유" 덧댐거부`

### 16.5 거부/실패 정책 — MUST

**`"사유" 덧댐거부` 호출 시:**
- 해당 마디의 Commit을 수행하지 않는다 — MUST
- Patch를 폐기하고 $S_0$를 유지한다 — MUST
- Audit에 거부 사유를 기록한다 — SHOULD

**`중단(panic)` 호출 시:**
- 즉시 마디/실행을 중단한다 — MUST

### 16.6 예시

```ddn
// HP는 절대 음수가 될 수 없음
(플겹.HP < 0) 늘지켜보고 {
    "HP가 음수가 될 수 없습니다" 덧댐거부.
}

// 월드 경계 검사
(플겹.x < 0 || 플겹.x > 1000) 늘지켜보고 {
    "플겹이 월드 밖으로 나갔습니다" 중단.
}
```

---

## 17. 말결/퍼지 토큰 — MUST

### 17.1 목적

`$꽤`, `$매우` 같은 부사 토큰을 0~1 퍼지 가중치로 매핑한다.

### 17.2 문법

```ddn
$부사 동사.
```

**허용 위치:**
- 움직씨의 호출 앞
- 형용사 앞
- 이름씨의 정의 내부 (감정/태도 표현)

### 17.3 표준 가중치 매핑 — MUST

| 토큰 | 가중치 | 의미 |
|------|:------:|------|
| `$전혀` | 0.0 | 완전 부정 |
| `$거의 안` | 0.1 | 미미 |
| `$약간` | 0.2 | 아주 약함 |
| `$조금` | 0.3 | 약함 |
| `$반쯤` | 0.5 | 중간 |
| `$꽤` | 0.7 | 상당 |
| `$매우` | 0.9 | 강함 |
| `$완전` | 1.0 | 최대 |

### 17.4 사용 예시

```ddn
$꽤 화나다.          // Emotion.arousal +<- 0.7
$매우 좋아하다.      // Relation.value +<- 0.9
$조금 걱정하다.      // Emotion.valence -<- 0.3
```

### 17.5 결합 규칙 — MUST

- 말결 토큰이 없으면 기본값 **0.5** 사용
- 같은 문장에 여러 말결 토큰이 있으면 **마지막 것** 적용
- 부정어(`안`, `못`)와 결합 시 부호 반전

**예:**
```ddn
$매우 안 좋아하다.   // Relation.value -= 0.9 (부호 반전)
```

### 17.6 확장성 — MAY

사용자 정의 말결 토큰:
```ddn
말결 살짝 = 0.2.
말결 아주 = 0.95.
```

---

## 18. GOAP 목표 어미: `-도록/-게` — MUST

### 18.1 목적

GOAP (Goal-Oriented Action Planning) 스타일의 목표 설정을 언어 레벨에서 지원.

### 18.2 문법

```ddn
(대상)을 (목표)하도록.
(대상)을 (목표)하게.
```

**차이:**
- `-도록`: 일반 목표
- `-게`: 즉시 목표 (우선순위 높음, MAY)

### 18.3 의미론 — MUST

```ddn
(적)을 처치하도록.
```

**효과:**
1. `GoalComponent(GoalId("적처치"), target=적)` 생성
2. 외부 플래너 또는 AI(슬기)가 관찰
3. 플래너가 행동 시퀀스를 생성하여 샘에 주입

### 18.4 외부 플래너 연동 — SHOULD

```rust
// 외부 GOAP 플래너 인터페이스
trait GOAPPlanner {
    fn plan_for_goal(&self, goal: GoalId, nuri: &NuriWorld) -> Vec〈SeulgiIntent〉;
}
```

**권장 플로우:**
1. Nuri에 GoalComponent 등록
2. Seulgi(또는 독립 플래너)가 관찰
3. 플래너가 행동 시퀀스 생성
4. Sam을 통해 SeulgiIntent로 주입

### 18.5 예시

```ddn
// 복합 목표
(플겹)가 (레벨10)이 되도록.
(인벤토리)에 (검)이 있도록.

// 조건부 목표
(HP < 30) 일때 {
    (플겹)를 안전지대로 이동하도록.
}
```

---

## 19. 한국어성: 어순과 생략 — SHOULD

### 19.1 어순의 자유 — 인자 순서

#### 19.1.1 원칙

네임드 바인딩 사용 시 인자 순서는 자유롭다.

```ddn
A=10 B=20 더하기.
B=20 A=10 더하기.  // 동일
```

#### 19.1.2 인자 순서가 자유로운 경우

- 네임드 바인딩
- 조사 바인딩 (조사가 유일하게 매핑되는 경우)

#### 19.1.3 순서가 고정된 경우

- 위치 바인딩
- 조사가 애매한 경우

### 19.2 생략 규칙 — 옵션 A 채택 (안전) — SHOULD

#### 19.2.1 옵션 A: 생략 금지 (가장 안전)

컴파일 타임에 모든 인자를 명시해야 한다.

```ddn
이동하고  // 오류! 대상이 누구?
```

**예외:** 기본값이 있는 매개변수

#### 19.2.2 기본값 매개변수

```ddn
(대상:엔티티~을~를, 속도:수~로~으로 = 1.0) 이동:움직씨 = { ... }

// 호출
(철수) 이동하기.           // 속도=1.0 (기본값)
(철수, 속도=2.0) 이동하기.  // 속도=2.0 (명시)
```



##### 19.2.2.1 선택적 인자·기본값 규칙 — MUST

**목표:** 생략 여부가 플랫폼·도구·사람의 추측에 좌우되지 않도록, *정본(AST) 단계에서* 완전히 결정적으로 처리한다.

- **기본값이 있는 인자**
  - 서명에서 `= 〈기본값〉`이 붙은 인자는 **호출 시 생략 가능(선택적)** 이다.
  - 정본화기는 생략된 인자에 대해 **즉시 기본값 리터럴을 주입**하여 정본 AST에 고정한다.
  - 따라서 실행 단계에서는 “기본값 계산”이 존재하지 않으며, 해시/리플레이에도 기본값이 포함된다.

- **기본값이 없는 선택적 인자**
  - 조사에 `?`가 붙은 인자(예: `대상~을~를?`)는 호출 시 생략될 수 있다.
  - 생략된 경우 정본화기는 해당 값을 **`없음`으로 정규화**한다.
  - 타입 표기는 `T?`로 간주한다. (예: `임자?`, `수?`)

- **규칙 충돌 방지(서명 배치)**
  - `= 〈기본값〉`이 있는 인자는 **인자 목록의 끝(오른쪽)** 에만 둘 수 있다.
  - 정본화기는 “중간 기본값 + 뒤에 필수 인자” 패턴을 **오류**로 처리한다.  
    (위치 바인딩 혼선을 방지하기 위함)

- **결정성 규칙**
  - 기본값은 **상수 리터럴**이어야 하며(고정64/수/글 등), 런타임 상태(누리)나 시간(벽시간/마디시간)에 의존해 계산되면 안 된다.
  - 기본값이 `고정64`인 경우, 내부 저장은 `Fixed64(raw_i64)`로 확정되어야 한다.

### 19.3 옵션 B/C는 후속 버전으로 보류

- 옵션 B: 기본 주어/기본 대상 컨텍스트 (제어된 생략)
- 옵션 C: 통계적/휴리스마디 추론 (금지 권고)

---


## 20. 표준 패턴 갤러리

> 이 절의 예제는 `SSOT_REFERENCES.md`의 **§E1 표준 패턴 갤러리**로 이동했습니다.
> (정본 규칙은 본문에, 데모/검증/갤러리 예제는 REFERENCES에 둔다.)

## 21. 구현 체크리스트

구현 단계별 체크리스트와 일정은 규범이 아니라 개발 계획이므로 별도 문서(예: `SSOT_PLANS`, `SSOT_ROADMAP_CATALOG`)로 관리한다.
이 문서에서는 무엇이 규범인지(정의/MUST/SHOULD/MAY)만 유지한다(MUST).


## 22. 참고 자료 (References)

### 22.1 관련 언어/시스템

- **F#:** 단위 시스템 (Units of Measure)
- **Rust:** 소유권, ECS (bevy_ecs), 타입 시스템
- **Haskell:** 순수 함수, 타입 클래스
- **Julia:** 다중 디스덧댐
- **Excel:** 리액티브 스프레드시트 (흐름씨 영감)
- **GOAP:** Goal-Oriented Action Planning (목표 어미)

### 22.2 ECS 참고 구현

- bevy_ecs (Rust)
- EnTT (C++)
- flecs (C)

### 22.3 결정론 참고

- Lockstep Networking
- Deterministic Lockstep (RTS 게임)
- Fixed-Point Math Libraries

---




## 23. 누리 쿼리 (Nuri Query) 및 군집 제어

### 16.1 목적과 원칙 (MUST)

**[QRY-01] (MUST) 전수 스캔 금지**  
런타임은 모든 엔티티를 순회하며 조건을 검사하는 방식을 엄격히 금지하며, 반드시 **아키타입(Archetype) 인덱싱**을 사용해야 한다.

**[QRY-02] (MUST) 결정적 정렬**  
쿼리 결과는 항상 `(realm_id, entity_id)` 오름차순으로 정렬되어 반환되어야 한다.

### 16.2 쿼리 표현식과 필터 (MUST)

**문법:**
```ddn
집합변수 = (조건1, 조건2, ...) 임자들.
```

**필터 규칙:**
- **이름씨/알 포함:** `이름씨`, `#알` — 해당 컴포넌트나 태그를 가진 임자 선택
- **이름씨/알 제외:** `!이름씨`, `!#알` — 해당 컴포넌트나 태그가 없는 임자 선택
- **순수 술어:** `(필드 > 값)` — 결정론적 수치 비교만 허용, 상태 변조(`<-`) 금지

**예시:**
```ddn
가동로봇들 = (카트폴, !#고장) 임자들.
```

### 16.3 군집 실행 블록 (MUST)

#### A. 모두 (ForEach)
```ddn
가동로봇들 모두 { 
  // 현재 임자 = (나)
  (1)만큼 보상.
}
```

- `모두`는 결과 집합의 각 임자에 대해 블록을 실행
- 블록 내부의 기본 대상은 `(나)`

#### B. 첫째/마지막 (선택)
```ddn
첫놈 = 가동로봇들 첫째.
막놈 = 가동로봇들 마지막.
```

#### C. 개수
```ddn
수 = 가동로봇들 개수.
```

### 16.4 스냅샷 의미론 (Snapshot Semantics) — MUST

**[QRY-03] (MUST) 멤버십 고정**  
쿼리의 결과 집합은 해당 실행 단계(Phase) 시작 시점에 고정된다. 실행 도중 컴포넌트가 추가/삭제되어도 현재 루프의 대상 목록은 변하지 않으며, 다음 평가 시점에 반영된다.

### 16.5 구현 요구 사항 (MUST)

**[QRY-IMPL-01] (MUST) 아키타입 인덱싱**  
내부 구현은 "아키타입 인덱싱/비트셋 교집합"을 표준으로 한다.  
예외: 디버그 모드에서만 전수 스캔 fallback 허용 (단, 결과 순서 규칙은 동일).

---

## 24. Fixed64 산술 안전 및 결정론적 오류 전이

### 17.1 원칙 (D-STRICT 산술) — MUST

**[MATH-PRINCIPLE-01] (MUST)**  
런타임은 **예외(Exception)로 흐름을 깨지 않는다.**

모든 산술 오류는:
1. **결정적 값**(Saturated/Clamp/Zero 등)으로 귀결되고,
2. **결정적 고장 기록**(Fault)로 남으며,
3. 필요 시 **알림**로 외부에 알릴 수 있다.

### 17.2 고장(Fault) 표준 구조 — MUST

**[MATH-FAULT-01] (MUST)**  
엔티티(임자)에 "고장 상태"를 붙일 수 있는 표준:

```ddn
(종류:고장종류, 연산:고장연산, 발생마디:수?) 고장:이름씨 = { }.
```

최소 구현(M1)에서는 `#고장` 알만 붙여도 되며, 고장 세부는 `LogComponent`로 남겨도 된다.

### 17.3 산술 규칙 (핵심 4연산) — MUST

#### A. 덧셈/뺄셈 (Add/Sub)

**[MATH-ADD-01] (MUST) 포화 산술**  
오버플로 발생 시:
- 양의 오버플로 → `Fixed64::MAX`
- 음의 오버플로 → `Fixed64::MIN`

**[MATH-ADD-02] (MUST) 고장 기록**  
- `#오버플로` 고장 + 경고 로그 1건 (결정적)

#### B. 곱셈 (Mul)

**[MATH-MUL-01] (MUST)**  
중간 곱이 범위를 벗어나면 **포화 산술**로 귀결. 고장 기록 동일.

#### C. 나눗셈 (Div)

**[MATH-DIV-01] (MUST) 0으로 나누기**  
`0으로 나누기`는 **복구 불가능 오류**로 취급.

규칙:
- 결과값은 **0**으로 귀결 (결정적)
- **해당 대입(`<-`)은 무효화** (MUST)
  - 즉, `x <- a / 0`은 `x`를 바꾸지 않는다.
- 실행 주체 엔티티에 `#고장`을 부착
- `(#산술고장)` 알림을 **알리기**도 된다 (권장: 디버깅/학습)

> **근거:** "0으로 나누기인데 값이 바뀌는 것"은 디버깅 지옥이 되기 쉬워서, v14.0에서는 **대입 무효화**를 표준으로 고정.

### 17.4 DetMath 함수 (삼각함수 등)의 결정론 — MUST

**[MATH-DET-01] (MUST)**  
`sin/cos/tan` 등은 부동소수점 호출 금지.


**[MATH-DET-01A] (MUST NOT) 호스트/부동소수점 수학 API 직접 호출**  
다음 연산은 플랫폼(FPU/표준 라이브러리/FFI)의 **직접계산 호출을 금지**하며, **오직 DetMath 표준 함수**로만 제공/사용한다.  
- `sin/cos/tan` (및 역삼각 `asin/acos/atan`, `atan2`)
- `sqrt` (제곱근)
- `exp` / `ln` / `log` (지수·로그)
- `pow` (거듭제곱; 정수 전용 최적화가 아닌 일반 `pow` 호출 포함)
> DetMath의 LUT 쓸감(.dtm) 규격/무결성/로드 정책(없으면 구동 거부)은 `SSOT_TOOLCHAIN §T6.1.1`을 따른다(MUST).

표준:
- LUT(룩업 테이블) + 결정적 보간 기반
- 입력/출력은 Fixed64


**[MATH-DET-01B] (MUST) DetMath 차림새 선택(빠름/정밀)**  
DetMath 함수는 “차림새(알고리즘/쓸감/보간 규칙의 묶음)”을 선택할 수 있다. 차림새는 TOOLCHAIN `§T6.5`에서 **쓸감 해시/규칙이 핀**되어야 하며, 런타임 폴백은 금지한다.

- **차림새 값(정본 리터럴)**: `#빠름` | `#정밀`
- **기본값**: 차림새 인자를 생략하면 `#빠름`으로 정본화한다.
- **가용성**:
  - `#정밀`이 **제공되지 않는** 런타임/가지 구성에서 `#정밀`을 요구하면 **로드/빌드 오류**로 실패한다(MUST).
  - 어떤 경우에도 `#정밀` → `#빠름`으로의 **묵시적 폴백은 금지**한다(MUST NOT).

**표면 예시(개념):**
```ddn
각도 = 30@도.

// 기본: #빠름
y1 = (각도=각도) 사인하기.

// 명시: #정밀
y2 = (각도=각도, 차림새=#정밀) 사인하기.
```

**[MATH-DET-02] (MUST) 도메인 오류**  
예: `(값=음수) 제곱근하기`
- 결과는 **0으로 귀결**
- 해당 대입은 **무효## 25. Reactive 루프 한도 및 전파 제한 — MUST

> 목표: “알리기 → 같은 마디 내 반응”을 제공하면서도, 무한 전파/재귀로 세계가 멈추는 것을 방지한다.

### 25.1 문제 정의

알림(이벤트)은 강력하지만, 다음 같은 “서로를 깨우는” 패턴이 생기면 한 마디가 끝나지 않을 수 있다.

```ddn
(#A)할때 { (#B) 알리기. }.
(#B)할때 { (#A) 알리기. }.
```

따라서 Reactive(반응) 단계에는 **반복 상한**과 **결정적 실행 규칙**이 필요하다.

### 25.2 실행 모델: Update + Reactive(패스 루프)

한 마디는 크게 2단계로 처리된다.

1) **Update 단계**
- `(매마디)마다 { ... }` 시스템들을 결정적 순서로 실행한다.
- Update 단계에서 발생한 알림은 “알림 큐”에 append 된다. (`알리기`)

2) **Reactive 단계**
- Update 커밋 직후 시작한다.
- “알림 큐가 빌 때까지” **패스(pass)** 를 반복한다.

### 25.3 한 번의 Reactive 패스 규칙 — MUST

패스 번호를 `k = 1, 2, ...`라 하자.

- 패스 `k`는 **패스 시작 시점의 큐 스냅샷**만 처리한다.  
  (패스 `k` 중에 새로 발생한 알림은 큐 끝에 append 되지만, **패스 `k+1`**에서 처리된다.)
- 처리 순서는 다음을 MUST로 한다.
  1) 알림 태그(SignalId) 오름차순
  2) 같은 태그 안에서는 발생(append) 순서 유지
- 각 알림 항목에 대해:
  - 매칭되는 `(... )할때` 훅들을 결정적 정렬(8.4) 순서로 모두 실행한다.

### 25.4 상한: `ReactiveMaxPass` — MUST

Reactive 패스 수에는 상한이 있다.

- 설정: 프로젝트/세상 명세(World Manifest, 권장 파일: `ddn.world.json`)에서 `limits.reactive_max_pass`로 설정 가능
- 기본값: 구현체 기본(예: 8) — 구현체 문서화 MUST
- `ReactiveMaxPass`를 초과하면:
  - 기본 정책: **런타임 중단(에러)** MUST  
  - 선택 정책: “진단 알림(#반응고장)”을 1회 발생시키고, 이후 알림을 버린다 MAY  
    (단, 결정적이어야 한다.)

### 25.5 전파 제한(Propagation) — SHOULD

대규모 프로젝트에서 “알림 폭주”를 줄이기 위해, 다음을 권장한다.

- 상태 변화는 가능하면 **바탕(상태)** 으로 표현하고,
- 알림은 “상태 변화의 원인/경계”만 나타내는 **희소한 신호**로 쓰기.
- 빈번한 반복 알림은 전용 스트림(`흐름씨`)로 옮기기.

Reactive cascade limit reached");
}
```

---

## 26. 쓸감 리터럴 및 @ 기호 용도 명확화

### 19.1 문제 상황

`@` 기호를 **단위 표기**와 **쓸감 리터럴** 두 용도로 사용하면 렉서/파서 충돌 발생.

**예시:**
- `10@m` (10 미터) — 단위 postfix
- `@"캐릭터/주인공.png"` — 쓸감 경로?

### 19.2 확정 규칙 (MUST)

> 용어: 여기서 말하는 `쓸감.`은 영어 **쓸감(에셋/파일)** 개념이다. PLATFORM의 **터바탕씨(Resource)** 와는 다른 층위이므로 혼동하지 않는다.

**[ASSET-01] (MUST) 표준 표기**  
쓸감(쓸감) 참조의 정본 표기는 **`"경로" 쓸감.`**이며, 결과로 **쓸감핸들**을 돌려준다.

**[ASSET-02] (MAY) 문법 설탕**  
`@"경로"`는 문법 설탕이며 컴파일 타임에 `"경로" 자원`로 치환된다.

**[ASSET-03] (MUST) 쓸감 리터럴은 문자열만**  
쓸감 리터럴은 반드시 `@"..."`(문법 설탕) 또는 `"..." 자원`(정본)이어야 한다.  
- `@식별자`는 **쓸감 리터럴이 아니다**. (이는 `숫자@단위`의 **단위 접착자** 형태로만 유효)

**[UNIT-01] (MUST) 단위 전용**  
단위 표기는 `숫자@단위` postfix로만 사용한다.

### 19.3 예시

**올바른 사용:**
```ddn
// 표준 (MUST)
주인공.생김새 <- "캐릭터/주인공.png" 쓸감.

// 문법 설탕 (MAY)
주인공.생김새 <- @"캐릭터/주인공.png".

// 단위
거리 = 10@m.
시간 = 3.5@초.
```

**금지된 사용:**
```text
// ❌ 식별자 형태
주인공.생김새 <- @캐릭터/주인공.png  // 컴파일 에러
```

---

## 27. PinSpec + 곳간(Registry) 상세

### 27.1 PinSpec 표준 (MUST)

**[PINSPEC-01] (MUST)**  
함수 시그니처의 **정본(문서표기)**은 DdoniLang 코드 문법과 동일하게 쓴다:

```
(인자명:타입~조사들?, ...) 말이름
```

**예시:**
```ddn
(대상:임자~을~를, 방향:벡터~로~으로, 속도:수~로~으로?) 움직이기.
```

- `?`는 생략 가능한 인자

- **옵션 핀(?)의 의미 (정본, MUST):**
  - `핀?`은 *호출 시 생략 가능*을 뜻한다.
  - 기본값이 **명시**되어 있으면(`=기본`), 생략 시 그 기본값이 주입된다. *(이 경우 핀의 타입은 그대로 `T`)*  
  - 기본값이 **없으면**, 생략 시 값은 `없음`으로 주입되고 핀의 타입은 자동으로 `T?`로 승격된다. *(함수 본문에서 `없음`을 처리해야 함)*

**예시(명시 기본값):**
```ddn
(감정:글~로~으로? = "기본") 말하기.
```

**예시(없음으로 처리):**
```ddn
(감정:글~로~으로?) 말하기.
감정 ~에 따라 {
  없음이면 { "기본"을 써. }
  글(값)이면 { 값으로 써. }
}.
```
- 조사 목록은 해당 인자에 허용되는 조사들
- `@`는 **단위/쓸감 표기**(호출/표기)에서만 쓰는 접착자이며, PinSpec(정의부)에는 등장하지 않는다.
- 핀 고정은 호출 인자 접미 `:핀`으로만 쓴다.
- PinSpec의 조사 표기는 `~`로만 쓴다.

**[PINSPEC-NAME-01] (MUST)** 핀 이름 충돌 금지
- 핀 식별자는 `@`, `:`, `~`를 포함할 수 없다.
- 핀 이름은 **단위 식별자(UnitRegistry)** 및 **조사 식별자(ParticleRegistry)** 와 동일하면 안 된다. (예: `m`, `cm`, `을`, `에서` 등)
- 충돌이 필요해 보이면, 핀 이름을 바꾸거나(예: `거리m`), 호출에서 `:핀` 고정을 사용하라.


**[PINSPEC-OPT-01] (MUST)**  
옵션 핀(`?`)은 호출에서 생략할 수 있다. 생략 시 정규화 규칙은 다음과 같다.  
- `= 기본값`이 있으면 **기본값을 주입**한다.  
- 기본값이 없으면 **`없음`으로 정규화**한다. (의미적으로 `T?`)  

**[OPTION-USE-01] (MUST)** 옵션 값 사용 시 ‘없음’ 처리 강제  
`T?`(예: `글?`, `수?`, `임자?`)는 그대로 `T`가 필요한 위치에 쓸 수 없다.  
- `태그:글?`를 `글` 자리(필수 핀/필드)에 넣으면 **컴파일 에러**  
- 아래 중 하나로 **반드시** ‘없음’ 케이스를 처리해야 한다:  
  1) `없으면` 설탕: `태그값 = 태그 없으면 "기본".`  
  2) 분기(`~에 따라`):  
     ```ddn
     태그값 = 태그에 따라 {
       없음이면 "기본"
       글(값)이면 값
     }.
     ```



### 27.1.1 갈래 분기: `~에 따라` — MUST

`~에 따라`는 **갈래형(합 타입)** 값을 안전하게 분해하여 경우별로 처리하는 **정본 제어 구조**다.

- 대상: `T? (= T | 없음)`, `참거짓(참|거짓)`, `고름씨(#태그 …)` 등 **유한(닫힌) 경우의 수**를 가진 타입
- 목적: (1) **없음 처리 강제**, (2) **정적 완전성 검사**, (3) **AOT 점프 테이블**로 고성능 분기

#### 27.1.1.1 문법(정본) — MUST

정본 문법은 **바깥 블록 `{ }`를 반드시 사용**한다. (들여쓰기는 가독성일 뿐, 문법이 아니다)

```text
〈식〉에 따라 { 〈가지〉+ }

〈가지〉 ::= 〈패턴〉이면 〈몸〉
         | 아니면 〈몸〉           // 기본 가지(= 와일드카드). 최대 1개, 반드시 마지막

〈몸〉   ::= 〈식〉                  // 단일 식(값)
         | { 〈문장들〉 }          // 블록. 마지막 식이 값이 된다(§6.1의 “마지막 식 반환” 규칙)

〈패턴〉 ::= 없음                  // 옵션의 없음, 또는 고름씨의 없음 변형
         | _                     // 와일드카드(= 아무거나). 반드시 마지막(아니면과 동일)
         | 〈리터럴〉              // 참, 거짓, 0, "문자열" 등
         | 〈타입이름〉(〈이름〉)     // 옵션/유니온의 “값” 가지. 〈이름〉은 바인딩 변수
         | #〈태그〉(〈이름들〉?)     // 고름씨 태그 패턴(필드 순서 바인딩)
```

**예시(옵션 `글?`):**
```ddn
태그값:글 = 태그에 따라 {
  없음이면 "기본"
  글(값)이면 값
}.
```

**예시(고름씨/태그):**
```ddn
상태에 따라 {
  #대기이면 { ... }
  #공격(대상)이면 { ... }
  아니면 { ... }
}.
```

#### 27.1.1.2 바인딩/스코프 규칙 — MUST

**[MATCH-BIND-01] (MUST)**  
`타입이름(이름)` 또는 `#태그(이름들)`에서 괄호 안 이름은 **해당 가지의 지역 바인딩**이다.

- 바인딩은 **해당 가지의 몸(ArmBody) 안에서만** 보인다.
- 가지 밖에서는 참조할 수 없다(컴파일 에러).
- 다른 가지에서 같은 이름을 써도 된다(가지마다 스코프가 다름).

**[MATCH-BIND-02] (MUST)**  
바인딩된 이름의 타입은 패턴이 가리키는 실제 페이로드 타입으로 고정된다.

- `글(값)`이면 `값:글`
- `#공격(대상)`이면 `대상:〈그 태그의 필드 타입〉`

#### 27.1.1.3 타입 규칙 — MUST

**[MATCH-TYPE-01] (MUST)**  
`E에 따라 { ... }`에서 `E`의 타입은 **갈래형**이어야 한다. 갈래형이 아니면 컴파일 에러.

갈래형의 최소 집합(v15):
- `T?` (옵션)
- `참거짓`
- `고름씨` (유한 태그 집합)

**[MATCH-TYPE-02] (MUST)**  
각 가지의 패턴은 `E`의 타입과 **호환**되어야 한다. (불가능한 패턴은 컴파일 에러)

#### 27.1.1.4 완전성/중복 규칙 — MUST

**[MATCH-EXHAUST-01] (MUST)**  
`~에 따라`는 **항상 완전(Exhaustive)**해야 한다.  
아래 중 하나를 만족해야 한다:

- 모든 변형(variant)을 명시적으로 다룬다, 또는
- `아니면`(혹은 `_이면`) 가지가 존재한다

**[MATCH-OVERLAP-01] (MUST)**  
서로 겹치는 패턴(한 값이 두 가지에 동시에 매칭)은 **금지**한다.  
겹침이 있으면 컴파일 에러. *(점프 테이블 사전 계산을 위해)*

**[MATCH-ORDER-01] (MUST)**  
`아니면`/`_`는 반드시 **마지막 가지**여야 한다. 그렇지 않으면 컴파일 에러(도달 불가 코드).

#### 27.1.1.5 반환 타입 규칙 — MUST

`~에 따라`는 **식(Expression)**이며 결과 타입 `R`을 가진다.

**[MATCH-RET-01] (MUST)**  
모든 가지의 `〈몸〉`은 하나의 결과 타입 `R`로 **합쳐질 수 있어야** 한다.  
v15에서는 다음만 허용한다:

- 전부 같은 타입이거나,
- 숫자 타입 승격 규칙(§5.2~§5.3)에 의해 같은 `수` 계열로 승격 가능한 경우

그 외(예: 한 가지는 `글`, 다른 가지는 `없음`)는 컴파일 에러.

> 참고: `움직씨` 안에서도 `~에 따라`를 쓸 수 있으며, 결과 값을 사용하지 않으면 단순히 버려진다.

#### 27.1.1.6 설탕 구문: `없으면` — MUST

**[COALESCE-01] (MUST)**  
`X 없으면 Y`는 옵션 결합 설탕이며, 아래로 정본화된다.

- 전제: `X:T?`, `Y:T` (타입 호환)
- 정본화:
  ```text
  X에 따라 {
    없음이면 Y
    T(값)이면 값
  }
  ```

`X`가 옵션 타입이 아니면 컴파일 에러.

**[SPACING-01] (MUST)**

#### [DOT-ACCESS-01] 공백 없는 마침표는 멤버 접근 토큰이다 — MUST
- `임자.부품`, `바탕.중력`, `샘.마우스.위치`처럼 **공백 없이 이어진 `.`**는 **멤버 접근(Property Access)**이다.
- **문장 종결 `.`**은 반드시 **어절 끝(공백/줄끝/주석 앞)**에서만 인정한다.
  - 예: `바탕.중력 <- 9.8@mps^2.` (첫 `.` = 접근, 마지막 `.` = 종결)
  - 예: `바탕.중력.` (마지막 `.` = 종결, 앞 `.` = 접근)
- 렉서는 `NAME '.' NAME` 패턴의 `.`를 `PROPERTY_ACCESS`로 토큰화한다.

 (MUST)** 소스 띄어쓰기 규칙(정본)  
또니랑 소스(`.ddn`)는 **어절/토큰 경계를 띄어쓰기**로 명확히 한다.  
- `사과를 먹기.` ✅  
- `사과를먹기` ❌ *(문법 오류: 경계 미표시)*  
- 예외: 접미 접착자(`@`, `:`, `~`)는 **어절 내부 경계**를 강제로 고정한다. 예: `사과~를 먹기.` ✅

**[SPACING-02] (MAY)** 편집기 회복 모드(진단 전용)  
IDE/LSP는 사용자 입력 단계에서 `사과를먹기` 같은 붙여쓰기를 **진단 목적으로만** 임시 분해할 수 있다.  
- 이 분해는 **표시(overlay)**이며, 파일 내용을 자동 변경하지 않는다.
- 동일하게, 접미 접착자(`@`, `:`, `~`)도 **Ghost/Overlay 제안**으로만 표시할 수 있으며(클릭-고정), 사용자가 수락하기 전에는 소스가 바뀌지 않는다.  
- 컴파일/빌드는 **반드시 실패**해야 하며, LSP가 **빠른 수정(띄어쓰기 삽입)**을 제안한다.

**[SPACING-03] (MAY)** 저장 시 정본화(사용자 승인)  
사용자가 *정본화(Format/Normalize on Save)*를 켠 경우에만, 저장 시 정본 띄어쓰기 표기로 교정할 수 있다.  
- 항상 **차분 미리보기 + 되돌리기**를 제공한다.



### [JOSA-SPLIT-01] 조사 접미사 자동 분리 (Gate0 MUST)

`~`는 조사 경계를 **명시**하는 최강의 표지이지만, 학습자·현장 입력을 위해 **`~` 없이도** `사과를 먹기.` 같은 문장을 허용한다.  
이를 위해 Gate0 파서/정본화기는 아래의 **결정적(Deterministic) 분리 규칙**을 따른다.

- **조사 목록(초기 Gate0):** `을/를`, `이/가`, `은/는`, `에`, `에서`, `에게`, `으로/로`, `의`, `와/과`, `랑/하고`, `부터/까지`, `마다`, `만`, `도`
  - **Q5 요약:** 네, 움직씨/셈씨/사용자 DSL에서 **새 조사(핀 조사)**를 만드는 건 자유롭게 가능하다. 다만 Gate0 자동 분리 목록 밖의 조사는 **반드시 `~`로 경계를 드러내고**, 가능하면 `곳간(Registry)`에 등록해 IDE/파서가 안정적으로 역조회하도록 한다.

  - (목록은 Gate0에서 **자동 분리용으로 고정**. 다만 프로젝트/사용자 DSL에서 새 조사를 쓰는 것은 허용하되, 그 경우 **`~`로 경계를 명시**해야 한다. 자동 분리 목록 자체를 확장하는 것은 Minor로만 허용)

- **해석 우선순위 (한 어절 W에 대해):**
  1. **명시 경계가 있으면 우선:** `이름~조사` 형태는 항상 그대로 해석한다.
  2. **전체 어절 이름 우선:** `~`가 없고, W가 **현재 스코프에서 유효한 이름씨**로 해석 가능하면(선언/바인딩 존재) **W를 이름씨로 채택**한다. (조사 분리하지 않음)
  3. **접미사 분리 시도:** W의 끝이 조사 목록과 일치하면, 접미사를 떼어낸 앞부분 S를 만든다.
     - S가 이름씨로 해석 가능하면 → **`S~조사`로 해석**한다.
     - S가 불가능하면 → W 전체를 이름씨로 해석한다. (이름 미정이면 일반 오류)
  4. **강제 규칙:** 사용자가 **조사 해석을 강제**하려면 언제나 `~`를 쓴다. (`사과~를`, `도~로`)

- **정본화 출력:** 3번 규칙으로 조사 분리가 발생한 경우, 정본화기는 **반드시 `~`를 삽입**하여 `사과~를 먹기.` 형태로 출력한다.

- **린트(권고):**
  - `사과를`처럼 조사 접미사가 붙어 보이는 이름씨를 **선언**하려면, 동일 스코프에 `사과`가 존재할 때 오해 위험이 크다. 이 경우 린트는 “조사로 오해될 수 있음” 경고를 낸다.


#### 27.1.1.a 커스텀 조사/합성 조사 처리 (예: `~를할라고`)

- 목표: **한국어 자연스러움**을 최대한 살리되, **Strict(결정성) 파싱**을 깨지 않고, **Loose(느슨한) 입력**도 지원한다.
- 정의: 커스텀 조사는 프로젝트/플랫폼이 추가하는 **“핀 조사(별칭)”** 이다. (예: `를할라고`, `랑`, `께`, `보다` 등)

**Strict(결정성) 모드 규칙**
- Gate0 자동 분리 목록 밖의 조사는 **반드시 경계 표기 `~`를 써서** `몬스터~를할라고`처럼 적는다.
- 또는 조사 대신 **명시 바인딩**으로 우회한다.
  - `:핀` 바인딩 (조사 대신 핀을 직접 지정)
  - `핀=값` 바인딩 (이름 인자)

**Loose(느슨한) 모드 규칙 (편집기/대화 입력용)**
- `몬스터를할라고`처럼 `~` 없이 붙여 쓴 입력도, ParticleRegistry에 `를할라고`가 등록되어 있으면 **최장일치(Longest‑match)** 로 후보 분해를 제안할 수 있다.
- 단, 정본화기는 항상 `~`를 삽입해 **Strict 형태로 출력**한다. *(Loose 입력 → Strict 정본)*

**겹침/충돌 관리 (노력 폭증 방지)**
- `를` vs `를할라고`처럼 **포함 관계**인 접미사는 최장일치로 1차 해소 가능.
- 그래도 다의성이 남으면(전체 어절 이름 후보와 조사 후보가 공존) 린트가 “명시 필요” 오류를 내고 `~` 사용을 요구한다.
- 구현 팁: 조사 후보 집합은 **접미사 Trie**(suffix trie)로 구성하면 분해 비용은 대략 O(len(word))로 제한된다.



### 27.1.2 FieldSpec (postfix 괄호) — RESERVED

- FieldSpec은 `이름( ... )` 형태의 **postfix 괄호**입니다.
- 의미(의도): `이름`의 필드/슬롯/멤버를 선택하거나, 구조화 값에서 일부를 꺼내는 **선택자(selector)** 용도입니다.
- Gate0 범위:
  - 구문은 **예약**합니다(파서가 인식).
  - 의미/표준 라이브러리/타입 시스템 연동은 Gate1에서 정의합니다.
- 호출(Call)은 FieldSpec으로 하지 않습니다. *(PinSpec과 역할을 분리해서 문법을 단순화합니다)*
  - ✅ `(인자...) 이름`  (PinSpec: 호출/인자 제공)
  - ❌ `이름(인자...)`  (Gate0에서는 "필드 선택" 자리이므로 호출로 해석하지 않음)
- 태그 `#...`는 이름(head)이 될 수 없습니다.
  - ✅ `( … ) 공격` 또는 `( … ) 공격:움직씨`
  - ❌ `( … ) #공격`  // `#공격`은 태그 리터럴(메타 표지)

### 27.2 곳간(Registry) (MUST)

**[REGISTRY-01] (MUST)**  
컴파일러와 IDE가 공유하는 함수 메타데이터 저장소.

**구조 (JSON 예시):**
```json
{
  "term_map_version": "tm-1",
  "fatal_terms": [
    {
      "code": "TERM-FATAL-001",
      "input": "자산",
      "canonical": "쓸감"
    },
    {
      "code": "TERM-FATAL-002",
      "input": "객체",
      "canonical": "임자"
    },
    {
      "code": "TERM-FATAL-003",
      "input": "리소스",
      "canonical": "바탕"
    },
    {
      "code": "TERM-FATAL-004",
      "input": "프레임",
      "canonical": "마디"
    },
    {
      "code": "TERM-FATAL-005",
      "input": "입력",
      "canonical": "샘"
    },
    {
      "code": "TERM-FATAL-006",
      "input": "가드",
      "canonical": "지킴이"
    },
    {
      "code": "TERM-FATAL-007",
      "input": "에러",
      "canonical": "고장"
    },
    {
      "code": "TERM-FATAL-008",
      "input": "랜덤",
      "canonical": "주사위"
    },
    {
      "code": "TERM-FATAL-009",
      "input": "디버그",
      "canonical": "거울"
    },
    {
      "code": "TERM-FATAL-010",
      "input": "상태",
      "canonical": "누리"
    },
    {
      "code": "TERM-FATAL-011",
      "input": "로그",
      "canonical": "진단말"
    },
    {
      "code": "TERM-FATAL-012",
      "input": "덧댐",
      "canonical": "고침"
    },
    {
      "code": "TERM-FATAL-013",
      "input": "world",
      "canonical": "누리"
    },
    {
      "code": "TERM-FATAL-014",
      "input": "scene",
      "canonical": "마당"
    },
    {
      "code": "TERM-FATAL-015",
      "input": "level",
      "canonical": "판"
    },
    {
      "code": "TERM-FATAL-016",
      "input": "월드",
      "canonical": "누리"
    },
    {
      "code": "TERM-FATAL-017",
      "input": "씬",
      "canonical": "마당"
    },
    {
      "code": "TERM-FATAL-018",
      "input": "레벨",
      "canonical": "판"
    },
    {
      "code": "TERM-FATAL-019",
      "input": "toolchain",
      "canonical": "연장줄"
    },
    {
      "code": "TERM-FATAL-020",
      "input": "platform",
      "canonical": "틀"
    },
    {
      "code": "TERM-FATAL-021",
      "input": "runtime",
      "canonical": "틀"
    },
    {
      "code": "TERM-FATAL-022",
      "input": "realm",
      "canonical": "터"
    },
    {
      "code": "TERM-FATAL-023",
      "input": "adapter",
      "canonical": "끼우개"
    },
    {
      "code": "TERM-FATAL-024",
      "input": "manifest",
      "canonical": "차림표"
    },
    {
      "code": "TERM-FATAL-025",
      "input": "filter",
      "canonical": "체"
    },
    {
      "code": "TERM-FATAL-026",
      "input": "q-chain",
      "canonical": "솎음줄"
    },
    {
      "code": "TERM-FATAL-027",
      "input": "qchain",
      "canonical": "솎음줄"
    },
    {
      "code": "TERM-FATAL-028",
      "input": "q chain",
      "canonical": "솎음줄"
    },
    {
      "code": "TERM-FATAL-029",
      "input": "q줄",
      "canonical": "솎음줄"
    },
    {
      "code": "TERM-FATAL-030",
      "input": "큐체인",
      "canonical": "솎음줄"
    },
    {
      "code": "TERM-FATAL-031",
      "input": "manim",
      "canonical": "움직이는 셈그림"
    },
    {
      "code": "TERM-FATAL-032",
      "input": "만임",
      "canonical": "움직이는 셈그림"
    },
    {
      "code": "TERM-FATAL-033",
      "input": "capability",
      "canonical": "할힘"
    },
    {
      "code": "TERM-FATAL-034",
      "input": "permission",
      "canonical": "할힘"
    },
    {
      "code": "TERM-FATAL-035",
      "input": "wordbinding",
      "canonical": "말힘누리"
    },
    {
      "code": "TERM-FATAL-036",
      "input": "incantation",
      "canonical": "말힘"
    },
    {
      "code": "TERM-FATAL-037",
      "input": "쿼리",
      "canonical": "여기에서_찾기"
    },
    {
      "code": "TERM-FATAL-038",
      "input": "필터",
      "canonical": "체"
    },
    {
      "code": "TERM-FATAL-039",
      "input": "forEach",
      "canonical": "각각_돌며"
    }
  ],
  "legacy_terms": [
    {
      "code": "TERM-WARN-001",
      "input": "변수",
      "canonical": "이름/이름씨"
    },
    {
      "code": "TERM-WARN-010",
      "input": "query",
      "canonical": "여기에서_찾기"
    },
    {
      "code": "TERM-WARN-012",
      "input": "for_each",
      "canonical": "각각_돌며"
    },
    {
      "code": "TERM-WARN-002",
      "input": "함수",
      "canonical": "움직씨"
    },
    {
      "code": "TERM-WARN-003",
      "input": "클래스",
      "canonical": "이름씨"
    },
    {
      "code": "TERM-WARN-004",
      "input": "이벤트",
      "canonical": "알림씨"
    },
    {
      "code": "TERM-LEGACY-001",
      "input": "stage",
      "canonical": "마당"
    },
    {
      "code": "TERM-LEGACY-002",
      "input": "스테이지",
      "canonical": "마당"
    },
    {
      "code": "TERM-LEGACY-003",
      "input": "언령게임",
      "canonical": "말힘누리"
    },
    {
      "code": "TERM-LEGACY-004",
      "input": "모양",
      "canonical": "생김새"
    },
    {
      "code": "TERM-LEGACY-005",
      "input": "트레잇",
      "canonical": "특성"
    },
    {
      "code": "TERM-LEGACY-006",
      "input": "bogae_canvas_w",
      "canonical": "보개_바탕_가로"
    },
    {
      "code": "TERM-LEGACY-007",
      "input": "bogae_canvas_h",
      "canonical": "보개_바탕_세로"
    },
    {
      "code": "TERM-LEGACY-008",
      "input": "bogae_bg",
      "canonical": "보개_바탕색"
    }
  ],
  "josa_only": [
    "이",
    "가",
    "을",
    "를",
    "은",
    "는",
    "에",
    "로",
    "의",
    "도",
    "만",
    "와",
    "과",
    "에서",
    "에게",
    "께",
    "부터",
    "까지"
  ],
  "reserved_words": [
    "마디",
    "샘",
    "임자",
    "누리",
    "지킴이",
    "고장",
    "거울",
    "쓸감",
    "바탕",
    "진단말",
    "고침"
  ]
}
```

### 20.3 파서 Reverse-Lookup (MUST)

**[PARSER-LOOKUP-01] (MUST)**  
사용자가 조사를 붙이면 그 조사를 만족하는 핀을 찾아 자동 매핑.

**예시:**
```ddn
주인공을 (10, 0)로 빠르게 움직이기.
```

파서 동작:
1. `주인공을` → "을" 조사 → `대상` 핀 매핑
2. `(10, 0)로` → "로" 조사 + 벡터 타입 → `방향` 핀 매핑
3. `빠르게` → 부사 → 말결 토큰 처리 (별도)


**[PARSER-LOOKUP-02] (MUST)** 조사 생략/모호성 바인딩 우선순위  
파서는 조사가 생략되거나 중의적일 때, 다음 순서로 핀(인자)을 확정한다.

1) `:핀`로 **핀 고정**된 인자
2) 명시 조사(을/를/이/가/에/에서/로/으로/에게/한테/… ) 또는 `~조사`로 고정된 인자
3) 타입이 **유일하게** 일치하는 핀(예: 벡터/임자/수/글 등)
4) 움직씨/셈씨 인자 선언 순서(왼쪽→오른쪽)
5) 그래도 모호하면 **정본화 실패**로 처리하고, 사용자에게 `:핀`(우선) 또는 조사(`~...`) 고정을 요구한다(MUST).

### 20.4 IDE 자동완성 (SHOULD)

**[IDE-COMPLETE-01] (SHOULD)**  
IDE는 현재 문맥에서 가능한 조사 목록을 팝업 제공.

**예시:**
```
사용자 입력: "주인공"
IDE 제안: [을, 를, 이, 가, 에게, ...]

사용자 입력: "주인공을"
IDE 제안: 움직이기, 제거해, ...
```

---



## 28. 설탕 구문 계층 (Story-driven Syntax) — MUST

또니랑은 내부적으로 ECS/아키타입/고정64 같은 고급 모델을 사용하더라도, 사용자(특히 학습자)는 **서술형 문장**으로 자연스럽게 접근할 수 있어야 합니다.

**[SUGAR-01] (MUST)** 설탕은 “정본 AST”로 해소된다  
- 표면(설탕) 문장은 정본화기에서 **동일 의미의 정본 AST**로 변환된다.  
- 런타임은 설탕을 해석하지 않고, 정본 AST(또는 그 하위 IR)만 실행한다(MUST).



**[L0-SUGAR-IF-ELIF-01] (ACCEPTED, canon-only)** `아니고 (조건) 일때`(elif) 축약
- 목적: 중첩 `} 아니면 { (조건) 일때 { ... } }`를 읽기 쉽게 만든다.
- 의미: 정본 AST는 기존 `일때/아니면` 중첩과 **동일**해야 한다.
- canon 전개(개념):
  - 표면:
    - `(c1) 일때 { A } 아니고 (c2) 일때 { B } 아니면 { C }.`
  - 정본 전개:
    - `(c1) 일때 { A } 아니면 { (c2) 일때 { B } 아니면 { C }. }.`

**[L0-SUGAR-NOT-01] (ACCEPTED, canon-only)** `(참거짓값 아님)` 축약
- 목적: `{ ... }아닌것`과 같은 표면을 더 자연스럽게 쓴다.
- 의미: `x 아님`은 논리 부정이며, 정본 AST는 기존 부정 표기와 동일해야 한다.
- 주의: 기호 `!`는 Gate0에서 도입하지 않는다(토큰/우선순위 증가). `아님`만 사용한다.

**[CANON-MOOD-01] (MUST)** 어조(말투) 보존
- 정본화기는 표면 문장을 동일 의미의 정본 AST로 수렴시키되, **어조**를 메타데이터로 보존한다.
- 정본 AST의 문장 노드는 `어조:갈래씨` 필드를 가진다.
  - `어조:갈래씨 = { #서술 | #명령 | #청유 | #의문 | #감탄 }`
- 어조는 실행 의미론(누리 덧댐)을 바꾸지 않을 수 있으나, **슬기/보개/거울**이 사용할 수 있도록 잃지 않는다.
- 어조 판정은 종결 어미/문장 부호 등 표면 힌트를 사용하며, 판정 불가 시 `#서술`을 기본값으로 한다(MUST).

**[SUGAR-02] (SHOULD)** 형용사/서술어 기반 상태 매핑  
- `주인공은 튼튼하다.` 같은 서술어는 말모이(레지스트리)에 등록된 매핑에 따라 컴포넌트 변경으로 해소될 수 있다.
- 강도 부사는 `$` 말결 토큰으로 표현한다: `$매우 주인공은 튼튼하다.`

**[SUGAR-03] (MAY)** 암시적 임자 생성(교육용)  
- `사과가 떨어진다.`에서 `사과`가 아직 없으면, 도구/런타임이 기본 임자를 생성하는 모드는 교육 경험에 유리하다.  
- 단, 결정성/감사 관점에서 “암시적 생성”은 입력/정본화 단계에서 **명시적 생성으로 환원**되어야 한다(MUST).

**예시(표면 → 정본 해소):**
```ddn
// 표면(학습자): 서술형
주인공은 튼튼하다.
$매우 주인공은 튼튼하다.

// 정본(개념): 컴포넌트/값 변경으로 환원
주인공에 (HP=100) 붙여.
주인공에 (HP=150) 붙여.   // $매우 가중치 반영(예)
```


## §M1 수식 체계 — 삼층(입력/알맹이/표시) 분리 — MUST

또니랑의 “수학 교과서처럼 정확하고 아름다운 수식”은 **표면 입력이 아니라 내부 알맹이(MathIR)**로 결정성을 보장한다.

### §M1.1 삼층 분리 (MUST)
1) **입력층(Syntax)**: 말수식/ASCII/LaTeX 등 다양한 입력을 허용한다.  
2) **알맹이층(Logic)**: 모든 입력은 **정본 MathIR(AST)** 하나로 정규화된다. (해시 가능)  
3) **표시층(View)**: MathJax/KaTeX/MathML 등은 “그림(렌더링)”이다. 계산 엔진이 아니다.

### §M1.2 표지 단일화: `수식{...}` (MUST)
수식 표지는 오직 하나다.

- `수식{ ... }` : 수식값(1급 값)을 만든다. 즉시 실행이 아니다.
- 방언은 **태그(Atom)** 로만 구분한다.

정본 방언:
- `(#말)수식{ ... }` : 한국어 말수식 (입력 별칭: `(#우리말)` → 정본 `(#말)`)
- `(#ascii) 수식{ ... }` : ASCII/교과서형 텍스트 수식(명시 곱 `*` 권장)
- `(#ascii1) 수식{ ... }` : ASCII-1글자(+숫자 첨자) 변수 전용(암묵곱 제한 허용)
- `(#latex) 수식{ ... }` : LaTeX 입력(표시/복붙 우선, 실행은 변환기 범위 내)
- `(#raytag) 수식{ ... }` : Raytag(정형 태그 트리) 입력(모호성 최소, AI 생성 권장)
- `(#그림)수식{ ... }` : 편집기/쓸감 기반(프로젝트 자산 ID 등)

> `[[ ... ]]` 같은 별도 구분자는 Gate0에서 사용하지 않는다(예약 기호 유지).

### §M1.3 `(#ascii)` vs `(#ascii1)` (MUST)
- `(#ascii) 수식{...}`: **암묵 곱 금지**. 곱셈은 `*`로만 표현한다.  
- `(#ascii1) 수식{...}`: 변수는 **영문 1글자(+선택 숫자 첨자)만 허용(MUST)**. 인접한 항은 곱셈으로 해석한다(MUST).

예:
```ddn
높이 = (#ascii) 수식{ x0 + v0*t + (1/2)*a*t^2 }.
높이 = (#ascii1) 수식{ x0 + v0t + 1/2at^2 }.  // 1글자(+숫자 첨자) 변수만 허용
```

금지(모호성):
```ddn
높이 = (#ascii1) 수식{ at^2 }.  // 'a' 't'는 1글자라 곱셈 OK
높이 = (#ascii1) 수식{ acc*t }. // acc는 1글자 아님 → 오류
```


##### §M1.2.3 태그 위치 정본
- 태그 묶음 `(#ascii)`, `(#ascii1)`, `(#latex)`는 **항상 `수식{...}` 씨앗 값에 귀속**하며, 씨앗 표지 **바로 앞**에 둔다.
  - 정본: `(#ascii) 수식{ ... }`
  - 비정본(금지): `수식{ ... } (#ascii)` , `수식{ ... #ascii }`
- Formatter는 `(#tag)수식{...}` 형태를 `(#tag) 수식{...}`로 정규화한다. (SPACING-01)
- 태그가 없으면 디폴트는 `#ascii`이다.

##### §M1.2.4 본문 허용 범위
- `수식{...}`의 본문은 **중괄호 균형**을 만족해야 한다.
  - 즉, `수식{`로 시작한 블록은 동일 중첩 레벨에서 닫는 `}` 1개로 닫힌다.
  - `#latex`를 위해 `{ ... { ... } ... }` 같은 중첩은 허용한다.
- Gate0에서의 허용 문자/평가:
  - `#ascii`, `#ascii1`: 본문은 **ASCII(0x20..0x7E) + 개행/탭**만 허용한다. 비-ASCII가 있으면 `FATAL:FORMULA_BODY_NONASCII`.
    - 허용 토큰(요약, Gate0): `숫자`, `식별자`, 연산자 `+ - * / ^`, 괄호 `(` `)`, 대입 `=`, 구분자 `,`, 소수점 `.`
      - 자세한 토큰/문법은 `SSOT_TOOLCHAIN` §TC-M1.4A(ddn.math/core)를 따른다.
      - 확장 예약(AGE1+): `#ascii`에서 함수호출/수열합·곱/형식 미분·적분 표기는 `SSOT_TOOLCHAIN` §TC-M1.4B(ddn.math/ext)를 따른다.
        - Gate0 `풀기`는 ddn.math/core만 평가하며, ext가 포함되면 `FATAL:FORMULA_EVAL_EXT_UNSUPPORTED`.
  - `#latex`: 본문은 임의 유니코드 허용. 단, Gate0 실행기에서 `풀기`/`미분하기`/`적분하기`는 `FATAL:FORMULA_DIALECT_UNSUPPORTED`로 실패한다(표시/저장만 가능).

### §M1.4 결정성 규칙 (MUST)
- 수식값은 정본화(항 정렬/상수접기/단위 정규화 등)를 거쳐 **동일 의미는 동일 MathIR**로 수렴해야 한다.
- 수치 평가(계산)는 Fixed64 + 단위/차원 시스템에 따르며, 동일 입력이면 동일 비트 결과를 보장한다.


### §M1.5 MathIR v1 정본(요약) — MUST

- `(#ascii/#ascii1) 수식{...}` 는 반드시 **MathIR v1**로 정규화(해시 가능)되어야 한다.
- 바인딩(수열합/곱/적분)의 더미 변수 이름은 의미가 아니므로, MathIR에서는 **De Bruijn index(묶인변수)** 로 표현한다.
- 정본 노드/직렬화/정규화 규칙은 `SSOT_TOOLCHAIN` **§TC-M1.5(MathIR)** 를 따른다. (LANG은 원칙만 선언하고, IR/DetBin의 상세는 TOOLCHAIN이 담당)

> NOTE: Gate0에서 `풀기`는 ddn.math/core만 평가하지만, “수식값” 저장/표시/변환의 기반은 MathIR이므로 IR 정의는 Gate0부터 고정해 두는 것이 안전하다.



---

## §M2 미분/적분/풀기 — “변환 동사” — Gate0/AGE1 범위




### §M2.1 실행(동작)과 결과(값) 분리 (MUST)
- 변환은 동작(호출식)으로 표현한다: `미분하기`, `적분하기`, `풀기`
- “해서”는 파이프 연결자이며, 동작 호출은 꼬리(`~기`/`~하기`)를 붙인다.
- `-서`(예: `미분해서`, `적분해서`)는 Gate0에서 **비허용(문법 오류)**. 정식은 `미분하기 해서`, `적분하기 해서`.

정본 예:
```ddn
f~을 미분하기 해서 돌려주기.
f~을 적분하기 해서 돌려주기.
```

Thunk를 중간에 묶고 싶으면(권장):
```ddn
{ f~을 미분하기 }해서 돌려주기.
```

> `미분한것` 같은 “결과명사”는 문장/교육용 별칭으로 둘 수 있으나, Gate0 정본 호출은 `미분하기`를 사용한다.

### §M2.2 수식 평가: 풀기 (Gate0)

`풀기`는 `수식값` + 변수 주입을 받아 **수치 결과(수)** 를 돌려주는 표준 변환 말입니다.

- 정본 이름: `풀기` (MUST)
- 별칭: (없음). Gate0에서 `값구하기`는 RESERVED (사용 금지).

타입(개념):
- 입력: `식:수식값` + `주입:묶음(변수→값)`
- 출력: `수` (단위가 있으면 단위를 포함한 수)

정본 호출 예:
```ddn
# (정본) 특수블록 `수식{...}`에 **주입이 앞에 붙으면**, 그 자리에서 곧바로 값(수)으로 평가된다.
y = (x=6) (#ascii) 수식{ y = 2*x + 3/2 }.
y 보여주기.

# (정본) 수식값(변수) 평가: (주입)인 식 풀기
직선 = (#ascii) 수식{ y = 2*x + 3/2 }.
y2 = (x=6)인 직선 풀기.
y2 보여주기.
```

#### §M2.2.1 변수 주입 규칙 (MUST)
- 주입은 **named binding**으로만 한다: `x=6` 형태.
  - `x:6`은 금지. (`:`는 타입 구분/필드 선택/핀 고정 접미에서만 사용)
- 주입 키는 변수 이름(식별자)여야 한다.
- 필요한 자유변수 누락 → FATAL
- 주입에 존재하지만 수식에서 쓰이지 않는 변수(여분 키) → FATAL (Gate0 정본은 **엄격 모드**)
- 값이 `없음` → FATAL
- 중복 키 → FATAL

#### §M2.2.2 평가 규칙 (MUST)
- Gate0 실행기는 `#ascii`, `#ascii1`만 평가합니다.
  - `#latex`는 저장/표시만 가능하며, `풀기`/`미분하기`/`적분하기`는 `FATAL`입니다.
- 본문 형태별 결과:
  - 본문이 `식`(expression)이면 그 값을 반환합니다.
  - 본문이 `이름 = 식`이면 RHS를 평가하여 그 값을 반환합니다.
- Gate0는 **방정식 풀이(미지수 해 구하기)** 를 하지 않습니다.
  - 예: `2*x = 10` 은 Gate0에서 `FATAL`.
- 수치 연산은 Fixed64 결정성(§24)을 따릅니다.
- 단위 연산/환산은 단위 시스템(§4) + Units Registry(TOOLCHAIN §T8)를 따릅니다.

### §M2.3 미분하기/적분하기 (심볼릭 변환) — Gate0/AGE1

- 목적: `수식값`을 입력으로 받아 “기호적(심볼릭) 변환”한 `수식값`을 돌려준다.
- 주의:
  - `미분하기/적분하기`는 **심볼릭 변환**만 의미한다. (DR-081)
  - 런타임 **수치 미분/수치 적분(근사)** 은 별도 규격으로 분리한다(OPEN: `OI-CALC-NUMERIC-01`).  
    심볼릭 결과와 수치 근사를 같은 출력으로 섞지 않는다(MUST NOT).

타입(개념):
- `미분하기`: 입력 `수식값` → 출력 `수식값`
- `적분하기`: 입력 `수식값` → 출력 `수식값`

Gate0 방언/표기계:
- Gate0에서 `미분하기/적분하기`의 방언 지원은 `풀기`와 동일하다.
  - `#ascii`만 허용(MUST)
  - `#latex`는 저장/표시만 가능하며, `미분하기/적분하기`는 `FATAL:FORMULA_DIALECT_UNSUPPORTED`.

시그니처 요약 (DR-081 준수):
- (약식) `미분하기(수식값, 변수이름?:글) -> 수식값`
- (약식) `적분하기(수식값, 변수이름?:글) -> 수식값`
- (정식) `미분하기(수식값, 옵션?:묶음) -> 수식값`
- (정식) `적분하기(수식값, 옵션?:묶음) -> 수식값`

옵션 묶음(v1 최소):
- `변수?:글`
- `차수?:수` (양의 정수, 기본 1)
- `상수포함?:참거짓` (적분만, 기본 거짓)

진단 코드(요약):
- `E_CALC_FREEVAR_AMBIGUOUS`
- `E_CALC_FREEVAR_NOT_FOUND`
- `E_CALC_TRANSFORM_BAD_ORDER`
- `E_CALC_TRANSFORM_UNSUPPORTED_EXPR`
- `E_CALC_TRANSFORM_UNSUPPORTED_OPTION`

## §W1 글무늬(템플릿) 체계

`글무늬{...}`는 **글(문장) 생성용 씨앗(리터럴)** 입니다. `수식{...}`가 수식값을 만드는 것과 같은 급의 “특수블록”입니다.

### §W1.1 글무늬 표지(Seed)

- 문법: `(#태그매듭)? 글무늬{ <본문> }`
  - `<본문>`은 2가지 중 하나:
    1) **따옴표 문자열** 1개: `"..."` (이스케이프 `\n` 등 사용 가능)
    2) **Raw 텍스트**: `{` 다음부터 매칭 `}` 직전까지를 그대로 읽는다(멀티라인 가능)
- **특수블록 판정 규칙(MUST):** `글무늬{` 는 공백 없이 붙여써야 한다. (붙여쓰면 특수블록, 띄어쓰면 `글무늬` 씨앗 + `{...}` 토막)
- Gate0에서도 Raw 텍스트(멀티라인)를 지원한다(MUST). Raw 텍스트는 다음 정본 정규화 규칙을 가진다:
  - (1) 본문이 `\n`으로 시작하면 그 1개는 제거한다.
  - (2) 본문이 `\n`으로 끝나면 그 1개는 제거한다.
  - (3) 비어있지 않은 줄들의 공통 최소 들여쓰기를 계산해 제거한다(dedent).
  - (4) 줄 끝의 `\` 는 “줄-이어쓰기”로 해석해, 바로 뒤 개행을 제거한다.

### §W1.2 자리표시자(placeholder)

`글무늬{...}`의 본문(따옴표 문자열/Raw 텍스트) 안에서 다음 자리표시자를 해석합니다.

- 기본 형태: `{키}`
- 포맷 포함: `{키|@포맷}`
- 이스케이프(MUST):
  - `{{` → `{`
  - `}}` → `}`

키 문법(최소):

- `키`는 **이름** 또는 `이름.이름...` 형태의 **경로**를 허용합니다.
- 경로의 첫 토막(루트 키)은 **주입(핀묶음)** 으로 제공되어야 합니다.
- 경로의 이후 토막은 런타임에 “필드 선택”으로 해석합니다. (필드가 없으면 FATAL)

- 필드 선택 런타임 규칙 (Gate0, MUST)
  - `{키.경로}`에서 `키`는 **채움 인자(루트)** 로 먼저 찾아야 한다. (없으면 FATAL)
  - `경로`의 각 토막은 순서대로 **묶음 값꾸러미(Pack) 필드 선택**으로 해석한다.
    - 중간 값이 묶음이 아니면 FATAL (예: `{사람.이름}`인데 `사람`이 글/수인 경우)
    - 필드가 없으면 FATAL
    - 필드 값이 `없음`이면 FATAL (널/옵션 미해결)
  - 마지막으로 선택된 값이 `없음`이면 FATAL (템플릿은 `없음`을 자동으로 빈 글로 바꾸지 않는다)


### §W1.3 @포맷(자리표시자 내부 전용)

- `@포맷`은 **자리표시자 내부에서만** 해석합니다(MUST).
  - 자리표시자 밖의 `@`는 단위 접미(예: `90@cm`)로만 해석합니다.

Gate0 지원 포맷(최소):

- 폭(width): `@W` 또는 `@0W`  
  - `W`는 1..99 정수
  - `@0W`는 0으로 채움
- 소수 자리 고정: `@.D`  
  - `D`는 0..9 정수
- 소수 + 출력 단위: `@.DU`  
  - 예: `@.3m`, `@.0cm`

수치 출력 결정성:

- 반올림: **ties-to-even**(nearest-even) 고정(MUST)
- 부호: `-`는 맨 앞, 폭 채움은 부호 뒤(MUST)
- 로케일 장식은 Gate0에서 금지(MUST): 천단위 구분(콤마), 지수표기, 지역 소수점

오류는 모두 FATAL:

- 타입 불일치(예: 글에 `@.3`)
- 단위 미정의/환산 불가
- 폭/정밀도 범위 위반

### §W1.4 채우기(렌더)

`채우기`는 `글무늬값`을 실제 `글`로 바꾸는 표준 변환 말입니다.

- 타입(개념, Gate0)
  - 입력: `무늬:글무늬값` + `주입:묶음(키→값)`
  - 출력: `글`

- 주입 표면(정본, MUST)

  1) **특수블록 즉시 렌더(정본)**  
     `(<키=값, ...>) (#태그매듭)? 글무늬{...}`  
     - 주입이 앞에 붙으면 이 표현은 **곧바로 `글` 값**으로 평가된다.  
     - 내부 의미: `글무늬{...}` 생성 + `채우기` 적용(동치).

  2) **무늬값 렌더(정본)**  
     `(<키=값, ...>)인 무늬 채우기`  
     - `무늬`는 `글무늬값` 변수/식별자.

  3) **명시 핀(허용; 도구/저수준)**  
     `(무늬=무늬, <키=값, ...>) 채우기`  
     - 정본화기는 1) 또는 2)로 정본화한다.

- 금지(비문/혼선; Gate0 문법 오류)
  - `글무늬{...} 해서 (키=값, ...) 채우기`
  - `글무늬{...} 채우기`
  - `글무늬{...} 해서 () 채우기`  *(빈 주입은 표면으로 쓰지 않는다)*
  - fix-it:
    - `글무늬{...} 해서 (k=v, ...) 채우기` → `(<k=v, ...>) 글무늬{...}`

- 값 타입 규칙 (MUST)
  - `{키}`: 값은 `글로` 변환 가능해야 한다. (예: `글`, `수`, `묶음` 등)
  - `{키|@...}`: 값은 반드시 `수`여야 한다. (단위 포함 가능)

예시(정본):

```ddn
(id=23, h=123.456@cm) (#엄격) 글무늬{"ID={id|@08}, 키={h|@.3m}"} 보여주기.
```

- `채우기`의 인자 규칙(MUST):
  - **주입 키**는 템플릿이 참조하는 **루트 키 집합**과 정확히 일치해야 합니다.
  - 누락/여분/중복은 FATAL.
  - 변환 과정(단위/반올림/폭 채움)은 결정적이어야 합니다.




### §W1.5 맞추기(패턴 매칭) — MAY (AGE1+)

글무늬는 “채우기(렌더)” 뿐 아니라, **문자열에서 값을 뽑는 패턴**으로도 쓸 수 있다.  
다만 이는 구현 난이도가 커서, **AGE0 필수는 아니며 AGE1+에서 구현**하는 것을 권장한다.

#### W1.5.1 시그니처(개념)

- 입력: `(무늬=글무늬값, 대상=글)`
- 출력: `짝맞춤?`
  - 일치하면: `{ 변수이름 → 캡처된 글 }` 짝맞춤
  - 실패하면: `없음`

> 이유: 정규식처럼 “여러 해석”이 생기면 결정성이 깨질 수 있다.  
> 따라서 SSOT는 **모호성 없는(결정적) 매칭 규칙**만 허용한다.

#### W1.5.2 결정적 매칭 규칙(요지)

- 기본은 **전체 일치(anchored)**: 대상 전체가 무늬와 맞아야 성공
- 변수 `{x}`는 기본적으로 **최소 매칭(minimal)** 으로 동작한다(왼쪽부터 확정)
- 같은 변수 이름이 여러 번 나오면:
  - 모두 같은 값이어야 한다(불일치 시 실패)
- 캡처 타입:
  - AGE1 기본은 `글`만 캡처한다(숫자/참거짓 변환은 STDLIB에서 따로 처리)

#### W1.5.3 예시

```
무늬 = 글무늬{"이름:{name} 나이:{age}"}
대상 = "이름:또니 나이:7"

(무늬, 대상) 맞추기.   # => { "name":"또니", "age":"7" }
```

> 확장(후순위): `{age:수}` 같은 **형 변환 매칭**은 이후 시즌에서 논의한다.


## §R1 정규식(Regex) — `정규식{}` 리터럴 — AGE2+

또니랑은 “동양적 말결”을 살리되, 텍스트 처리는 현실적으로 정규식이 필요하다.  
다만 정규식은 구현체/플래그/유니코드 처리에 따라 결과가 달라질 수 있으므로, **정규식은 반드시 ‘값’으로 봉인**하고, 표준 API를 통해서만 실행한다.

### §R1.1 리터럴 문법

- 리터럴 표기: `정규식{ ... }`
- 본문은 **문자열 리터럴 1개(패턴)** + 선택적으로 **문자열 리터럴 1개(깃발)** 를 `,`로 구분한다.

예:

```ddn
패턴1 <- 정규식{"^[A-Z]{2}[0-9]+$"}.
패턴2 <- 정규식{"[a-z]+", "i"}.  # i = 대소문자 무시
```

### §R1.2 타입/값 의미

- 타입 이름: `정규식`
- 의미:
  - `pattern`: UTF-8 문자열
  - `flags`: UTF-8 문자열(기본값 `""`)
- 결정성 규칙:
  - **같은 입력(글, 정규식 값) → 같은 출력**을 보장해야 한다.
  - 구현체(엔진)는 런타임/표준 라이브러리 버전에 고정되어야 한다. (업그레이드는 버전으로만)

### §R1.3 깃발(Flags) 최소 집합 (Gate0/AGE2)

Gate0/AGE2에서 **최소 보장**하는 깃발은 아래와 같다.

| 깃발 | 의미 |
|---|---|
| `""` | 기본 |
| `"i"` | 대소문자 무시(case-insensitive) |

> 그 외 깃발은 AGE3 이후 확장 대상으로 두며, 지원하지 않는 깃발은 즉시 실패한다.

### §R1.4 표준 API(정본) — 이름만 선반영

정규식 실행은 표준 라이브러리 API로만 노출한다. (문법 확장 없이 “라이브러리”로 해결)

| API(정본 이름) | 최소 시그니처(초안) | 의미(초안) |
|---|---|---|
| `정규맞추기` | `(대상:글, 패턴:정규식) -> 참거짓` | 전체 일치(anchored) |
| `정규찾기` | `(대상:글, 패턴:정규식) -> 글?` | 첫 매치(없으면 없음) |
| `정규바꾸기` | `(대상:글, 패턴:정규식, 바꿈:글) -> 글` | 전체 치환(global) |
| `정규나누기` | `(대상:글, 패턴:정규식) -> 차림<글>` | 분리(split) |

### §R1.5 오류 코드(신규)

| 코드 | 등급 | 의미 |
|---|---|---|
| `E_REGEX_FLAGS_INVALID` | FATAL | 지원하지 않는 깃발 문자열 |
| `E_REGEX_PATTERN_INVALID` | FATAL | 패턴 컴파일 실패(문법 오류 등) |



## §P1 파이프(해서) — 흐름값/주입/모호성 금지 — MUST

### §P1.1 파이프의 목적
파이프는 “값을 만들어 다음 호출로 넘기는 연쇄”를 **표면에서 결정적으로 표시**한다.  
특히 AI/구현체가 “암묵 추측”을 하지 않게 하려면 연쇄 표지가 필요하다.

### §P1.2 호출식만 허용 (PIPE-CALL-ONLY-01, MUST)
- `해서` 뒤에는 **호출식(CallExpr)** 만 올 수 있다.
- `해서` 뒤에서 `a+b`, 리터럴 단독, 식별자 단독은 금지.
- 필요하면 `{ ... }해서`로 값을 만든 뒤 **즉시 파이프**하거나, `{ ... }한것`으로 값을 만든 뒤 조사/핀으로 주입한다.

### §P1.3 암묵 주입 금지 (PIPE-NO-IMPLICIT-INJECT-01, MUST NOT)
아래 형태는 금지:
```ddn
{ ... }한것 돌려주기.   // 주입 표지 없음 → 금지
```
주입은 반드시 아래 셋 중 하나로 표면에 표시해야 한다:
1) `~조사` (권장: `~을/~를`)
2) `:핀`
3) `해서`

### §P1.4 단일 전달(권장 정본)
단 한 번 값 전달은 **조사로 봉인**하는 것을 권장한다.
```ddn
{ f 미분하기 }한것~을 돌려주기.
```

### §P1.5 다단계 연쇄(권장 정본)
여러 단계 변환은 파이프로 읽기 좋게 만든다.
```ddn
f~을 미분하기 해서 정리하기 해서 돌려주기.
```

### §P1.6 `{ ... }해서` 파이프 꼬리 (MUST)
- `{ ... }해서`는 **토막(일묶음씨/Thunk)**을 즉시 실행해 **값(Value)**을 얻고, 그 값을 **곧바로 다음 CallExpr로 파이프**한다.
- `}한것`과 `해서`를 분리해 쓰지 않는다. (`{ ... }한것 해서 ...`는 비허용; fix-it: `{ ... }해서 ...`)
- `PIPE-CALL-ONLY-01`: `}해서` 뒤에는 반드시 CallExpr가 와야 한다.

예:
```ddn
{ f~을 미분하기 }해서 돌려주기. # OK(정본)
```
### §P1.7 흐름값 주입 알고리즘 (PIPE-INJECT-01, MUST)
파이프 `A 해서 B`에서 `A`의 결과 흐름값 `v`를 `B`의 어떤 핀에 주입하는지:

0) 사용자가 `:핀` 또는 `~조사` 또는 이름바인딩으로 이미 채운 인자는 건드리지 않는다.
1) 다음 호출에 목적격(`~을/~를`) 핀이 있고 비어 있으면 → 거기에 주입
2) 없으면 → 선언 순서상 “미채움 필수핀”의 첫 번째에 주입
3) 후보가 둘 이상이면 → **모호 오류** (사용자는 `:핀` 또는 `~조사`로 봉인)

### §P1.8 예시 (요약)
- 정본:
  - `{ f~을 미분하기 }한것~을 돌려주기.`  # 값으로 만들고(}한것) 조사로 전달
  - `{ f~을 미분하기 }해서 돌려주기.`      # 값으로 만들고(}해서) 즉시 파이프
- 금지(문법 오류):
  - `f 미분해서 돌려주기.`                 # '-서' 비허용 → `f~을 미분하기 해서 ...`
  - `{ f~을 미분하기 }한것 해서 돌려주기.` # 비문/비정본 → `{ ... }해서 ...`
## §C2 STDLIB (표준 라이브러리)

# STDLIB


# 또니랑 SSOT v17.0.0 (Compact) — STDLIB (표준 라이브러리)

> **표기 주의 (MUST)**  
> 이 문서의 PinSpec “타입” 칼럼에서 보이는 `(T)차림`, `(수)꾸러미` 같은 표기는 **기술적 설명(메타 표기)**입니다.  
> 실제 또니랑 코드 문법에서는 자리표시자 꺾쇠(예: `〈…〉/《…》`)를 사용하지 않으며, 모든 정의는 **(수식어) 씨앗 이름** 규칙을 따릅니다.  
> 따라서 `(T)차림`는 코드 표면 문법으로는 보통 `(T) 차림`처럼 “(수식어) 먼저”로 읽습니다.


### ⭐ AI-친화 정리: "호출 꼬리 규칙"을 표/예제에 더 강하게 드러내기

- **호출은 항상 "앞에 값/인자, 뒤에 말(씨앗 이름)"** 형태이다. (괄호 `이름(인자)` 호출을 쓰지 않는다.)
- **호출 꼬리(추천/표준)**: 실행은 `~기/~하기`, 이어쓰기는 `~고/~하고`, 조건은 `~면/~하면`.
  - 꼬리를 빼면 호출이 아니라 **이름(값) / 필드 / 수식**으로 오해될 수 있다.
- 문서에서 ` ```ddn` 코드블록은 **정본 문법**만 담는다. (틀린 예시·의사코드는 ` ```text`)

❌ 자주 나오는 잘못된 호출 형태(예시)
```text
말하기("안녕").
보여주기("안녕").
(10) 증가.
```

✅ 정본 호출(뒤이름 + 꼬리)
```ddn
"안녕"을 말하기.
"안녕" 보여주기.
(10) 증가하기.
```

## 1. 핀(Pin) 스펙 표기법

PinSpec 칼럼은 “말(함수/어미)의 **핀(인자) 요구**”를 표기합니다.

```text
(핀명:타입~조사들) (핀명:타입~조사들)? ... 〈말이름:반환타입〉
```

- `~` : 핀에 허용되는 조사(여러 개 가능). 예) `~을~를`, `~로~으로`
- `?` : **옵션 핀(생략 가능)**. 생략 시 값은 `없음`으로 정규화된다(MUST).
- `[]` : **차림 리터럴** 표기(DEC-20260121-CHARIM-LIT-01). PinSpec 표기법에서는 사용하지 않는다(사용처 혼동 방지).
- `$` : 어찌씨에 붙는 말결 토큰이다.

**예시:**
```ddn
// 표면 문장 예
"안녕"을 말하기.
"안녕"을 (감정="기쁨")로 말하기.

// PinSpec 예
(내용:글~을~를) (감정:글~로~으로)? 말하기
```

---

## 2. 핵심 함수 — MUST

### 2.1 출력/로그

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `보여주기` | `(내용:글 ~을)` | LogComponent 생성 (Transient) |
| `말하기` | `(내용:글 ~을) (감정:글 ~로~으로)?` | SpeechComponent 생성 |
| `생각하기` | `(내용:글 ~을)` | ThoughtComponent 생성 (보개 정책에 따라 출력 여부 결정) |

**중요:** 이들은 "출력 함수"가 아니라 **컴포넌트 생성 Sugar**이다.

### 2.2 알림 (alrim) — MUST

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `알리기` | `(사건:글 ~을) (데이터:값 ~로~으로)?` | SignalComponent 생성 (Transient) |

**처리:** 동일 마디 Reactive 단계에서 즉시 트리거됨.

**예시:**
```ddn
(#레벨업(새레벨=5)) 알리기.
(#충돌(대상=철수, 다른=영희)) 알리기.
(#종료) 알리기.
```

### 2.3 쓸감 (Asset) — MUST

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `쓸감` | `(경로:글 ~을) 쓸감:쓸감손잡이` | 정규화 경로를 `쓸감번호(u64)`로 치환하여 손잡이를 만든다 |

**리터럴:** `@"경로/파일.png"` *(= `"경로/파일.png" 쓸감.`)*

**예시:**
```ddn
그림 = "그림/주인공.png" 쓸감.
그림 = @"그림/주인공.png"  // 동일
```

**결정론 규칙:**
- `쓸감번호`는 정규화된 경로의 해시로 생성
- 리플레이에서 파일이 변경/삭제되어도 기록된 `쓸감번호` 자체는 불변
- 보개는 `쓸감번호 → 실제 파일` 매핑을 로딩 정책에 따라 수행

> **용어 구분(중요)**  
> - **쓸감(Asset)**: 파일/그림/모델 같은 “정적 항목”을 가리키는 **쓸감손잡이(쓸감번호)** 체계.  
> - **터바탕씨(Resource)**: 틀(PLATFORM)에서 쓰는 ECS 개념으로, **터(Realm)마다 단 하나** 존재하는 전역 데이터.

**용어/금지어(중요):**
- `자산`은 Gate0에서 **치명 금지어(fatal_terms)** 이다. 입력에 등장하면 **즉시 오류**로 처리하고, 대체어로 `쓸감`을 제시한다.
- `자원`은 `바탕`의 레거시 별칭(입력 허용·경고)이며, 쓸감(Asset) 의미로의 사용은 금지한다.


### 2.4 목표 (Goal)

`-도록` 어미 사용 시 GoalComponent 등록됨.

```ddn
(적)을 처치하도록.
// → GoalComponent(GoalId("적처치")) 생성
```

---

## 3. DetMath (결정적 수학) — MUST

### 3.1 원칙

- **모든 연산은 Fixed64 기반**
- **플랫폼 무관 동일 결과** (D-STRICT)

### 3.2 기본 연산

| 함수 | 시그니처 | 설명 |
|------|----------|------|
| `더하기` | `(왼:수, 오른:수) 더하기:수` | 덧셈 |
| `빼기` | `(왼:수, 오른:수) 빼기:수` | 뺄셈 |
| `곱하기` | `(왼:수, 오른:수) 곱하기:수` | 곱셈 |
| `나누기` | `(왼:수, 오른:수) 나누기:수` | 나눗셈 (항상 비정수 결과) |
| `나눈몫` | `(왼:수, 오른:수) 나눈몫:정수` | 정수 몫 (0을 향해 절삭) |
| `나눈나머지` | `(왼:수, 오른:수) 나눈나머지:정수` | 정수 나머지 |
| `절댓값` / `abs` | `(값:수) 절댓값:수` | |
| `부호` / `sign` | `(값:수) 부호:수` | -1, 0, 1 |

### 3.3 반올림/분해

| 함수 | 시그니처 | 설명 |
|------|----------|------|
| `바닥` / `floor` | `(값:수) 바닥:수` | 내림 |
| `천장` / `ceil` | `(값:수) 천장:수` | 올림 |
| `자름` / `trunc` | `(값:수) 자름:수` | 0방향 절삭 |
| `반올림` / `round_ne` | `(값:수) 반올림:수` | Nearest-even |
| `소수부` / `fract` | `(값:수) 소수부:수` | 소수점 이하 |

### 3.4 삼각함수

| 함수 | 시그니처 |
|------|----------|
| `사인` / `sin` | `(각도:수) 사인:수` |
| `코사인` / `cos` | `(각도:수) 코사인:수` |
| `탄젠트` / `tan` | `(각도:수) 탄젠트:수` |
| `아크사인` / `asin` | `(값:수) 아크사인:수` |
| `아크코사인` / `acos` | `(값:수) 아크코사인:수` |
| `아크탄젠트` / `atan` | `(값:수) 아크탄젠트:수` |
| `아크탄젠트2` / `atan2` | `(y:수, x:수) 아크탄젠트2:수` |

### 3.5 지수/로그

| 함수 | 시그니처 |
|------|----------|
| `지수` / `exp` | `(값:수) 지수:수` |
| `지수2` / `exp2` | `(값:수) 지수2:수` |
| `로그` / `log` | `(값:수) 로그:수` |
| `로그2` / `log2` | `(값:수) 로그2:수` |
| `로그10` / `log10` | `(값:수) 로그10:수` |

### 3.6 기타 수학

| 함수 | 시그니처 | 설명 |
|------|----------|------|
| `제곱근` / `sqrt` | `(값:수) 제곱근:수` | |
| `역제곱근` / `rsqrt` | `(값:수) 역제곱근:수` | 1/sqrt(x) |
| `거듭제곱` / `pow` | `(밑:수, 지수:수) 거듭제곱:수` | |
| `빗변` / `hypot` | `(왼:수, 오른:수) 빗변:수` | sqrt(a²+b²) |

### 3.7 범위 제한

| 함수 | 시그니처 | 설명 |
|------|----------|------|
| `최소` / `min` | `(왼:수, 오른:수) 최소:수` | |
| `최대` / `max` | `(왼:수, 오른:수) 최대:수` | |
| `범위제한` / `clamp` | `(값:수, 최소:수, 최대:수) 범위제한:수` | min ≤ 결과 ≤ max |

### 3.8 보간

| 함수 | 시그니처 | 설명 |
|------|----------|------|
| `선형보간` / `lerp` | `(시작:수, 끝:수, t:수) 선형보간:수` | 시작 + (끝-시작)*t |
| `역선형보간` / `invlerp` | `(시작:수, 끝:수, 값:수) 역선형보간:수` | (값-시작)/(끝-시작) |
| `부드럽게` / `smoothstep` | `(시작:수, 끝:수, t:수) 부드럽게:수` | Hermite 보간 |

### 3.9 벡터 연산

| 함수 | 시그니처 | 설명 |
|------|----------|------|
| `거리` | `(a:위치, b:위치) 거리:수` | 유클리드 거리 |
| `크기` | `(v:벡터) 크기:수` | 벡터 길이 |
| `정규화` | `(v:벡터) 정규화:벡터` | 단위 벡터 |
| `내적` | `(a:벡터, b:벡터) 내적:수` | dot product |
| `외적` | `(a:벡터3, b:벡터3) 외적:벡터3` | cross product |

### 3.10 상수

| 상수 | 값 |
|------|-----|
| `원주율` / `pi` | 3.141592653589793... (Fixed64 근사) |
| `타우` / `tau` | 6.283185307179586... |
| `자연상수` / `e` | 2.718281828459045... |

### 3.11 각도 변환

| 함수 | 시그니처 | 설명 |
|------|----------|------|
| `도에서라디안` / `deg2rad` | `(값:수) 도에서라디안:수` | degrees → radians |
| `라디안에서도` / `rad2deg` | `(값:수) 라디안에서도:수` | radians → degrees |

---

## 4. 단위 시스템 — MUST

### 4.1 기본 SI 단위

| 단위 | 기호 | 차원 |
|------|------|------|
| 미터 | `@m` | 길이 |
| 초 | `@s` | 시간 |
| 킬로그램 | `@kg` | 질량 |
| 라디안 | `@rad` | 각도 |

### 4.2 유도 단위

| 단위 | 기호 | 정의 |
|------|------|------|
| 속도 | `@m/s` | m·s⁻¹ |
| 가속도 | `@m/s^2` | m·s⁻² |
| 뉴턴(힘) | `@N` | kg·m·s⁻² |
| 픽셀 | `@px` | (논리 좌표계) |

### 4.3 접두사

```ddn
단위 cm = 0.01 * m.
단위 km = 1000 * m.
단위 ms = 0.001 * s.
```


### 4.3.1 Gate0 지원 단위 목록 (정본)

Gate0 기준 구현은 아래 단위 기호들을 **최소**로 지원해야 한다. (추가 단위는 확장 가능)

| 범주 | 기호 | 기준 단위로의 스케일 | 비고 |
|------|------|----------------------|------|
| 길이 | `@m` | `1` | 기준 |
| 길이 | `@mm` | `1/1000 * m` |  |
| 길이 | `@cm` | `1/100 * m` |  |
| 길이 | `@km` | `1000 * m` |  |
| 시간 | `@s` | `1` | 기준 |
| 시간 | `@us` | `1/1,000,000 * s` |  |
| 시간 | `@ms` | `1/1000 * s` |  |
| 시간 | `@min` | `60 * s` |  |
| 시간 | `@h` | `3600 * s` |  |
| 질량 | `@kg` | `1` | 기준 |
| 질량 | `@g` | `1/1000 * kg` |  |
| 각도 | `@rad` | `1` | 기준 |
| 픽셀 | `@px` | (독립 차원) | SI 길이(`@m`)로 환산 없음 |

- `@deg`는 단위 기호로 지원하지 않는다. (각도 변환 함수 `deg2rad`/`rad2deg` 사용)
- `@m/s`, `@m/s^2`, `@N` 등 유도 단위는 위 기본 단위 조합으로 자동 유도되며, 표기상으로는 그대로 허용한다.

### 4.3.2 환산 실패 규칙 (Gate0, MUST)

- 알 수 없는 단위 기호 → `FATAL:UNIT_UNKNOWN`
- 차원 불일치 → `FATAL:UNIT_DIM_MISMATCH`
- `@px` ↔ SI 차원(예: `@m`) 환산 요청 → `FATAL:UNIT_NO_BRIDGE`
- Fixed64 오버플로/언더플로 → `FATAL:UNIT_OVERFLOW`
- Gate0의 수치/환산은 Fixed64 기반이며, 나눗셈/스케일 적용에서 절단이 발생할 수 있다. (정확한 규칙은 TOOLCHAIN §T8.2)

### 4.4 차원 검증 예시

```ddn
거리 = 100@m.
시간 = 2@s.
속도 = 거리 / 시간.   // 자동으로 @m/s

거리 + 시간.          // 컴파일 에러! 차원 불일치
```

---

## 5. 말결(Nuance) 매핑 — MUST

### 5.1 목적

`$꽤`, `$매우` 같은 부사 토큰을 0~1 퍼지 가중치로 매핑한다.

### 5.2 표준 매핑 테이블

| 토큰 | 가중치 | 의미 |
|------|:------:|------|
| `$전혀` | 0.0 | 완전 부정 |
| `$거의 안` | 0.1 | 미미 |
| `$조금` | 0.3 | 약함 |
| `$반쯤` | 0.5 | 중간 |
| `$꽤` | 0.7 | 상당 |
| `$매우` | 0.9 | 강함 |
| `$완전` | 1.0 | 최대 |

### 5.3 사용 예시

```ddn
$꽤 화나다.          // Emotion.arousal +<- 0.7
$매우 좋아하다.      // Relation.value +<- 0.9
$조금 걱정하다.      // Emotion.valence -<- 0.3
```

### 5.4 규칙 — MUST

- 말결 토큰이 없으면 기본값 **0.5** 사용
- 같은 문장에 여러 말결 토큰이 있으면 **마지막 것** 적용
- 부정어(`안`, `못`)와 결합 시 부호 반전

---

## 6. 표준 컴포넌트 — MUST

### 6.1 물리/공간 (Persistent)

| 컴포넌트 | 필드 | 설명 |
|----------|------|------|
| `위치` | `x:수@m, y:수@m` | 2D 좌표 |
| `속도` | `vx:수@m/s, vy:수@m/s` | 속도 벡터 |
| `가속도` | `ax:수@m/s^2, ay:수@m/s^2` | 가속도 벡터 |
| `회전` | `angle:수@rad` | 회전 각도 |
| `크기` | `w:수@m, h:수@m` | 너비/높이 |

### 6.2 시각 (Persistent)

| 컴포넌트 | 필드 | 설명 |
|----------|------|------|
| `생김새` | `asset:쓸감핸들, color:색` | 렌더링용 |
| `겹` | `z:정수` | 렌더 순서 |
| `보임` | `visible:참거짓` | 가시성 |

### 6.3 고차 상태 (Persistent)

| 컴포넌트 | 필드 | 충돌 정책 |
|----------|------|-----------|
| `감정` | `valence:수, arousal:수` | Accumulate |
| `기억` | `events:(기억사건)차림` | Append |
| `관계` | `target:엔티티, value:수, tags:(글)차림` | LastWin/Merge |

### 6.4 임시 (Transient)

| 컴포넌트 | 설명 | 수명 |
|----------|------|------|
| `로그` | 콘솔/화면 출력용 | 마디 종료 시 삭제 |
| `알림` | 이벤트 전달 | 마디 종료 시 삭제 |
| `소리` | 효과음 재생 요청 | 마디 종료 시 삭제 |
| `효과` | VFX 재생 요청 | 마디 종료 시 삭제 |
| `말풍선` | 대사 표시 | 마디 종료 시 삭제 |

---

## 7. 입력 함수 — MUST

### 7.1 콘솔/텍스트 입력

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `물어보기` | `(질문:글 ~을) 물어보기:글` | 콘솔 입력 요청 |

**결정론:** 실제 입력은 Sam이 InputSnapshot에 기록. 리플레이 시 기록된 값 사용.

### 7.2 키보드/마우스

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `눌렸나` | `(키:글 ~을) 눌렸나:참거짓` | 키 눌림 여부 |
| `막눌렸나` | `(키:글 ~을) 막눌렸나:참거짓` | 이번 마디에 새로 눌림 |
| `마우스위치` | `() 마우스위치:(수, 수)` | 마우스 좌표 |
| `마우스눌림` | `(버튼:정수 ~을) 마우스눌림:참거짓` | 마우스 버튼 상태 |

---

## 8. 결정적 난수 — MUST

### 8.1 함수

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `무작위` | `() 무작위:수` | 0~1 사이 난수 |
| `무작위정수` | `(최소:정수, 최대:정수) 무작위정수:정수` | 범위 내 정수 난수 |
| `무작위선택` | `(차림:(T)차림) 무작위선택:T` | 차림에서 무작위 선택 |

### 8.2 결정론 규칙 — MUST

- 난수 시드는 `InputSnapshot.rng_seed`에서 가져옴
- 동일 시드 → 동일 난수 시퀀스 보장
- 호출 순서도 결정적이어야 함 (시스템 실행 순서 고정)

---

## 9. 시간 함수 — MUST

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `마디번호` | `() 마디번호:정수64` | 현재 마디 번호 |
| `델타시간` | `() 델타시간:수@s` | 이번 마디의 dt |
| `게임시간` | `() 게임시간:수@s` | 누적 논리 시간 |

**주의:** `현재시각()` (wall-clock)은 결정론 위반이므로 제공하지 않는다.

---

## 10. 엔티티 관리 — MUST

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `새로` | `(종류:타입 ~을) 새로:엔티티` | 엔티티 생성 (다음 마디 활성화) |
| `지우기` | `(대상:엔티티 ~을)` | 엔티티 삭제 예약 |
| `있나` | `(대상:엔티티 ~이~가) 있나:참거짓` | 엔티티 존재 여부 |
| `모든` | `(종류:타입 ~의) 모든:(엔티티)차림` | 해당 타입 엔티티 목록 |

---

## 11. 컴포넌트 접근 — MUST

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `가져오기` | `(대상:엔티티 ~에서) (컴포넌트:타입 ~을) 가져오기:T?` | 컴포넌트 읽기 |
| `붙이기` | `(대상:엔티티 ~에) (컴포넌트:T ~을)` | 컴포넌트 추가 |
| `떼기` | `(대상:엔티티 ~에서) (컴포넌트:타입 ~을)` | 컴포넌트 제거 |
| `있나` | `(대상:엔티티 ~에) (컴포넌트:타입 ~이~가) 있나:참거짓` | 컴포넌트 존재 여부 |

---

## 12. 차림 연산 — MUST

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `길이` | `(차림:(T)차림 ~의) 길이:정수` | 요소 개수 |
| `첫번째` | `(차림:(T)차림 ~의) 첫번째:T?` | 첫 요소 |
| `마지막` | `(차림:(T)차림 ~의) 마지막:T?` | 마지막 요소 |
| `추가` | `(차림:(T)차림 ~에) (요소:T ~을)` | 끝에 추가 |
| `제거` | `(차림:(T)차림 ~에서) (인덱스:정수 ~을)` | 인덱스로 제거 |
| `정렬` | `(차림:(T)차림 ~을) (기준:함수 ~로~으로) 정렬:(T)차림` | 정렬된 새 차림 |
| `거르기` | `(차림:(T)차림 ~을) (조건:함수 ~로~으로) 거르기:(T)차림` | 필터링 |
| `변환` | `(차림:(T)차림 ~을) (함수:함수 ~로~으로) 변환:(U)차림` | 맵핑 |
| `합치기` | `(차림:(T)차림 ~을) (초기:U ~부터) (함수:함수 ~로~으로) 합치기:U` | 리듀스 |

---

## 13. 문자열 연산 — MUST

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `길이` | `(글:글 ~의) 길이:정수` | 문자 개수 |
| `합치기` | `(앞:글 ~과~와) (뒤:글 ~을) 합치기:글` | 문자열 연결 |
| `포함하나` | `(글:글 ~이~가) (패턴:글 ~을) 포함하나:참거짓` | 포함 여부 |
| `시작하나` | `(글:글 ~이~가) (패턴:글 ~로~으로) 시작하나:참거짓` | 접두사 확인 |
| `끝나나` | `(글:글 ~이~가) (패턴:글 ~로~으로) 끝나나:참거짓` | 접미사 확인 |
| `자르기` | `(글:글 ~을) (구분:글 ~로~으로) 자르기:(글)차림` | 분리 |
| `붙이기` | `(차림:(글)차림 ~을) (구분:글 ~로~으로) 붙이기:글` | 합치기 |
| `숫자로` | `(글:글 ~을) 숫자로:수?` | 파싱 |
| `글로` | `(값:T ~을) 글로:글` | 문자열 변환 |

---

## 14. 디버그/개발 — MAY

| 함수 | PinSpec | 동작 |
|------|---------|------|
| `단언` | `(조건:참거짓 ~이~가) (메시지:글 ~로~으로)?` | 조건 실패 시 panic |
| `중단` | `(메시지:글 ~로~으로)` | 즉시 실행 중단 |
| `로그` | `(레벨:글 ~로~으로) (메시지:글 ~을)` | 디버그 로그 |

---

## 15. 모듬 구조 — MUST

표준 라이브러리는 다음 모듬로 구성된다:

```
시스템/          # 샘, 마디, 시간
  마디
  dt
  난수시드
  키보드
  마우스

기본/            # 핵심 타입, 연산
  수, 글, 참거짓
  차림, 짝맞춤

수학/            # DetMath
  사인, 코사인, ...
  제곱근, 거듭제곱, ...

엔티티/          # ECS 접근
  새로, 지우기
  가져오기, 붙이기, 떼기

입출력/          # 입력/출력
  보여주기, 물어보기
  눌렸나, 마우스위치
```

---

## 16. 호스트 등록 확장 — MAY

### 16.1 `.ddn-lib` 매니페스트

```toml
plugin_id = "org.ddonirang.std.io"
name      = "표준입출력"
version   = "13.0.0"
det_tier   = "D-STRICT"
trace_tier = "T-PATCH"   # 플러그인/호스트 호출 추적 권장

[types]
"고정64" = "int64_t"
"글"     = "utf8_ptr_len"

[exports.functions]
"출력" = { args = ["문자열"], ret = "없음", purity = "io" }

[permissions]
network = false
filesystem = false
```

### 16.2 결정성 정책 연동 — MUST

| det_tier | 허용 purity |
|----------|-------------|
| D-STRICT | `det`만 |
| D-FAST | 제한 완화 *(구현체 정의)* |
| D-ULTRA | 제한 완화 *(구현체 정의)* |

> 참고: `D-LOG`는 det_tier가 아니라 `{D-STRICT + T-FULL}` 프리셋이므로,
> purity 규칙은 **D-STRICT**를 따른다.

---





## 15.1 이름공간(모듬/가지) — MUST

또니랑에서 “불러오기(import) 문”은 없습니다.  
대신 **이름공간(모듬)**을 고정하고, 모듬 선택/별칭/의존성은 **툴체인(ProjectMeta + gaji)**에서 처리합니다.

### 15.1.1 기본 규칙

- 모든 소스 파일은 정확히 1개의 **모듬**에 속한다. (MUST)
- 모듬은 최상위 이름공간이다. (MUST)
- 같은 모듬 안의 심볼은 짧은 이름으로 참조할 수 있다. (MAY)
- 다른 모듬의 심볼을 참조하려면 **점 접근**을 사용한다. (MUST)

```ddn
표준.수학.pi
물리.힘계산하기
```

### 15.1.2 모듬의 선택/별칭(툴체인 책임)

- 어떤 모듬을 프로젝트에 포함할지, 그리고 별칭을 무엇으로 줄지는 소스가 아니라 **ProjectMeta(차림표)**에서 정한다. (MUST)
- 소스는 “존재하지 않는 모듬/심볼”을 추측하지 않는다. (MUST)  
  해석 불가면 오류 + QuickFix(가능한 후보 목록)를 제공한다. (MUST)

### 15.1.3 정본 원칙

- 정본화기는 이름 충돌이 없도록(해석이 1개가 되도록) 필요한 경우 모듬 접두를 요구한다. (MUST)
- 도구는 자동 import 삽입을 하지 않는다. (MUST)


## 17. 산술 연산 의미론 — MUST

### 17.1 나눗셈 `/`

- `/`는 **절대 정수 나눗셈이 아니다**
- `/`의 결과는 항상 **비정수(실수/고정)**

**규칙:**
- 피연산자 중 하나라도 실수/고정이면 → 공통 타입으로 승격 후 `/`
- 둘 다 정수/자연이면 → 둘을 `수`(월드 기본 수치)로 승격 후 `/`

> 이렇게 하면 C처럼 "모르고 썼는데 정수 나눗셈"이 되는 사고를 원천 차단한다.

### 17.2 나머지 `%`

- `%`는 **정수/자연에만 허용**
- 실수/고정에서 나머지가 필요하면 `수학.나머지(x,y)` 사용

### 17.3 거듭제곱 `^`

| 조건 | 결과 |
|------|------|
| `B`가 정수이고 `A`가 정수 | 정수64 (오버플로는 모듈러) |
| 그 외 | 공통 수치 타입으로 승격 후 `pow` |

### 17.4 정수 오버플로

- 기본: **2의 보수 모듈러(랩 어라운드)**
- 검사 연산: `검사더하기(A,B)`, `검사곱하기(A,B)` → 오버플로 시 Panic 또는 `없음`


## 추가 §AI. AI-GYM 전용 함수

### AI.1 끝내 (MUST)

**[STDLIB-TERM-01] (MUST)**  
환경 종료 상태 설정.

**PinSpec:**
```ddn
끝내.
```

**동작:**
```ddn
// 상태 변형
심판.끝났나 <- 참.

// 종료 알림 전파 (선택)
(#종료)를 알리기.
```

**권장:** 상태 변형과 알림을 분리하여 명확한 의미 전달.

### AI.2 지금관찰 (MUST, 별칭: 눈떠)

**[STDLIB-OBS-01] (MUST)**  
대상 엔티티의 관찰씨를 즉시 벡터화.

**PinSpec:**
```ddn
지금관찰 (대상:엔티티 ~을~를)
```

**별칭 (ALLOW):**
```ddn
눈떠 (대상:엔티티 ~을~를)
```

컴파일 타임에 `지금관찰`로 치환.

**시점 규칙:**
- 런타임 자동 관찰: "Stage 5.5 (Post-Reactive)"
- 수동 트리거: 언제든지 가능 (디버깅/특수 케이스)

### AI.3 보상 (MUST)

**[STDLIB-REWARD-01] (MUST)**  
심판씨.보상_raw 갱신.

**PinSpec:**
```ddn
보상 (값:수 ~만큼)  // 누적 (add)
보상 (값:수 ~로~으로)    // 설정 (set)
```

**D-STRICT:**
- 내부: Fixed64
- 외부 통신: raw_i64 문자열

**예시:**
```ddn
(1.0)만큼 보상.      // reward += 1.0
(5.5)로 보상.        // reward = 5.5
```

---

## 추가 §뉘. 말결 토큰 매핑

### 뉘.1 말결 토큰 정의 (MUST)

**[STDLIB-NUANCE-01] (MUST)**  
말결 토큰은 `$어찌씨` 형태로 표현하며, 컴파일 타임에 Fixed64 가중치로 치환됩니다.

**표준 매핑:**

| 토큰 | 가중치 (Fixed64) | 비고 |
|------|------------------|------|
| `$전혀` | 0.0 | |
| `$거의 안` | 0.1 | |
| `$약간` | 0.2 | |
| `$조금` | 0.3 | |
| `$반쯤` | 0.5 | |
| `$꽤` | 0.7 | |
| `$매우` | 0.9 | |
| `$완전` | 1.0 | |

### 뉘.2 사용 예시

**예시 1: 기본 사용**
```ddn
주인공을 $매우 빠르게 움직이기.
// 컴파일 → 주인공을 0.9 비율로 빠르게 움직이기.
```

**예시 2: 조합 규칙**
```ddn
적을 $꽤 $조금 공격하기.
// 컴파일 → 0.7 * 0.2 = 0.14
```

### 뉘.3 부정과의 조합 (MUST)

**[STDLIB-NUANCE-NEG-01] (MUST)**  
부정과 말결이 함께 사용될 때:

```ddn
적을 $매우 안 공격하기.
// → (1.0 - 0.9) = 0.1 공격력
```

---

## 추가 §DetMath. 결정론적 수학 함수

### DetMath.1 룩업 테이블 (LUT) 기반 구현

**[STDLIB-DETMATH-01] (MUST)**  
삼각함수 등 복잡한 수학 함수는 LUT + 선형 보간으로 구현.

**참조:** LUT 쓸감(.dtm) 포맷/무결성/로드(없으면 구동 거부) 규약은 `SSOT_TOOLCHAIN §T6.1.1`을 따른다(MUST).

**표준 함수:**
- `(각도:수) 사인:수`
- `(각도:수) 코사인:수`
- `(각도:수) 탄젠트:수`
- `(값:수) 제곱근:수`
- `(값:수) 절댓값:수`

### DetMath.2 입력/출력 (MUST)

**[STDLIB-DETMATH-IO-01] (MUST)**  
- 입력: Fixed64
- 출력: Fixed64
- 부동소수점 호출 **절대 금지**

### DetMath.3 도메인 오류 처리

**[STDLIB-DETMATH-ERR-01] (MUST)**  
`(값=음수) 제곱근하기` 같은 도메인 오류:
- 결과: 0
- 대입 무효화
- `#도메인오류` 고장 기록

**예시:**
```ddn
결과 = (값=-1) 제곱근하기.
// 결과는 변경되지 않음 (대입 무효화)
// 엔티티에 #고장(#도메인오류) 부착
```

---

## 추가 §입력키. 입력키 표준 함수(compat/strict)

### 입력키.1 `입력키` (compat) — MAY (AGE1)

**[STDLIB-INPUTKEY-01] (MAY)**  
`입력키`는 현재 샘(InputSnapshot)에서 “마지막 입력 키”를 글로 돌려준다.

- 정의되지 않은 경우 기본값은 **빈 글 `""`** (compat) 이다.
- 이 기본값은 **호환(compat) 편의**이며, 엄격 사용자는 `입력키?` 또는 `입력키!`를 사용한다.

시그니처:
- `() 입력키:글`

### 입력키.2 `입력키?` (권장) — SHOULD (AGE1+)

**[STDLIB-INPUTKEY-OPT-01] (SHOULD)**  
정의되지 않음을 안전하게 구분하기 위해 옵션 반환 버전을 제공한다.

- `() 입력키?:글?`
- 키가 없으면 `없음`을 반환한다.

### 입력키.3 `입력키!` (엄격) — SHOULD (AGE2)

**[STDLIB-INPUTKEY-STRICT-01] (SHOULD)**  
키가 없으면 즉시 실패한다.

- `() 입력키!:글`
- 실패: `E_INPUTKEY_MISSING`

> 린트(권장): `입력키`의 빈 글 기본값을 사용하는 코드는 `L_STDLIB_INPUTKEY_EMPTY_DEFAULT`로 경고할 수 있다.

## 추가 §글. 글바꾸기 표준 함수

### 글.1 `글바꾸기` (안전) — MAY

**[STDLIB-STR-REPLACEAT-01] (MAY)**  
`글바꾸기(글, 인덱스, 새글)`은 주어진 글의 특정 위치를 새글로 교체한다.

- 인덱스 범위 밖이면 **원본 글을 그대로 반환**한다(안전 동작).
- 인덱스는 0-based로 정의한다.

시그니처:
- `(원본:글, 인덱스:수, 새글:글) 글바꾸기:글`

### 글.2 `글바꾸기!` (엄격) — SHOULD

**[STDLIB-STR-REPLACEAT-STRICT-01] (SHOULD)**  
범위 밖이면 즉시 실패한다.

- `(원본:글, 인덱스:수, 새글:글) 글바꾸기!:글`
- 실패: `E_STR_INDEX_OOB`

## 추가 §매틱. 매틱 진입 호환(문서용) — MAY (Gate0/Compat)

**[LANG-MATIC-ENTRY-COMPAT-01] (MAY)**  
문서/레거시 예제 호환을 위해 아래 표면을 **입력에서만** 허용할 수 있다.

- 입력(compat): `매틱:움직씨 = { ... }`
- 정본 출력(canon): 표준 표면(정본 AST 전개)으로 **반드시 치환**한다.

규칙:
- Gate0/compat 모드에서만 허용한다. (strict 모드에서는 `E_LANG_COMPAT_MATIC_ENTRY_DISABLED`)
- 치환은 의미를 바꾸지 않아야 하며, 정본 출력은 “조사/핀/괄호 정본 규칙”을 따른다.

## PinSpec(핀 스펙) — 상세 구현 노트

PinSpec의 정본(문서 표기/결정 규칙)은 본 문서의 **27장(PinSpec)**에 포함되어 있다.
여기서는 중복을 피하기 위해 추가 설명을 생략한다.


## 추가 §단위. 단위 시스템 확장

### 단위.1 @ 기호 표준화 (재확인)

**[STDLIB-UNIT-01] (MUST)**  
단위는 `숫자@단위` postfix로만 사용.

**예시:**
```ddn
거리 = 10@m.
시간 = 3.5@초.
속도 = 거리 / 시간.  // 자동 환산
```

### 단위.2 자동 환산 규칙

**[STDLIB-UNIT-CONV-01] (SHOULD)**  
표준 라이브러리는 SI 단위 자동 환산 제공:

```ddn
거리1 = 1000@m.
거리2 = 1@km.
같나 = (거리1 == 거리2).  // 참
```

---

## 추가 §쓸감. 자원 핸들 시스템


### 쓸감.1 쓸감 리터럴 (MUST)

**정본 표기:**

```ddn
핸들 = "캐릭터/주인공.png" 쓸감.
```

- `자원`은 **글(경로/키)**를 받아 **쓸감핸들**을 만든다.
- 실패 시: **런타임 오류(자원 없음)**를 발생시킨다.
- 구현은 호스트(파일시스템, 묶음, CDN, 레지스트리 등)별로 달라질 수 있으나, 결과는 **핸들**로 정규화한다.

> `@"..."` 표기는 `"..." 쓸감.`의 문법 설탕이다.
### 쓸감.2 @ 문법 설탕 (MAY)

**[STDLIB-ASSET-SUGAR-01] (MAY)**  
```ddn
주인공.생김새 <- @"캐릭터/주인공.png".
// 컴파일 타임에 치환:
주인공.생김새 <- "캐릭터/주인공.png" 쓸감.
```

**중요:** `@"..."` 형태만 허용 (문자열 강제).

---



## GOAP (목표 지향 계획) — 예약

이 절은 **예약(Reserved)**이다.
- v14.0에서는 GOAP의 **개념/용어만 유지**하고, 구체 API/자료형/예제는 후속 버전에서 정본화한다.
- `{}`가 **사전/레코드 리터럴**처럼 보이는 예제는 금지이며, 자료형은 `(필드) ( )` 규칙에 맞춰 별도로 설계한다.


## 추가 §G. 확장 구문 프레임 — MUST

확장은 “언어를 무한히 키우는 것”이 아니라, **핵심 의미론(정본화·결정성)** 을 유지한 채로 *표면 문장*과 *표준 라이브러리*를 늘리는 방식이어야 합니다.

### §G.1 원칙
- **(MUST)** 모든 확장 구문은 **정본 AST**로 **완전 변환 가능**해야 합니다. (확장 전용 런타임 의미론 금지)
- **(MUST)** 변환 결과는 `SSOT_LANG`의 문법·의존성 규칙을 그대로 따른다.
- **(MUST)** 결정성 모드(D-STRICT)에서 확장은 **무작위/시계/외부 네트워크**를 직접 사용하지 못한다.  
  필요 시 `샘(Sam)`을 통해 입력으로 주입하고 동결한다.
- **(SHOULD)** 확장은 “새 예약어”보다 **꾸러미(라이브러리) + 표준 함수**로 먼저 제공한다.

### §G.2 확장 블록(예시)
- `지식{ ... }` / `규칙{ ... }` 같은 블록은 “표면 구문”이며,
  내부적으로는 **표준 자료구조(집합/목록/사전) + 함수 호출**로 변환되는 것을 원칙으로 한다.

> 개별 확장(예: Prolog/추론, NuriGym, Manim 어댑터, 로봇/솜씨)은 `SSOT_LANG.md`의 **LANG 확장(가지)** 섹션 및 `ROADMAP.md`의 가지 항목에 정의한다. (GAJI는 코어와 분리된 **세트 외 보조/선택 카탈로그**로 유지한다. GAJI의 규범은 “활성화된 경우(MUST-IF-ENABLED)”에만 강제된다.)

### [NAMING-LINT-01] 조사 단독 금지 + 조사 접미사 자동 분리 — MUST/SHOULD (Gate0)

한국어 단어는 끝글자가 `이/가/로/...`로 끝나는 경우가 많으므로, **해당 글자 자체를 금지하지 않습니다.**  
대신 Gate0는 **붙임형(띄어쓰기 없이 적힌 ‘이름+조사’)**을 결정적으로 해석하기 위해 아래 규칙을 강제합니다.

#### 1) 금지(예약) — MUST
- 다음 **조사별칭 자체(단독)**는 식별자(그릇/말뚝/이름씨)로 사용할 수 없습니다:  
  `이, 가, 을, 를, 과, 와, 로, 으로, 에, 에서, 에게, 의, 도, 만, 까지, 부터, 처럼, 보다`  
  *(Gate0 기본 목록; 확장/추가는 Minor로만 허용)*

#### 2) 해석 우선순위 — MUST
Gate0 파서는 어절(공백으로 분리된 토큰) `T`에 대해 아래를 순서대로 적용합니다.

1. **물결 경계가 있으면** (`~` 포함):  
   `X~Y`이면 `X`는 이름씨, `Y`는 조사(또는 핀/접미)로 확정합니다.
2. **물결이 없고**, `T`가 현재 스코프에서 **유효한 이름(정의됨)**이면:  
   `T` 전체를 하나의 이름씨로 채택합니다. *(조사 분리하지 않음)*
3. 위가 아니면, `T`의 끝에서 Gate0 **조사별칭 목록**을 **가장 긴 것부터** 매칭하여 `T = S + J` 분리를 시도합니다.
   - `S`가 현재 스코프에서 유효한 이름이면 → `S`를 이름씨, `J`를 조사로 채택합니다.
   - `S`가 유효하지 않으면 → 분리를 포기하고 `T` 전체를 하나의 이름씨로 유지합니다. *(이름 미정이면 일반 오류)*

> 사용자가 **조사 해석을 강제**하려면 언제나 `~`로 경계를 명시합니다. (`사과~를`, `도~로`)

#### 3) 정본화 — MUST
- 2-3 규칙으로 조사 분리가 발생한 경우, 정본화기는 **반드시 `~`를 삽입**하여 `S~J` 형태로 출력합니다.

#### 4) 린트 — SHOULD
- `T`와 `S`가 **모두** 스코프에서 유효한 이름이고, `T`의 끝이 조사별칭으로 보이는 경우, 린트는 “조사 의도면 `S~J`로 명시” 경고를 냅니다.
  - 예: `사과`와 `사과를`이 모두 존재하는데 `사과를`을 썼다면 → “조사 의도면 `사과~를`”

#### 5) 예시
- 허용(자연어): `이유`, `가구`, `도로`, `모르는것` 등
- 붙임형 입력(설탕): `도로를` *(단, `도로`가 정의되어 있고 `도로를`이 정의되어 있지 않을 때 `도로~를`로 정본화)*
- 의도 명시:
  - `도로~를` : 항상 `도로 + 를`
  - `사과~를` : 항상 `사과 + 를`


---

## §NEW (v20.1.2) 가지(gaji) 메타데이터와 기능 게이트 선언

문법을 늘리지 않기 위해, 기능 허용/금지는 **가지(package)/도구 메타데이터**에서 선언한다.

### 1) 가지 메타데이터(gaji.toml) — 정본 (B안)

```toml
# gaji.toml (정본, 예시)
name = "표준_철학_감정실험가지"
version = "0.1.0"

[requires]
ssot_requires = "20.1.5"
age_target    = "AGE1"
det_tier      = "D-ULTRA"
openness      = "open"   # "closed" | "open"
```

- 입력 별칭(레거시): `pack.toml`  
  - 툴체인은 **읽어주되**, 정본 문서/정본 출력에서는 `gaji.toml`을 사용한다.
- (B안) `requires.*`는 **도트 키(`requires.det`)를 쓰지 않고**, 반드시 `[requires]` 테이블로 쓴다.

### 2) 강제 규칙

- 프로젝트 det_tier/openness가 요구 조건을 만족하지 못하면 로딩/빌드 실패 MUST
- 표준가지는 가능한 한 D-STRICT/closed에서도 동작하도록 설계하되,
  “세계 의미를 바꾸는 실험”은 반드시 D-ULTRA/open로 격리 SHOULD

### AGE2(Open) 지시문
- `#열림 허용(...)` : 열림(Open) 범주 선언(가독성/도구 진단용). 실행 허용/차단은 open 모드 정책이 결정한다. (DR-093)


### AGE3(Bogae) 출력 결정성
- 보개 렌더링의 정본 대상은 픽셀이 아니라 `detbin`과 `bogae_hash`이다. `bogae_hash=blake3(detbin)`로 고정한다. (DR-094)


### 좌표변환 표준(격자→픽셀)
- 격자 좌표를 픽셀 좌표로 바꾸는 표준 호출 형태는 `(대상=..., 원점=..., 셀=...) 격자.픽셀.` 이다. (DR-096)


### 용어(순우리말)
- entity는 `임자`, component는 `붙이`, binder는 `매김이`로 표기한다. entity 참조는 `임자가리킴`을 사용한다. (DR-097)


### 임자무리(임자가리킴 차림)
- 임자 이름은 값 위치에서 `임자가리킴`으로 평가될 수 있으며, 이를 차림에 담아 반복 갱신할 수 있다. (DR-098)

---

## 셈씨 규칙 보강(v20.4.1)

### [SEMSI-RESULT-01] 셈씨 결과칸(결과 이름 대입) — MUST

정의:
- 셈씨 선언이 `(… )이름:형:셈씨 = { … }.` 형태일 때, 본문 블록 안에서 **`이름`은 결과칸(암묵 바인더)** 으로 취급된다.
- 결과칸에 마지막으로 대입된 값이 셈씨의 결과가 된다.

예:
```ddn
(가:수~를, 나:수~에)더:수:셈씨 = { 더 <- 가 + 나 }.
```

규칙:
1) 결과칸은 **섀도잉 금지**
   - 매개변수/지역 바인더/임시 이름이 결과칸 이름과 같으면 오류.
2) 결과칸은 **최소 1회 이상** 대입되어야 한다(권장: 오류 `E-SEMSI-RESULT-UNSET`).
3) 결과칸 대입은 여러 번 가능하며, **마지막 대입이 결과**가 된다.
4) 결과값은 선언된 결과 형(`:수`)과 호환되어야 한다(불일치 시 오류).

비고:
- 호출 형태(정의/호출 분리 규칙 준수):
  - 셈씨 “정의 이름”은 꼬리 없이 쓴다(예: `더`).
  - 실행/호출은 **`~기/~하기` 꼬리**로 표현한다(예: `더하기`).
  - 인자(괄호)는 **앞에 온다**: `(가, 나)더하기.`

- 조사 정본:
  - 입력은 붙여 쓸 수 있으나, 정본 출력에는 `~`로 조사 경계를 반드시 드러낸다.
    - 예: `(가:수~를, 나:수~에)더:수:셈씨`

- “반환 키워드/셈씨”:
  - `돌려(…)` 같은 형태는 우리 호출 규칙(인자 앞, 꼬리로 실행)에도 맞지 않으며, **정본 문법에 존재하지 않는다.**
  - 반환은 `더 <- …`처럼 **결과칸 대입**으로만 표현한다.

---

### [FILE-META-01] DDN 파일 메타 헤더(`#키: 값`) — SHOULD (도구 호환)

목적:
- DDN 파일 상단에서 `#이름:`, `#설명:` 같은 **파일 메타**를 표준화하여,
  “문법인가/주석인가/도구 전용인가” 혼란을 제거한다.

표기:
- 파일 맨 위에 한해, 연속된 **메타 헤더 블록**을 허용한다.
- 한 줄 형식: `#키: 값`  (콜론 `:` 포함)
  - `#키`(콜론 없음) 는 원자(Atom) 토큰으로 취급되며, 메타 헤더와 구분된다.

표준 키(최소):
- `#이름:`  파일/프로그램/입력의 이름
- `#설명:`  한 줄 요약 (별칭: `#풀이:`)
- `#말씨:`  파일 말씨(표기) 고정 (`ko|en|sym3|ja|mn|tr|qu|ay|ne|ta|te|kn|eu`) — **의미는 같고 표기/린트만** 달라진다
  - 별칭: `#사투리:`
- (선택/확장) `#버전:`, `#태그:` 등은 추후 합의

위치/종료:
- 메타 헤더는 **파일 최상단**에서만 허용한다.
- 빈 줄은 허용하되, 코드 문장이 한 번이라도 나오면 헤더는 종료된다(이후 `#키:`는 메타가 아님).

의미:
- 메타 헤더는 **실행 의미를 바꾸지 않는다.**
- 파서 AST에는 포함되지 않으며, 도구가 참고하는 **파일 메타데이터**로만 보존한다.

중복 키:
- 같은 키가 여러 번 나오면 **마지막 값을 우선**하고, 경고(권장)한다.

---

### [BOGAE-CONTRACT-01] 보개 계약(뷰 인터페이스) — SHOULD (교육/팩/셈그림)

목적:
- 사용자 DDN이 “어떤 값을 내보내야 어떤 보개가 표시되는지”를 명확히 하여,
  custom DDN/lesson/pack이 같은 규칙으로 작동하게 한다.

핵심:
- 보개는 DDN 실행 중 “내보내진 채널(이름→알맹이)”을 입력으로 받아 표시한다.
- 각 보개는 **필수 채널**(있어야 동작)과 **선택 채널**(표시 품질/보조)을 가진다.

#### [BOGAE-EMIT-01] 채널 내보내기(보여주기) — SHOULD
- 표준 문장: `<이름> 보여주기.`
  - 의미: 현재 시점(또는 현재 행/프레임)의 `<이름>` 알맹이를 “출력 채널”로 기록한다.
  - `<이름>`은 그릇/붙박이/결과칸 등 “값을 가진 이름”이어야 한다.
- 값꾸러미(예: `(x=..., y=..., 라벨=...) 값꾸러미`)를 `<이름>`으로 내보내는 것을 허용한다.

예:
```ddn
t 보여주기.
x 보여주기.
y 보여주기.
```

#### [BOGAE-TIME-01] 시간 채널 `t` — SHOULD
- `t` 채널이 있으면 보개는 이를 “시간/순서 축”으로 사용한다.
- `t`가 없으면 보개는 행 번호(0,1,2,…)를 `t`로 간주할 수 있다(도구 정책).


### [BOGAE-UPDATE-01] 보개 갱신 규칙: update=append|replace (+ 선택적 tick) — SHOULD

목적:
- 보개가 “새 데이터가 들어왔을 때” 기존 표시를 어떻게 갱신하는지 표준화한다.
- custom DDN/lesson/pack이 동일 규칙으로 재현되게 한다.

규칙(권장):
- 채널 기록은 `update` 정책을 가질 수 있다.
  - `append`: 기존 표시(시계열/점열/행들)에 추가한다.
  - `replace`: 기존 표시를 통째로 교체한다.
- 선택적 `tick`(마디):
  - 있으면 “이 기록이 속한 마디”를 나타낸다. (보개는 타임줄/스크럽과 연결 가능)
  - 없으면 행 번호/기본 tick으로 간주할 수 있다(도구 정책).

비고:
- 실제 저장 포맷(예: graph.v0/snapshot.v0/session.v0)은 도구/솔루션 스키마에서 정의하되,
  **갱신 의미**는 이 규칙을 따른다.


### [INPUT-REGISTRY-01] 입력원 레지스트리 — SHOULD (셈그림)

목적:
- UI를 “수식/DDN 토글”이 아니라, 여러 입력원을 동등하게 취급하는 레지스트리로 확장한다.

정의(초안):
- 입력원은 다음 중 하나(또는 조합)로 구성된다:
  - `ddn` (정본 실행 입력)
  - `formula` (DDN 생성 설탕; 적용 후에도 원본 보존)
  - `lesson` (required_views + meta.toml + lesson.ddn)
  - `dataset` (표/통계/회귀용 입력)
  - `control` (조절기/드래그 등 직접조작 입력)
- UI/세션 저장은 “현재 선택된 입력원 + 레지스트리 목록”을 보존할 수 있어야 한다.

비고:
- DDN-first 원칙은 유지한다: 실행의 정본은 항상 DDN이다.



---

### [BOGAE-VIEWSET-01] required_views(교과/lesson) — SHOULD

- lesson(교과) 메타는 `required_views` 또는 동등 필드로 “필수 보개”를 선언한다.
- 값은 5종 보개 타입 식별자 집합으로 제한한다.

정본 식별자(working):
- `"2d" | "graph" | "table" | "text" | "structure"`

원칙:
- “표현 원형(교육 분류) 4종”과 “구현/팩 기준 5종 보개”는 충돌하지 않는다.
  - 축/좌표 ≒ graph
  - 공간(2D/3D) ≒ 2d
  - 표 ≒ table
  - 지도·연표 ≒ structure(레이아웃 규약)
  - 설명/편집/검증 ≒ text

---

### [BOGAE-IF-01] 보개별 필수 채널(최소)

> 아래 표는 “custom DDN”이 어떤 이름을 `보여주기` 해야 하는지의 최소 규약이다.

1) 보개/그래프(graph)
- 필수(택1):
  - `x` + `y`  (XY 그래프)
  - 또는 `t` + `y` (시계열)
- 선택: `무리`(series id), `라벨`, `색`, `z`(3D는 향후)

2) 보개/2D(2d)
- 필수: `그림` (2D DrawList 또는 동등 구조)
- 선택: `t`, `카메라`, `줌`, `레이어`

3) 보개/표(table)
- 필수(택1):
  - `행` (값꾸러미 1행)
  - 또는 `행들` (값꾸러미 목록)
- 선택: `t`, `열이름들`, `정렬`, `단위`

4) 보개/글(text)
- 필수: `글` (마크업 텍스트)
- 선택: `제목`, `t`, `로그들`(경고/검증)

5) 보개/구조(structure)
- 필수(택1):
  - `마디들` + `잇기들` (노드/간선)
  - 또는 `벡터장` (화살표장; 초기에는 2D 표현)
- 선택: `라벨`, `강조`, `레이아웃`, `t`

확장(권장; 5종 보개 안에서 표현):
- 지도/연표: structure로 표현(마디=지점/시간, 잇기=경로/의존)
- 집합: table(text)+structure(포함관계) 조합으로 표현
- 경제/간단 심즈: 2d(에이전트 위치)+graph(가격/수요)+table(상태)로 합성

---

### [CROSS-VIEW-01] 보개 동기화(맞물림) — SHOULD (교육 효과)

목적:
- graph/table/2d/structure/text 간에 “같은 시간/같은 상태”를 동시에 보게 하여 학습 효율을 높인다.

동기화 기준(권장):
1) `tick`(마디) 우선:
- 기록에 `tick`이 있으면, 보개는 같은 `tick`에 해당하는 항목을 하이라이트/스크럽한다.

2) `t`(시간) 차선:
- `tick`이 없고 `t`가 있으면, 보개는 같은 `t`(또는 가장 가까운 t)를 기준으로 맞춘다.

3) `id`(식별) 선택:
- 점/행/마디에 `id`가 있으면, 클릭한 항목의 `id`를 다른 보개에서 찾아 하이라이트할 수 있다(도구 정책).

UI 권장 동작:
- graph 클릭 → 동일 tick/t의 2d 위치, table 행, text 문단을 함께 강조
- table 클릭 → graph 점/구간 강조 + 2d 상태 강조
- structure 선택(노드/간선) → 관련 변수/수식/행/곡선 강조(가능한 범위에서)


### [STRUCTURE-IDENTITY-01] 보개/구조의 정체성(생각의 지도) — SHOULD

정의:
- 구조 보개는 “수식 이전에 개념의 연결”을 표현하는 보개다.
- 동일 계약으로 인과지도(causal loop), 결정트리(decision tree), 회로도(circuit) 등으로 확장할 수 있다.

권장 채널(재사용):
- 필수: `마디들` + `잇기들`
- 선택: `레이아웃`, `강조`, `무리`, `t/tick`

권장 데이터 형식(값꾸러미):
- 마디(노드): `{id, 이름, 종류, 값(선택), 위치(선택)}`
- 잇기(간선): `{from, to, 이름(선택), 종류(선택), 굵기(선택), 방향(기본 true)}`

특수화(종류 예):
- 인과지도: 간선 종류 = `증가/감소/지연` 등
- 결정트리: 노드 종류 = `질문/결정/결과`, 간선 이름 = 선택지
- 회로도: 노드 종류 = `전원/저항/접지/...`, 간선 종류 = `도선`


### [OVERLAY-PEDAGOGY-01] 비교(겹)의 교육학 — SHOULD

목적:
- 정답/이상 모델과 학습자 결과를 겹쳐 “차이”를 시각적 잔상으로 이해하게 한다.

권장 패턴:
- 정답겹(A) + 내겹(B) 두 겹을 기본으로 제공한다.
- 레이어 이름/역할을 메타로 보존한다(세션/스냅샷):
  - `role = "answer" | "student" | "baseline" | "variant"`

사례:
- 이상 vs 실제(마찰 0 vs 마찰 포함)
- 감도 분석(세율 10% vs 20%)

---

### [SCENE-BLOCK-01] `보개장면 { ... }` — SHOULD (한국어 Manim, AGE1+)

목적:
- DDN 안에서 “시간축 기반 연출(장면)”을 **선언형으로 기술**한다.
- DDN-first를 유지한다: 계산 정본은 DDN이며, 보개장면은 **연출 메타/트랙**만 만든다.

원칙:
- 보개장면은 **보개 내부 렌더링에 간섭하지 않는다.**
  - 픽셀/좌표/프레임을 직접 명령하지 않고, scene.v0에 들어갈 “연출 상태”만 선언한다.
- Gate0에서는 **파싱/정본화만** 지원(실행은 AGE1 이후).
  - Gate0 실행 시: `W-NOT-IMPLEMENTED-AGE1: 보개장면` 경고(권장).

문법(초안):
```ddn
보개장면 {
  마디0 (tick=0~60): {
    (#제목, 글="포물선의 변신") 나타나기.
  }

  마디1 (tick=60~180): {
    (#곡선, 식=포물선, 범위=(-1,5), 색="#ff0000", 보개="graph1") 그려지기(방식="실시간").
  }
}
```

- `마디N (...) : { ... }` 는 시간 구간을 정의한다.
- 마디 안의 문장은 “연출 명령”이며, **인자 앞 규칙**을 따른다.
  - `(#곡선, ... ) 그려지기( ... ).` 처럼 “대상(#태그...) + 연출옵션”이 인자로 들어간다.

시간 표기(결정성):
- 정본은 `tick` 정수 범위이다: `tick=a~b`.
- 초 표기는 설탕으로 허용할 수 있다(AGE1 도구):
  - `0초~5초` → fps(초당프레임)로 tick 변환
  - 단, `초 * fps`가 정수로 떨어지지 않으면 오류(반올림 금지).

장면물체 태그(working):
- `#제목` : text 보개에 표시할 제목
- `#곡선` : graph 보개에 그릴 곡선(식/범위 참조)
- `#점` : graph 또는 2d의 강조점
- `#진자` : 2d에 “진자 프리셋”으로 표시(교육용 설탕)
- `#기록` : table에 로그/행 추가
- `#자막` : 자막(해설) 트랙의 텍스트
- `#해설` : (향후) 음성 합성/내레이션 메타를 포함한 해설

연출동사(최소 5개):
- `나타나기`, `사라지기`, `그려지기`, `움직이기`, `강조하기`
- (선택) `깜빡이기`는 `강조하기(횟수=...)`의 별칭.

타깃(보개 id):
- `보개="graph1"` 같이 보개 id를 명시할 수 있다.
- 명시가 없으면 lesson의 `required_views` 및 장면차림의 기본 보개로 라우팅한다(도구 정책).

출력(정본):
- `보개장면`은 `seamgrim.scene.v0.json`로 정본화된다.
- scene.v0는 실행 의미를 바꾸지 않는 “연출 트랙”이며, Scene Summary(JSON)에 포함될 수 있다.

---

### [NARRATIVE-TRACK-01] 해설/자막 트랙 — SHOULD (교육/AI 연동)

목적:
- 수식/그래프/2D와 함께 “설명”을 시간축에 맞춰 제공한다.
- 향후 TTS/LLM 연동의 소스로 사용할 수 있도록 정본 데이터를 남긴다.

표현(권장):
- `보개장면`에서 `#자막`/`#해설` 태그를 사용한다.
- 예:
```ddn
보개장면 {
  마디0 (tick=0~60): {
    (#자막, 글="이제 중력에 의해 아래로 가속됩니다.") 나타나기.
    (#해설, 글="중력가속도 g", 토큰="g") 강조하기.
  }
}
```

### [TIMEBOOKMARK-01] 시간의 조각(책갈피) — SHOULD (타임줄/디버그/되감기)

목적:
- 타임줄 스크럽 또는 디버깅에서 특정 tick으로 “되감기/점프”를 빠르게 수행한다.
- 결정성을 유지한다: 책갈피는 **캐시**일 뿐, 결과 의미를 바꾸지 않는다.

정의(초안):
- 책갈피는 `{tick, state_hash}` 쌍이며, 선택적으로 “저장된 상태 스냅샷”을 가리킬 수 있다.
- Scene Summary 또는 session에 `bookmarks[]`로 포함될 수 있다.

규칙(권장):
- 책갈피는 UI/도구가 생성할 수 있으며, DDN 실행 의미와 무관하다.
- 책갈피가 있더라도, 전체 결과는 “정본 재계산”으로 검증 가능해야 한다(캐시 미사용 모드).

### [INVERSE-CONTROL-01] 만져지는 수식(역조작) — SHOULD (control 입력원)

목적:
- 사용자가 2D(또는 graph)에서 “만져서” 파라미터를 바꾸고, DDN-first로 재실행한다.

규칙(권장):
- 드래그/슬라이더 같은 직접조작은 `control` 입력원으로 수집된다([INPUT-REGISTRY-01]).
- 직접조작은 “연속 스트림”이 아니라, **확정 순간(예: drag_end)** 에서만 `마련` 값(또는 그릇 초기값)을 갱신하도록 한다.
  - 이유: 결정성/팩 검증 단순화 + 불필요한 재실행 폭증 방지
- control → 파라미터 매핑은 “화이트리스트”로 제한한다(임의 코드 실행 금지).
  - 예: `theta0`, `L`, `m`, `omega0` 등

---

### [SPACE2D-DRAWLIST-01] space2d(2d) drawlist primitive — MUST (C+)

정본:
- 2d 보개의 입력은 `그림` 채널의 drawlist(v0)로 통일한다.
- drawlist는 “도형 명령 값꾸러미”의 목록이다.
- drawlist 좌표는 **월드 좌표**다(카메라 변환으로 화면 표시).

필수 primitive (C+):
- `선` : (시작, 끝, 색, 굵기)
- `원` : (중심, 반지름, 채움, 테두리)
- `점` : (위치, 크기, 색)
- `선들`(폴리라인) : (점들, 색, 굵기)
- `사각형` : (중심 또는 좌상단, 너비, 높이, 채움, 테두리)
- `다각형` : (점들, 채움, 테두리)
- `글` : (위치, 내용, 크기, 색)
- `화살표` : (시작, 끝, 색, 굵기, 머리크기)

---

### [CONTROL-META-01] control 정의를 DDN 메타(`#키: 값`)로 제공 — SHOULD

정본 키:
- `#control:` (정본 권장)
- `#조절:` (한국어 별칭; 입력 호환)

형식(권장; 한 줄):
- 세미콜론으로 항목 분리
- 각 항목: `이름:형=기본값 [min..max] step=... unit=...`

예:
```ddn
#control: L:수=1.0 [0.2..3.0] step=0.01 unit=m; theta0:수=0.6 [-1.57..1.57] step=0.01 unit=rad
```

규칙:
- control 변화는 `control` 입력원으로 들어가며, **확정 순간(drag_end/commit)** 에만 마련 값 갱신 후 DDN 재실행(결정성 유지).
- 매핑 대상은 화이트리스트로 제한한다.

---

### [OVERLAY-PARAM-01] 오버레이(겹) 정본: 파라미터 비교 baseline+variant — SHOULD

정의:
- 오버레이는 **같은 모델/같은 축 의미**에서 파라미터만 바꿔 결과 변화를 비교하는 기능이다.
- baseline 1개 + variant 1개(2겹)로 시작하고, 이후 N개로 확장한다.

규칙(권장):
- graph 오버레이는 x/y 의미(단위 포함)가 동일해야 한다. (이종 오버레이 금지)
- 2d 오버레이는 동일 좌표계/카메라 설정에서만 허용한다.
- 겹 메타에 `role="baseline"|"variant"` 및 `params` 요약을 보존한다(session/snapshot).

---

### [SCENE-DRAW-MODE-01] `그려지기` 구현 모드: A(progress) → B(append) 확장 — SHOULD

A(progress):
- 데이터(점열/도형)는 이미 완성되어 있고, 표시 진행률(progress)만 0→1로 변화한다.

B(append):
- tick마다 `update=append`로 점/행이 실제로 누적되어 “그려지는” 효과를 만든다.

정본 단계:
- AGE1 최소 구현은 **A(progress)** 를 먼저 채택한다.
- 이후 확장으로 B(append)를 지원한다.

---

### [PHYS-BACKEND-01] 물리 백엔드: A(계산) + B(매임/엔진) 공존 — SHOULD

A(계산):
- DDN이 θ(t) 또는 상태를 직접 계산하고 drawlist/series로 출력한다.

B(엔진):
- DDN이 물체/매임(제약)을 선언하고, 결정적 솔버가 상태를 계산한다.

운영:
- backend 선택은 DDN 메타로 제공 가능(예: `#physics_backend: calc|constraint`).

---

### [GRAPH-KIND-01] graph 보개 종류(`graph_kind`) — MUST (v0)

v0 표준 목록:
- `timeseries` : (t,y) 시계열
- `xy_line` : (x,y) 선 그래프
- `scatter` : (x,y) 산점도
- `histogram` : bins+counts 또는 samples+bin_spec
- `bar` : labels+values
- `box` : quartiles/whiskers/outliers

오버레이 조건:
- 동일 graph_kind + 동일 축 메타에서만 허용한다.

---

### [GRAPH-AXIS-META-01] graph 축 메타(`x_kind/unit/label`, `y_kind/unit/label`) — MUST

필수:
- `x_kind`, `x_unit`, `y_kind`, `y_unit`

선택:
- `x_label`, `y_label`

오버레이 허용 조건(정본):
- baseline과 variant의 `(graph_kind, x_kind, x_unit, y_kind, y_unit)`가 동일해야 한다.

---

### [GRAPH-DATA-01] graph_kind별 최소 데이터 채널 — SHOULD (v0)

- timeseries: `t`+`y`(또는 `x=t`+`y`)
- xy_line/scatter: `x`+`y`
- histogram: (`bins`+`counts`) 또는 (`samples`+`bin_spec`)
- bar: `labels`+`values`
- box: `q1/median/q3/whisker_low/whisker_high`(+outliers)

---

### [SPACE2D-DRAWLIST-02] space2d optional primitive 확장(C++) — SHOULD

- `원호`, `베지에`, `경로`, `면채우기`, `주석선(callout)`을 차기 확장으로 둘 수 있다.

---

### [SPACE2D-3D-01] 3D 표현 확장(보개 증식 없이) — SHOULD

정본(권장):
- `그림` : 2D drawlist
- `그림3d` : 3D drawlist(또는 `그림` 내부에 3D 도형 허용)

3D primitive 최소 세트:
- `상자`, `구`, `원기둥`, `원뿔`, `선3d`, `점3d`


---
===== END SSOT_LANG_v20.6.33.md =====
===== BEGIN SSOT_DEMOS_v20.6.33.md =====
# 또니랑 SSOT — DEMOS (v20.6.33, Reference)

> 역할: 데모/예시 모음(참고). 예시는 SSOT_LANG v19 정본 표기(`$말결`, `늘지켜보고`, 제네릭 꺾쇠 금지)를 따른다.

> 문서 버전: **v20.6.9**  | 기준일: **2026-02-13**  | 상태: **SSOT (참고)**


P26-02-13
Status: RELEASE (Gate0 기준)

---

<!--
File Role: Demos + golden tests (Non-normative). Used for learning and verification.
Authority: REFERENCE
Version: v20.6.9 (Reference)
P26-02-13
Status: Non-normative
-->

## §E0 원칙

- 이 파일은 **참고/검증용**이다(Non-normative).
- 규범(정의/MUST)은 `LANG/RUNTIME/PLATFORM/EXTENSIONS`에만 둔다.
- 다만, **골든 테스트/릴리스 게이트**는 개발 운영상 강제될 수 있다(프로세스 규약).


## §E0.A 용어 및 참조 (Non-normative)

이 절은 예제 파일의 범위를 “예제/골든 테스트”에서 **용어 사전 + 참조 문헌(REFERENCES)**까지 확장하는 자리입니다.
파일명은 `SSOT_REFERENCES.md`이며, 문서 제목과 이 절에서 범위를 명시합니다(SHOULD).

### 용어(Glossary)
- **원자(`#이름`)**: 텍스트와 구분되는 “이름표” 값(결정적 비교/해시 가능).
- **갈래씨**: 원자들의 닫힌 집합(열거) 타입.
- **이름씨**: 구조형 스키마(필드/재료는 `( … )`에만 선언).
- **움직씨**: 상태 변환(결정적). 실제 상태 변경(`< -`)은 “이야기/세계” 문맥에서만 허용.
- **보개**: 관찰/렌더링 계층(UI/콘솔/2D/3D).
- **거울**: 추적/감사/리플레이를 위한 기록 계층.

### 참조(References)
- (추가 예정) 결정적 실행/리플레이, Fixed64, DetJson, ECS 구독 모델 관련 참고 자료를 여기에 누적한다(MAY).

---


---


## §E0.B 말씨(ko/en/sym3/ja/mn/tr) 6단 병기 템플릿 + i18n(읽기)

이 절의 목적:
- **같은 AST**를 말씨(표기 스타일)만 바꿔서 여러 방식으로 적는 예시를 제공한다.
- 문서/팩/골든은 보통 `ko + canon`이 기준이고, 학습/입력 편의로 `en/sym3/ja/mn/tr`를 **별칭 말씨**로 쓸 수 있다.
- `i18n-*`는 “코드 토큰 치환”을 넘어선 **읽기/교육용 표시(render)** 이다(왕복 파싱 불요).

> 참고 1: `sym3`에서는 `해서`의 별칭 파이프가 `|>>`로 정본이며, `|>`는 금지 또는 compat(경고+정규화)로만 취급한다.  
> 참고 2: `ja/mn/tr`는 v1에서 “제어/논리/흐름”의 **최소 키워드**만 입력 별칭으로 제공한다(세부 매핑은 `SSOT_LANG`의 [DIALECT-JA/MN/TR-01]).

### §E0.B.1 파이프 + 토막(Thunk) 예제 (같은 의미)

#### ko (정본: 조사 + `~기/~하기` 꼬리)

```ddn
#말씨: ko
f~을 diff하기 해서 simp하기 해서 돌려주기.
{ f~을 diff하기 }해서 돌려주기.
```

#### en (입력 별칭: 조사코드 + `()` 꼬리)

```ddn
#말씨: en
f~ob diff() |> simp() |> return.
{ f~ob diff() }|> return.
```

#### sym3 (기호 별칭: 조사코드 + `!()` 꼬리)

```ddn
#말씨: sym3
f~ob diff!() |>> simp!() |>> =<<.
{ f~ob diff!() }|> =<<.
```

#### ja (입력 별칭: 일본어 제어어 + `()` 꼬리)

```ddn
#말씨: ja
f~ob diff() |> simp() |> 返す.
{ f~ob diff() }|> 返す.
```

#### mn (입력 별칭: 몽골어 제어어 + `()` 꼬리)

```ddn
#말씨: mn
f~ob diff() |> simp() |> буцаах.
{ f~ob diff() }|> буцаах.
```

#### tr (입력 별칭: 터키어 제어어 + `()` 꼬리)

```ddn
#말씨: tr
f~ob diff() |> simp() |> dondur.
{ f~ob diff() }|> dondur.
```
### §E0.B.1b (선택) ja/mn/tr 자연 조사 표면형(accepted) 예시

아래는 `~ob` 같은 코드 조사 대신, 말씨별 **자연 조사/격 표지**를 쓰는 예시다.  
(입력은 `accepted`, fmt는 말씨별 `preferred`로 정리할 수 있다.)

```ddn
#말씨: ja
f~を diff() |> simp() |> 返す.

#말씨: mn
f~ыг diff() |> simp() |> буцаах.

#말씨: tr
f~i diff() |> simp() |> dondur.
```


### §E0.B.2 조건/분기 예제 (같은 의미)

#### ko

```ddn
#말씨: ko
(HP < 10) 일때 { "위험!" show. } 아니면 { "안전." show. }.
```

#### en

```ddn
#말씨: en
(HP < 10) if { "Danger!" show. } else { "Safe." show. }.
```

#### sym3

```ddn
#말씨: sym3
(HP < 10) ?=> { "Danger!" show. } ;=> { "Safe." show. }.
```

#### ja

```ddn
#말씨: ja
(HP < 10) もし { "危険!" show. } でなければ { "安全." show. }.
```

#### mn

```ddn
#말씨: mn
(HP < 10) хэрэв { "Аюул!" show. } үгүйбол { "Аюулгүй." show. }.
```

#### tr

```ddn
#말씨: tr
(HP < 10) eger { "Tehlike!" show. } yoksa { "Guvenli." show. }.
```

### §E0.B.3 i18n(읽기 렌더링) — 예시(코드가 아님)

아래는 **코드가 아니라 문장 번역(읽기용)** 예시다.  
(i18n 출력은 왕복 파싱을 요구하지 않으며, pack/golden 저장에 사용하면 안 된다.)

- 日本語: 「HPが10未満なら『危険!』、そうでなければ『安全。』を表示する。」
- Монгол: 「HP 10-аас бага бол ‘Аюул!’ гэж харуул; үгүй бол ‘Аюулгүй.’ гэж харуул.»
- Türkçe: “HP 10’dan küçükse ‘Tehlike!’ göster; değilse ‘Güvenli.’ göster.”
## §E0.4 또니랑누리 ‘마법세계’ — 최소 플레이 루프(MVP) 데모

이 데모는 “또니랑이 최종적으로 무엇을 해야 하는가?”를 **가장 짧게** 보여주는 기준선이다.

- 이야기 지향: 또니(아이)가 주문(글)을 써서 누리(세계)를 바꾼다.
- 수학/시뮬 지향: 상태 변화가 **규칙(계약)**을 따른다.
- 결정성 지향: `무쇠/주사위`에서 **재현**된다.
- AI 지향: AI는 “제안자/편집자”일 뿐, **지킴이 규칙을 넘지 못한다.**

### 데모 스토리(초소형)
- 배경: 작은 숲 마을
- 또니 목표: “불씨를 안전하게 피우기”
- 누리 규칙: 물이 있으면 불씨가 약해지고, 바람이 강하면 불씨가 꺼질 수 있다(주사위 모드)

### 데모 입력(의사코드)
아래는 **형태와 의도**를 보여주는 예시다(플랫폼/표준 라이브러리가 확정되면 정본 문법으로 고정).

```text
#이름: 또니랑누리_마법세계_MVP
#레벨: 무쇠

누리:누리씨 = (
  장소:"숲마을",
  날씨:(바람:1, 비:0),
  불씨:0,
  물:2
).

또니:또니씨 = (
  이름:"또니",
  가방:(나뭇가지:3)
).

#주문(움직씨) — ‘무엇을 바꿀지’를 토막 단위로 분리

※ 이 데모는 “한국어 느낌”을 강조하려고 씨앗 이름에 조사를 포함했다(`불씨~를_피우기`).
- `~`는 **조사 접착자**로, `@`(단위/포맷/태그)와 다르다.
- 구현/팀 스타일에 따라, 씨앗 이름에서 조사는 빼고 `불씨피우기`처럼 쓰는 편이 더 읽기 쉬울 수도 있다(린트 권장).

불씨~를_피우기:움직씨 = {
  #계약(지킴이) — 예시
  늘지켜보고 { (누리(불씨) <= 3) }.
  늘지켜보고 { (또니(가방)(나뭇가지) >= 1) }.

  #실행
  누리(불씨) <- 누리(불씨) + 1.
  또니(가방)(나뭇가지) <- 또니(가방)(나뭇가지) - 1.
}

물~을_뿌리기:움직씨 = {
  늘지켜보고 { (누리(물) >= 1) }.

  누리(물) <- 누리(물) - 1.
  누리(불씨) <- 누리(불씨) - 1.
}

마디:마디씨 = (
  1마디:{ (또니가) 불씨~를_피우기 하기. },
  2마디:{ (또니가) 불씨~를_피우기 하기. },
  3마디:{ (또니가) 물~을_뿌리기 하기. }  # “실패도 게임”이 되게
).
```

### 기대 출력(요지)
- 1마디: 불씨=1, 나뭇가지=2
- 2마디: 불씨=2, 나뭇가지=1
- 3마디: 물=1, 불씨=1

### 이 데모가 잡아주는 SSOT 체크포인트
- 글/마디/토막 단위가 실제로 의미가 있는지
- 계약(불변식)을 위반하면 어떻게 설명할지(어린이 말)
- 재현(state_hash / trace)과 리플레이가 가능한지
- AI가 개입해도 “규칙을 깎아 먹지” 못하는지


## §E1 표준 패턴 갤러리 (CORE_SPEC에서 이관)

## 20. 표준 패턴 갤러리

### 20.1 기본 셈씨

```ddn
(x:수) 증가:셈씨 = {
    x + 1 돌려주기.
}
```

### 20.2 상태 변경 (움직씨)

```ddn
(대상:플겹) 회복:움직씨 = {
    대상.HP <- 대상.HP + 10.
}
```

### 20.3 연산자 오버로딩

```ddn
A:값꾸러미 +~합 : 값꾸러미 : 이음씨 B:값꾸러미 = {
    (A.x + B.x, A.y + B.y) 돌려주기.
}
```

### 20.4 조건 트리거

```ddn
(플겹.HP < 10) 일때 {
    "위험!" 보여주기.
}
```

### 20.5 스트림 연결

```ddn
마우스X : 샘 <<- 시스템.입력.마우스.x
카메라X : 흐름씨 <<- 마우스X * 0.8
```

### 20.6 상태 머신 (Union)

```ddn
상태 : 고름씨 = #대기 | #이동 | #공격
(상태 == #공격) 일때 { ... }
```

### 20.7 함수형 체이닝

```ddn
// (데이터) 함수 형태로 연속 호출
(10) 증가하기 (20) 더하기.
```

### 20.8 검사 훅 활용

```ddn
(재고 < 0) 늘지켜보고 {
    "재고가 음수가 될 수 없습니다" 덧댐거부.
}
```

### 20.9 말결 표현

```ddn
$매우 기쁘다.
$조금 슬프다.
```

### 20.10 GOAP 목표

```ddn
(플겹)가 (레벨10)이 되도록.
```


### 20.18 순회/필터 — `~중에 {...}인것들~에게:` (ROADMAP)

```ddn
# 예: 몬스터들 중 HP가 0 이하인 것들을 하나씩 처리

(모든 몬스터들)~중에 { (저마다.HP <= 0) }인것들~에게: {
    (저마다) 제거하기.
}
```

- `저마다`는 “이번 반복의 대상”을 가리키는 예약 바인딩 이름이다.
- Gate0에서는 순회 순서를 **결정적으로 고정**해야 한다(예: stable id 정렬).

---


---

## §E2 테스트 표준(골든/적합성/리플레이) (CONVENTIONS에서 이관)

## 4. 테스트 표준

### 4.1 테스트 겹
- **골든 테스트:** 파서/프린터/IR 스냅샷
- **적합성 테스트:** SSOT MUST 항목별 케이스(최우선)
- **리플레이 테스트:** 입력로그 기반 재현
- **프로퍼티 테스트:** 산술/단위/파서(무작위 생성)
- **퍼즈 테스트:** 렉서/파서 크래시 방지

### 4.2 최소 필수 테스트 세트(Release Gate) — MUST
- TODO: `det-hash`: 대표 프로그램 20개 이상, OS 2종 이상
- TODO: `replay`: 입력로그 재생 100% 일치
- TODO: `units`: 차원/환산 오류 케이스 포함
- TODO: `eomi`: `-고/-며` 및 활용/별칭 파싱/의미
- TODO: `import-lock`: lock 고정 빌드 재현

### 4.3 Gate0 검증용 시나리오 묶음(파이프 + 차원고장 + 대입무효화) — MUST

이 절은 Gate0 구현체가 **반드시 통과해야 하는 최소 골든 시나리오**를 제공한다.  
(이 파일은 Non-normative이지만, 아래 묶음은 “릴리스 게이트” 프로세스에서 강제될 수 있다.)

표기:
- **CE**: 정본화 실패(컴파일 오류)
- **RF**: 런타임 고장(Runtime Fault)
- **INV**: 대입 무효화(Assignment Invalidation)
- **TAG**: `#고장`, `#차원고장` 등 알 부착
- **LOG**: 거울(Geoul) 기록

#### 케이스 목록(요약)

| ID | 핵심 | 대상 규칙(참조) | 기대 결과 |
|---|---|---|---|
| G0-PIPE-001 | 파이프 단계는 호출식만 | `[PIPE-CALL-ONLY-01]` | **CE** |
| G0-PIPE-002 | 파이프 + 표준 셈씨로 산술 | `[PIPE-CALL-ONLY-01]` | OK (값 일치) |
| G0-UNIT-001 | 리터럴 차원 불일치(정적) | `[UNIT-VALID-TIME-01]` | **CE** |
| G0-UNIT-002 | 샘/호스트 경계 차원 불일치(동적) | `[UNIT-VALID-TIME-02]`, `[MATH-DIV-01]` | **RF + INV + TAG + LOG** |
| G0-FAULT-001 | 0으로 나누기 | `[MATH-DIV-01]` | **RF + INV + TAG + LOG** |
| G0-FAULT-002 | 고장 이후의 “값 유지”가 연쇄에 미치는 영향(결정적) | `[MATH-DIV-01]` | OK (결정적) |

---

#### G0-PIPE-001 — “해서” 뒤 연산자 단독 금지

```ddn
(10)만들기 해서 + 5 해서 (나)보여주기.
```

- 기대:
  - **CE**: `[PIPE-CALL-ONLY-01]` 위반  
  - 오류 메시지/코드는 **결정적으로 고정**되어야 한다(같은 입력이면 같은 코드/스팬).

---

#### G0-PIPE-002 — 파이프에서 산술은 “셈씨 호출”로만

```ddn
(10)만들기 해서 (5)더하기 해서 (2)곱하기 해서 (나)보여주기.
```

- 기대:
  - OK: 결과가 `(10 + 5) * 2 = 30`으로 계산됨(DetMath/Fixed64 규칙에 따름).
  - 정본 출력에서도 `해서` 체인이 유지됨.

---

#### G0-UNIT-001 — 리터럴/상수 차원 불일치는 컴파일 오류

```ddn
거리:수@m = 10@m.
시간:수@s = 5@s.
결과:수? = 거리 + 시간.
```

- 기대:
  - **CE**: `[UNIT-VALID-TIME-01]` 위반(차원 불일치: L + T)
  - “미터(m)와 초(s)는 더할 수 없다”류의 결정적 메시지(또는 코드) 제공.

---

#### G0-UNIT-002 — 샘/호스트 경계 단위는 런타임 안전망 + 대입 무효화

사전 상태(초기값)  
```ddn
바탕.결과 <- 777@m.
```

실행(동일 마디 내)  
```ddn
// 샘.외부값은 실행 중에 단위가 판정되는 경계 입력.
// 예: 이번 프레임에 샘.외부값이 5@s로 들어왔다고 가정.
바탕.결과 <- 샘.외부값 + 10@m.
```

- 기대:
  - **RF**: 차원 불일치 관측 → `#차원고장` 분류(권장) + `#고장` 부착(필수)
  - **INV**: `바탕.결과` 대입은 **무효화**되어 값이 **777@m로 유지**됨
  - **LOG**: 거울에 “차원 불일치(관측 단위: s, 기대 단위: m)” 같은 사유가 기록됨(권장)

> 주의: 이 케이스는 “대입 무효화” 정책이 **경계 입력에서도 동일하게 적용**됨을 검증한다.

---

#### G0-FAULT-001 — 0으로 나누기: 대입 무효화 + 고장 알

사전 상태  
```ddn
바탕.y <- 7.
```

실행  
```ddn
바탕.y <- 1 / 0.
```

- 기대:
  - **RF**: `[MATH-DIV-01]` 0으로 나누기
  - **INV**: `바탕.y`는 **7로 유지**
  - **TAG**: 실행 주체에 `#고장` 부착(필수)
  - (권장) 알림: `("산술고장")` + 거울 기록

---

#### G0-FAULT-002 — “값 유지”가 연쇄에 미치는 영향이 결정적임을 검증

사전 상태  
```ddn
바탕.y <- 7.
```

실행(순서 중요: 좌→우)  
```ddn
바탕.y <- 1 / 0.      // INV → y는 7 유지
바탕.z <- 바탕.y + 1. // y의 ‘유지된 값’ 사용 → z는 8
```

- 기대:
  - `바탕.y == 7`
  - `바탕.z == 8`
  - 동일 입력/동일 마디 스케줄에서 state_hash가 항상 동일

---


---


---

## §E3 결정론 테스트 추가 규약 (CONVENTIONS에서 이관)

## ✅ 결정론 테스트 추가 규약 (v14.0)

- **Golden Replay Test:** 동일한 `InputSnapshot` 스트림을 주고, 플랫폼/CPU/스레드 수가 달라도 `world_hash`가 동일해야 한다.
- **AI Injection Sort Test:** 랜덤 순서로 도착한 `SeulgiPacket`이 스냅샷에서 항상 동일한 정렬 결과를 가져야 한다.
- **알림 Same-madi Test:** `알려` 직후 동일 마디에서 `(알림)할때`가 실행됨을 검증한다.
- **Reactive Loop Limit Test:** 자기 재귀 알림이 있어도 엔진이 멈추지 않고 16패스 이후 알림이 다음 마디로 이월됨을 검증한다.
- **Fixed64 Lint Gate:** 코어 크레이트에서 `f32/f64` 사용 시 CI에서 실패한다(경계 모듈 제외).


---


---

## §E4 4대 대표 데모 (초안/템플릿)

> 아래 4대 데모는 ‘보이는 것’을 최우선으로 하는 교육/검증 템플릿입니다.  
> 각 데모는 입력로그→기대출력(해시/스냅샷)로 결정성 검증을 포함합니다.

1) **콘솔 미로** — 텍스트 누리/이야기/샘(키) 기반 이동 + 리플레이
2) **웹 풍선** — 블록/Web 확장 연동(§G2) + 보개(웹) 렌더
3) **포물선** — 단위/DetMath + ‘움직이는 셈그림(Manim)’(§G3)로 시각화
4) **막대기쌓기 Gym** — NuriGym(§G4) 환경 + reset/step 로그/리플레이 + 폴백/계약/진단

### DoD(완료 정의) 공통
- TODO: 동일 입력 로그로 재생 시 결과 해시가 동일하다.
- TODO: trace_tier를 올려도 시뮬 결과(해시)는 바뀌지 않는다.
- TODO: det_tier 전환은 런타임 실행 중 허용되지 않는다(§R1).


## §E5 AI-aware 데모: 막대기쌓기 Gym (v0, Gate0 범위)

### 목표
- “AI-aware(의도/계약/진단/격리/재현)”를 **한 번에 체감**할 수 있는 대표 데모를 제공한다.
- 연속 물리 엔진 없이도 Gate0에서 **결정적으로** 돌아가도록, 연속 시뮬 대신 **안정 판정(지지구간/중심)** 규칙으로 구현한다.
- “결측치(질량 없음) + 폴백 + 로그 정직성”을 기본 규칙으로 포함한다.

### 환경 개요
- 막대기(rod)는 `길이`를 반드시 가진다. `질량`은 있을 수도 없을 수도 있다.
- 배치는 “바닥” 또는 “다른 막대기 위”이며, 위치는 **이산**(예: LEFT/CENTER/RIGHT 또는 0..N)으로 제한한다.
- 안정 판정은 **무게중심(COM)이 지지구간 안**에 있으면 안정, 벗어나면 넘어짐이다.

### 폴백 규칙(결정성 + 정직성)
- `질량`이 없으면 기본 폴백으로 `질량 = 길이`(또는 `길이×두께`)를 사용한다.
- 폴백을 사용했는지 여부는 매 스텝 로그/메타에 반드시 기록한다.
  - 예: `rod.mass_is_fallback = true`

### 관측(ObsSpec) 초안
- `step_idx`, `seed`, `goal_height`
- `rods[]`: `{id, length, mass, mass_is_fallback}`
- `tower[]`: 위에서 아래 순서의 rod id 리스트
- `supports[]`: 각 rod의 지지구간(이산 구간) 또는 현재 놓인 위치(LEFT/CENTER/RIGHT)
- `last_fault?`: 최근 계약/규칙 위반 코드(없으면 null)

### 의도(IntentSpec) 초안
- `Pick(rod_id)`
- `Place(target=GROUND | rod_id, slot=LEFT|CENTER|RIGHT)`
- (선택) `Reset(seed)` — 보통 reset은 환경 API로 분리

> 권장: Gate0에서는 연속 좌표/실수 입력을 피하고, Fixed64 또는 정수/이산만 사용한다.

### 보상/종료(GoalSpec) 예시
- 보상(reward):
  - 안정적으로 1개 더 쌓이면 `+1.0`
  - 넘어짐(unstable) 발생 시 `-5.0` 및 종료
  - 목표 높이 달성 후 K스텝 유지 시 추가 `+10.0`
- 종료(done):
  - `tower.height >= goal_height` AND `stable_for >= K`
  - 넘어짐
  - 최대 스텝 초과

### 계약/진단(필수)
- `늘지켜보고`: 안정 판정이 실패하면 `FAULT=UNSTABLE`를 기록하고 에피소드를 종료한다.
- `늘지켜보고`: 폴백 질량이 사용된 경우 `DIAG=FALLBACK_MASS_USED`(정보성) 로그를 남긴다.
- 모든 진단은 `source_span`/`madi`/`rule_id`를 포함한다.

### 리플레이/골든 테스트 포인트(필수)
- 동일한 입력 로그(`seed + intent stream`)면 항상 동일한 결과(`state_hash`)가 나와야 한다.
- AI 주입 정렬/지연마디가 섞여도 결과는 동일해야 한다.
- 리플레이에서는 외부 모델/LLM 호출 없이, 기록된 입력 주입만으로 동일하게 재생되어야 한다.

### 골든 시나리오 3개(초안)
1. **EASY-01 (성공)**
   - rods: [(id=1,len=3,mass=3), (2,len=2,mass=2), (3,len=1,mass=1)]
   - goal_height=3
   - intents: Pick(1)→Place(GROUND,CENTER), Pick(2)→Place(1,CENTER), Pick(3)→Place(2,CENTER)
   - expected: done=true, fault=null

2. **EASY-02 (실패: 불안정)**
   - rods: [(1,len=3,mass=3), (2,len=2,mass=2)]
   - intents: Pick(1)→Place(GROUND,CENTER), Pick(2)→Place(1,LEFT)
   - expected: fault=UNSTABLE, done=true(실패 종료)

3. **EASY-03 (폴백 기록 확인)**
   - rods: [(1,len=3,mass=?), (2,len=2,mass=2)]
   - 폴백 규칙으로 rod1.mass=3 적용, `mass_is_fallback=true` 기록
   - intents: Pick(1)→Place(GROUND,CENTER), Pick(2)→Place(1,CENTER)
   - expected: done=false(계속), diag에 FALLBACK_MASS_USED 포함



---

## A3. 예제/참고 (Compact 통합)

Compact 묶음에서는 파일 수를 줄이기 위해 **예제/용어/참고**를 이 문서로 통합합니다.

- 예제/골든 테스트: A2 섹션에 포함
- 결정 로그(DEC-xxxx): A1 섹션에 포함
- 별도 `SSOT_REFERENCES.md`, `SSOT_EXAMPLES.md`, `REPORT_*.md` 파일은 **Compact 묶음에 포함하지 않습니다** (Full 묶음에서만 제공)

---

## 부록: 순우리말 용어 정리(통합)

> v16부터는 SSOT 밖 문서까지 ‘한 목소리’로 맞추기 위해, 순우리말 용어표를 Appendix에 통합합니다.

### 0. 용어 층위(혼선 방지) — MUST

- **말(LANG)**: 문장/씨앗/조사/정본 규칙
- **틀(PLATFORM/RUNTIME)**: 누리·터·거울·보개·슬기 등 실행 계약
- **가지(GAJI)**: Manim/Gym/로봇팩/창작툴 등 도메인 패키지
- **연장줄(TOOLCHAIN)**: 글터·말도우미·엮개·시험줄·꾸러미 도구 묶음

### 1. 장인의 공방(연장줄) — 정본 추천

| 기술 용어 | 정본 우리말(영문/약어) | 한 줄 뜻 |
|---|---|---|
| TOOLCHAIN | **연장줄(TOOLCHAIN)** | 또니랑을 짓고 다듬고 증명하는 도구의 줄기 |
| IDE | **글터(IDE)** | 글을 짓고(코드), 보개로 살피는 작업 마당 |
| LSP | **말도우미(LSP)** | 글터에서 핀/조사/정본을 실시간으로 안내하는 도우미 |
| Semantic Highlighting | **뜻빛칠** | ‘이 조사는 이 핀’ 같은 의미 바인딩을 색/배지로 보여줌 |
| Diagnostic | **진단말** | 흠(오류)·의심(경고)·제안(힌트)을 표준 형식으로 전달 |
| Quick Fix / Code Action | **바로손질** | 진단말을 근거로 1클릭 수정(사용자 승인 필요) |
| Formatter | **정본손질(포맷터)** | 표기(띄어쓰기/`@`)를 정본으로 다듬음(옵션) |
| Canonicalizer | **정본화기** | 다양한 표면 문장을 정본 AST로 수렴(정보 손실 금지) |
| CI / Regression | **시험줄(CI)** | 결정성·회귀·성능을 자동으로 재검증 |

#### 1.1 ‘말도우미’ 원칙(소스 보존) — MUST
- 뜻빛칠/고스트텍스트/배지는 **표시(overlay)만** 한다.
- 소스 변경은 **바로손질(사용자 승인)** 또는 **저장 시 정본손질(옵션)** 때만 한다.

### 2. 엮기·굳히기·돌림(컴파일/실행) — 정본 추천

| 기술 용어 | 정본 우리말 | 비고 |
|---|---|---|
| Lexer/Tokenizer | **쪼갬기(렉서)** | 글을 낱말(토큰)로 쪼갬 |
| Parser | **엮기(파서)** | 토큰을 말나무(AST)로 엮음 |
| AST | **말나무(AST)** | 문장의 뼈대(구문 트리) |
| IR | **속말(IR)** | 최적화를 위한 중간 표기 |
| Bytecode | **속글(바이트코드)** | 돌림틀이 읽는 실행 글 |
| Compiler | **엮개(컴파일러)** | 말나무→속말/속글로 바꿈(결정적) |
| Build | **굳히기(빌드)** | 의존/판수까지 고정해 한 벌로 굳힘 |
| AOT | **미리굳히기(AOT)** | 실행 전에 굳혀 두기 |
| JIT | **그때굳히기(JIT)** | 실행 중에 굳히기(초기에는 보류 권장) |
| Runtime/VM | **돌림틀(VM)** | 속글을 돌리는 실행 틀 |

> 주의: ‘엮기’는 **파싱**에, ‘굳히기’는 **빌드/산출물 고정**에 우선 배정한다(의미 충돌 방지).

### 3. 꾸러미(배포/의존) — 정본 추천

| 기술 용어 | 정본 우리말 | 한 줄 뜻 |
|---|---|---|
| Package | **꾸러미(패키지)** | 함께 나눠 쓰는 기능 묶음 |
| Module | **갈래(모듈)** | 꾸러미 안의 이름 공간 |
| Manifest | **차림표(매니페스트)** | 꾸러미의 이름/판수/의존을 적은 쪽 |
| Lockfile | **잠금쪽(락파일)** | 의존 판수를 고정해 재현을 보장 |
| Registry | **곳간(레지스트리)** | 꾸러미를 올리고 받는 공용 창고 |

### 4. 한결같은 증명(결정성) — 정본 추천

| 기술 용어 | 정본 우리말 | 비고 |
|---|---|---|
| Hash | **지문값(해시)** | 특정 상태/기록의 유일 요약 |
| state_hash | **상태지문** | 한 마디의 누리 상태 지문 |
| trace_hash | **발자국지문** | 진행 경로(기록) 지문 |
| Replay | **되감기(리플레이)** | 발자국을 따라 1비트 오차 없이 재현 |
| DoD | **마감기준(DoD)** | 단계가 끝났음을 증명하는 시험 항목 |

### 5. 헷갈리기 쉬운 짝(엄격 구분) — MUST

#### 5.1 터(Realm) vs 누리(World)
- **누리**: 상태가 저장되는 세계(개념/데이터)
- **터**: 누리가 돌아가는 결정적 실행 자리(인스턴스). **지문값은 터 단위로 닫힌다.**

#### 5.2 자원(쓸감) vs 터바탕씨(Resource)
- **자원(쓸감)**: 그림/소리/모형 파일 같은 **바깥 파일(에셋)**
- **터바탕씨(Resource)**: 터 안에 **단 하나**만 존재하는 전역 데이터(시간/중력/규칙집 등)

### 6. 이미 순우리말로 잘 잡힌 핵심(유지 권장)

- 말(LANG), 틀(PLATFORM), 가지(GAJI)
- 누리, 터, 이야기, 보개, 거울, 슬기, 샘
- 7대 씨앗: 이름씨, 움직씨, 셈씨, 일묶음씨, 이음씨, 흐름씨, 일때씨
- ECS 기본: 임자, 이름씨, 알, 알림(레거시: alrim), 터바탕씨

### 7. 채택 상태(정본/별칭/보류) — 운영 규칙

- **정본**: 문서/예시/보개 UI에서 기본으로 사용
- **별칭**: 한동안 병기(레거시 문서/외부 연동 대비), 이후 제거 가능
- **보류**: 당장 채택하지 않고 후보로만 유지

#### 7.1 이번 판에서 정본으로 잠그는 것
- 연장줄, 글터, 말도우미, 뜻빛칠, 진단말, 바로손질
- 쪼갬기, 엮기(파서), 말나무, 속말, 속글, 엮개, 굳히기, 미리굳히기, 돌림틀
- 꾸러미, 갈래, 차림표, 잠금쪽, 곳간
- 지문값, 상태지문, 발자국지문, 되감기, 마감기준
- 터바탕씨

#### 7.2 레거시 별칭(폐기 예정)

- **값함수(레거시)** → **셈씨**  
  - 과거 SSOT/예시에서 ‘순수 계산’을 `값함수`로 표기했으나, 현재는 **셈씨**로 통일합니다.
- **셈씨(레거시: 토막/Thunk/Block 의미)** → **일묶음씨**  
  - 과거 SSOT/예시에서 `셈씨`가 ‘블록/지연 실행(Thunk)’을 뜻했으나, 현재는 **일묶음씨**로 통일합니다.

> 운영 원칙: 문서·예시·UI는 **정본 용어만** 사용한다. 레거시 입력이 필요한 경우에만 파서/도구층에서 별칭을 허용한다.

## v18.0.6 부록 추가: 단위/통화/환율 정본

### A18-01 단위 곳간 확장 원칙
- “많이 넣고, 모호하면 레지스트리에 선언”을 기본으로 한다.
- 단위는 3층으로 구분한다.
  1) **기본 단위**(m, s, kg, A, K …)
  2) **파생 단위**(m/s, N, J, Pa, Hz …)
  3) **실무 단위/관습 단위**(inch, ft, mile, 평, L, bar …)

### A18-02 예시 레지스트리 엔트리(표기만, 차원 검사는 AGE2)
- `@평` = `3.305785@m2` (면적) — *참고 값, 구현 시 레지스트리로 확정*
- `@inch` = `0.0254@m` (길이)
- `@kmh` = `@km/@h` (속도)
- `@mps` = `@m/@s` (속도)

### A18-03 통화/환율 (Gate0 정본 + AGE2 확장)

- 통화는 단위처럼 취급한다: `@KRW`, `@USD`, `@EUR` …
- Gate0의 원칙은 **“표기/저장 가능, 암묵적 환전 금지”**이다.

#### Gate0 규칙(정본)
- 서로 다른 통화 간 **암묵적 환전/혼합 산술은 금지**한다.
  - 예: `1@KRW + 1@USD` → 오류
- 환율 값은 **보관/표기**만 허용한다.
  - 환율 단위는 `@KRW/@USD` 같은 **통화쌍 단위**를 정본으로 인정한다.
  - Gate0는 **자동 환전 규칙**을 제공하지 않는다.

#### AGE2(표준 라이브러리) 확장
- 명시적 함수로만 환전을 허용한다(예시):
  - `환전하기(돈: @USD, 환율: @KRW/@USD) -> @KRW`
  - `환전하기(돈: @KRW, 환율: @KRW/@USD) -> @USD` *(또는 역수 제공)*

---

# 또니랑 3줄기(부)·9고개(기)·99걸음(단계) 로드맵(단일 출처)

> 본 문서(SSOT_DEMOS)는 **"어떻게 맞는지(검증/데모)"**만 다룹니다.  
> **"무엇을 만들지(로드맵)"** 상세(3줄기(부)·9고개(기)·99걸음(단계))는 **SSOT_ROADMAP_CATALOG_v20.6.33.md**가 단일 출처(SSOT)입니다.

- 로드맵 상세(단일 출처): `SSOT_ROADMAP_CATALOG_v20.6.33.md` §R1B  
- 본 DEMOS 문서는 로드맵 표/단계를 **복제하지 않습니다**(단일 출처·혼선 방지).


# 또니랑 프로젝트 대백과 (PROJECTS_CATALOG)

Version: v20.4.1
P26-02-13

- 작성일: 2025-12-24 (KST)

이 문서는 **또니랑의 모든 프로젝트 아이디어를 버리지 않고 보관**하기 위한 ‘카탈로그’입니다.
- **규범(SSOT)과 분리**: SSOT는 ‘정본 규격’만 담고, 이 문서는 아이디어/기획/우선순위 후보를 담습니다.
- **예시 코드는 ‘개념 스케치’**이며, 최종 정본 문법(PinSpec/조사/@/띄어쓰기 규칙)을 따르는 예시는 각 프로젝트가 착수될 때 별도 스펙에서 확정합니다.

## 분류(4갈래)
- **창작·교육**
- **지능·시뮬레이션**
- **실체·협업**
- **메타·인프라**

## 각 항목 템플릿
- 한 줄 요약
- 목적(왜 만드나)
- 또니랑 5대 기둥과의 연결(우리말·수학적 엄밀·결정적 재현·배움창작·슬기/솜씨 협업)
- 차별점(또니랑만이 할 수 있는가)
- 구현 난이도(감)
- 의존성(말/틀/가지/연장줄/보개/거울 등)
- MVP(첫 열매)
- DoD(마감기준)
- SSOT 연결 위치(어느 문서/어느 부록으로 가는가)

## 빠른 추천(단계별 TOP)
- **관문 0/초기 데모**: 되감기 교과서, 우리말 논리 퍼즐, 만화·컷 메이커
- **차별성 증명(중기)**: AI 윤리 시뮬레이터, 우리말 동화·시나리오 창작, 움직이는 셈그림(Manim)
- **생태계(장기)**: 공유된 꿈의 도서관, 다손 슬기 공방, 다손 마을


# 창작·교육

## 창01. 되감기 교과서(시간여행 문제집)

**한 줄 요약**: 학생이 코드를 실행하고 ‘거울’로 되감아, 틀린 지점을 마디 단위로 보며 배우는 인터랙티브 교재/채점 체계.

**목적**:
- 디버깅=학습으로 전환
- 재현 가능한 수행평가/과제

**또니랑 기둥 연결**: 결정적 재현, 배움·창작, 우리말 네이티브

**차별점**: 거울(로그)·되감기·state_hash를 교육 UX로 바로 연결하는 점이 또니랑만의 독보점.

**구현 난이도(감)**: 중간(핵심은 거울/리플레이·간단한 보개 UI)

**의존성(필요 요소)**:
- 말: 기본 문장/반복/조건
- 틀: 마디·거울(Trace/Replay)·state_hash
- 연장줄: 글터/말도우미 진단말
- 보개: 상태/변수 시각화(최소)

**MVP(첫 열매)**:
- ‘1~10 더하기’, ‘소수 판별’ 같은 10문제
- 제출물=입력+정본 코드+state_hash
- 오답 비교: ‘마디 N에서 변수 x가 달라짐’ 안내
- 거울 재생 UI(전/후/특정 마디 점프)

**DoD(마감기준)**:
- 동일 입력·동일 정본 코드 → 항상 동일한 마디·동일 state_hash
- 정답 로그와 학생 로그 비교로 ‘최초 분기 마디’ 찾기
- 말도우미가 오답 지점 관련 진단말/바로손질 제안

**비고**:
- SSOT 연결: 말(기본 문법), 틀(거울/되감기/해시), 연장줄(진단말/바로손질), 가지(교육 꾸러미 포맷)


---

## 창02. 우리말 동화·시나리오·시트콤 짓기(슬기 협업)

**한 줄 요약**: 슬기(LLM)가 줄거리/대사를 제안하고, 사람이 승인한 부분만 정본 코드로 굳혀 ‘보개’로 연출하는 창작 공방.

**목적**:
- 창작 입문(아이·청소년)
- 저작/책임 경계 명확(승인한 것만 반영)

**또니랑 기둥 연결**: 우리말 네이티브, 슬기·솜씨 협업, 정본화(승인)

**차별점**: AI 출력의 ‘비결정성’을 ‘승인→정본화→거울 기록’으로 길들여 ‘재현 가능한 창작’으로 바꾸는 구조.

**구현 난이도(감)**: 중간~높음(LLM 연동, 보개 연출, 승인 UX)

**의존성(필요 요소)**:
- 말: 등장/대사/장면 서술
- 틀: 보개(연출), 거울(창작 과정 로그)
- 연장줄: 승인/변환(정본화기), 말도우미
- 가지: 슬기 브리지/시나리오 포맷

**MVP(첫 열매)**:
- 3종 템플릿: 동화/시트콤/짧은 연극
- 승인 패널: ‘슬기 제안’ vs ‘정본 확정’
- 보개: 말풍선+간단한 위치 이동만
- 거울: ‘누가 무엇을 승인했나’ 기록

**DoD(마감기준)**:
- 승인된 산출물만 누리 상태에 반영
- 같은 승인 기록(거울)로 100% 동일 재연
- ‘기여도’(슬기/사람) 메타데이터 보존

**비고**:
- SSOT 연결: 연장줄(정본화기/승인 흐름), 틀(보개/거울), 가지(슬기 연동)


---

## 창03. 움직이는 셈그림(Manim)(수학·물리 시각화)

**한 줄 요약**: 우리말 문장으로 수식/물리 법칙을 적고, 보개가 애니메이션으로 그려주는 수학·과학 시각화 도구.

**목적**:
- 수학·과학 교육
- 연구/강의용 시각자료 자동 생성

**또니랑 기둥 연결**: 수학적 엄밀, 결정적 재현, 우리말 네이티브

**차별점**: Fixed64(고정64) 기반으로 ‘같은 코드면 어디서나 같은 궤적’이 보장되는 교육용 실험 장치.

**구현 난이도(감)**: 높음(렌더링/레이아웃/타임라인)

**의존성(필요 요소)**:
- 말: 수식/도형/장면 문장
- 틀: 고정64·마디 타임라인
- 보개: 도형/텍스트 렌더
- 연장줄: 미리엮기(AOT)·내보내기(영상/이미지)

**MVP(첫 열매)**:
- 10개 예시(포물선/사인파/벡터/미분접선)
- 타임라인=마디 기반
- PNG/GIF 출력
- 정본 스크립트→렌더 결과 해시 기록

**DoD(마감기준)**:
- 동일 입력 → 동일 프레임 해시(또는 렌더 로그 해시)
- 고정64 연산 동일성 단위 테스트
- 예시 10개가 모든 OS에서 동일 결과

**비고**:
- SSOT 연결: 틀(보개 렌더), 말(수식 서술), 가지(Manim 가지)


---

## 창04. 스크래치류(블록/텍스트/다이어그램) 창작

**한 줄 요약**: 블록으로 짠 것을 정본 텍스트로 왕복 변환하고, 다이어그램(흐름/상태)로도 동시에 보여주는 ‘한몸’ 편집기.

**목적**:
- 입문 장벽 제거
- 텍스트로 자연스럽게 이행

**또니랑 기둥 연결**: 배움·창작, 우리말 네이티브, 연장줄 우선주의

**차별점**: 블록/텍스트/다이어그램이 같은 정본(정규 형태)에서 파생되어 ‘혼선 없이’ 학습 가능.

**구현 난이도(감)**: 높음(UI/모델 동기화)

**의존성(필요 요소)**:
- 연장줄: 글터·말도우미·정본화기
- 말: 최소 문법
- 틀: 실행기(교육용 인터프리터)

**MVP(첫 열매)**:
- 블록 20개(반복/조건/변수/사건)
- 텍스트↔블록 완전 왕복(손실 없음)
- 다이어그램: 흐름/상태 2종
- 바로손질(예: 조사 핀) 연결

**DoD(마감기준)**:
- 왕복 변환 ‘정보 손실 0’ 테스트
- 정본 텍스트가 단일 진실(SSOT)로 남음
- LSP 핀 가시화가 블록에도 반영

**비고**:
- SSOT 연결: 연장줄(글터/말도우미/정본화기), 말(문법), 틀(교육 실행기)


---

## 창05. 게임 메이커(누리 짓기)

**한 줄 요약**: 표준 이름씨(위치/속도/모양/충돌 등)를 조합해 2D/간단 3D 게임을 만드는 ‘누리 제작기’.

**목적**:
- 창작 동기 부여
- ECS 개념을 ‘서술형’으로 체득

**또니랑 기둥 연결**: 배움·창작, 결정적 재현, 누리(틀)

**차별점**: 게임의 ‘버그’가 거울/되감기로 완전히 재현되어, 사용자(아이)가 ‘왜 그런지’를 스스로 확인.

**구현 난이도(감)**: 높음(에디터+런타임)

**의존성(필요 요소)**:
- 틀: ECS(임자/이름씨/알/알림씨/터바탕씨)
- 보개: 렌더/입력
- 연장줄: 디버그(거울) UI

**MVP(첫 열매)**:
- 2D 탑다운(이동/충돌/점수)
- 레벨 편집(간단)
- 되감기 디버그(마디 이동)
- 꾸러미 배포(프로젝트 묶음)

**DoD(마감기준)**:
- 멀티 환경에서도 동일 입력→동일 플레이
- 저장/불러오기 시 동일 해시
- 기본 템플릿 3개 제공

**비고**:
- SSOT 연결: PLATFORM(ECS/보개/입력), TOOLCHAIN(디버그), GAJI(게임 템플릿)


---

## 창06. 우리말 논리 퍼즐(관계씨/질의 가지)

**한 줄 요약**: 관계씨로 지식을 선언하고 ‘모두찾아’ 질의로 추론하는 퍼즐/교육 게임(한국어 Prolog 느낌).

**목적**:
- 논리/추론 교육
- 설명 가능한 추론(왜 이 답?)

**또니랑 기둥 연결**: 우리말 네이티브, 결정적 재현, 가지 확장

**차별점**: 질의 탐색 순서가 결정적이어서 ‘추론 과정’을 거울로 그대로 설명/재현 가능.

**구현 난이도(감)**: 중간

**의존성(필요 요소)**:
- 가지: PROLOG/관계씨
- 틀: 거울(추론 트레이스)
- 말: 사실/규칙 서술
- 연장줄: 질의 디버거

**MVP(첫 열매)**:
- 10개 퍼즐(기사/도적, 가족관계, 스도쿠 미니)
- 추론 트레이스 뷰어(어떤 규칙이 언제 적용?)
- 힌트(슬기 없이도)

**DoD(마감기준)**:
- 같은 지식+질의 → 같은 답+같은 트레이스 해시
- 규칙 충돌/무한루프 진단말
- 퍼즐 10개 통과

**비고**:
- SSOT 연결: GAJI(PROLOG), TOOLCHAIN(질의 디버깅)


---

## 창07. 결정적 음악·리듬 생성기(합주)

**한 줄 요약**: 고정64 타이밍과 마디 동기화로, 네트워크 지연과 무관하게 모두 같은 박자에 연주/재생되는 음악 생성기.

**목적**:
- 예술 창작
- STEM+예술

**또니랑 기둥 연결**: 수학적 엄밀, 결정적 재현, 재미

**차별점**: ‘세계 어디서나 같은 코드=같은 연주’라는 강한 데모가 가능.

**구현 난이도(감)**: 중간~높음(오디오/동기화)

**의존성(필요 요소)**:
- 틀: 고정64/마디
- 연장줄: 미리듣기/내보내기
- 가지: MIDI/오디오 어댑터(선택)

**MVP(첫 열매)**:
- 시퀀서 1개(음표+길이)
- 리듬 패턴 10개
- 동기화 데모(2클라이언트)
- 내보내기(WAV/MIDI 중 1)

**DoD(마감기준)**:
- 동일 입력→동일 오디오 해시(또는 이벤트 해시)
- 네트워크 합주: 해시 일치 검증
- 지연 200ms에서도 동기 유지


---

## 창08. 만화·컷 메이커(컷=찍음)

**한 줄 요약**: 한 컷=찍음(스냅샷), 컷 전환=발자국(트레이스)으로 ‘만화처럼’ 누리를 짓는 창작 도구.

**목적**:
- 스토리보드 제작
- 코딩 없이도 상태/변화 이해

**또니랑 기둥 연결**: 배움·창작, 결정적 재현, 보개

**차별점**: 상태/변화를 만화 문법으로 재해석해, 어린이도 ‘시뮬=이야기’를 직관적으로 체득.

**구현 난이도(감)**: 중간

**의존성(필요 요소)**:
- 틀: 찍음/발자국/거울
- 보개: 컷 렌더
- 연장줄: 컷 편집기

**MVP(첫 열매)**:
- 컷 10장짜리 짧은 만화
- 컷 간 전환 애니메이션
- 말풍선/자막
- 컷 공유(꾸러미)

**DoD(마감기준)**:
- 컷 파일(찍음)과 전환(발자국)만으로 100% 재생
- 컷 편집이 정본 규칙을 변경하지 않음
- 공유/불러오기 성공


---

## 창09. 결정적 기억 보관소(가족 추억 누리)

**한 줄 요약**: 가족의 사건/사진/대사를 ‘누리’로 엮어 해시로 봉인하고, 세대가 달라도 동일하게 재현하는 추억 보관.

**목적**:
- 가족/교육
- 문화 기록

**또니랑 기둥 연결**: 결정적 재현, 창작, 문화

**차별점**: ‘추억’이 재현 가능한 형식으로 남는다는 감동 포인트.

**구현 난이도(감)**: 중간(핵심은 보개+거울+미디어 자원)

**의존성(필요 요소)**:
- 틀: 자원(파일)·보개 연출·거울
- 연장줄: 가져오기/정리
- 가지: 템플릿

**MVP(첫 열매)**:
- 사진+자막+음성(선택)으로 5장면
- 연표 보기
- 공유 링크/꾸러미
- 개인정보 보호 옵션

**DoD(마감기준)**:
- 같은 꾸러미→같은 재생(자원 포함)
- 자원 누락/변조 감지
- 권한/공개 범위 메타데이터


---

## 창10. 철학 실험실(자유의지 vs 결정론)

**한 줄 요약**: ‘선택’이 있는 에이전트를 누리에서 만들고, 같은 입력이면 같은 결과가 나오는 세계에서 철학 질문을 실험/토론.

**목적**:
- 철학/인문 교육
- 토론 수업

**또니랑 기둥 연결**: 결정성, 우리말, 배움

**차별점**: 추상 철학을 ‘재현 가능한 실험’으로 바꾼다는 점.

**구현 난이도(감)**: 중간

**의존성(필요 요소)**:
- 틀: 에이전트/입력
- 보개: 관찰
- 연장줄: 토론 기록(선택)

**MVP(첫 열매)**:
- 선택 실험 5개
- 질문 카드
- 되감기와 비교(입력 바꾸기)
- 토론 기록

**DoD(마감기준)**:
- 실험 스크립트 해시 고정
- 토론 로그(거울) 저장
- 교육용 안내서 1개


---


# 지능·시뮬레이션

## 지01. 누리짐(NuriGym) 결정적 강화학습

**한 줄 요약**: 수천 개의 병렬 ‘터’를 띄워 슬기를 학습시키되, 에피소드가 100% 재현되는 강화학습 환경.

**목적**:
- 연구 재현성
- 교육용 RL 실험

**또니랑 기둥 연결**: 결정적 재현, 슬기 협업, 성능

**차별점**: 재현 불가가 고질인 RL에서 state_hash/trace_hash로 ‘논문급 재현성’을 기본 제공.

**구현 난이도(감)**: 매우 높음(성능/병렬/ABI)

**의존성(필요 요소)**:
- 틀: 병렬 터/결정적 RNG/스냅샷
- 연장줄: 실험 관리(실행/기록/비교)
- 가지: 환경 템플릿
- 말: 정책/보상 서술(선택)

**MVP(첫 열매)**:
- CartPole급 1~2개 환경
- Python 브리지(선택) 또는 CLI
- 에피소드 기록/재현 버튼
- 해시 검증

**DoD(마감기준)**:
- 동일 시드+정책 → 동일 에피소드 해시
- 10k 에피소드 병렬 실행(목표 성능 수치 정의)
- 환경 버전 고정(잠금쪽)

**비고**:
- SSOT 연결: PLATFORM(터/거울/성능), TOOLCHAIN(실험 관리), GAJI(환경 모음)


---

## 지02. 물리학 시뮬(결정적 물리 실험실)

**한 줄 요약**: 고정64+마디으로 충돌/탄성/진자 등을 완전히 결정적으로 재현하는 물리 실험실.

**목적**:
- 교육(실험)
- 연구/엔진 검증

**또니랑 기둥 연결**: 수학적 엄밀, 결정적 재현, 성능

**차별점**: 부동소수/플랫폼 차이를 제거해 ‘실험 결과를 제출하면 그대로 재현’ 가능한 과학 교실.

**구현 난이도(감)**: 높음

**의존성(필요 요소)**:
- 틀: 고정64/물리 적분/충돌
- 보개: 시각화
- 연장줄: 실험 리플레이/측정 내보내기

**MVP(첫 열매)**:
- 2D 강체(공/벽) 충돌
- 진자 1종
- 측정(최대높이/주기) 자동 계산
- 리플레이 제출

**DoD(마감기준)**:
- 모든 OS에서 동일 궤적(허용오차 0)
- 측정값 해시 고정
- 단위테스트(에너지 보존 등)


---

## 지03. 경제학/사회 시뮬(에이전트 시장)

**한 줄 요약**: 수만 에이전트가 거래/세금/정책에 반응하는 경제·사회 시뮬레이션(결정적 실험장).

**목적**:
- 정책 실험
- 교육/연구

**또니랑 기둥 연결**: 결정적 재현, 성능, 설명 가능성

**차별점**: 정책 A/B를 평행 터로 돌려 ‘같은 시작·다른 정책’의 인과를 명확히 비교 가능.

**구현 난이도(감)**: 매우 높음

**의존성(필요 요소)**:
- 틀: ECS+아키타입 인덱싱
- 연장줄: 실험 비교/통계
- 가지: 정책 모듈
- 보개: 그래프(선택)

**MVP(첫 열매)**:
- 1만 에이전트 소비/저축/거래
- 정책 2개(세율/기본소득)
- 지표 3개(지니/물가/행복)
- 터 비교

**DoD(마감기준)**:
- 동일 정책→동일 지표 해시
- 성능 목표(예: 1만 에이전트 60마디/초)
- 정책 모듈 버전 고정


---

## 지04. 우주 만들기(규칙·상수·생성)

**한 줄 요약**: 사용자가 ‘물리/생태/사회 규칙’을 우리말로 적어 새로운 누리를 창조하고 관찰하는 창조 모드.

**목적**:
- 창의+과학
- 철학/상상력

**또니랑 기둥 연결**: 배움·창작, 결정적 재현, 수학적 엄밀

**차별점**: 규칙이 곧 세계의 헌법이 되는 ‘실행 가능한 창조’.

**구현 난이도(감)**: 매우 높음(종합 프로젝트)

**의존성(필요 요소)**:
- 말+틀+연장줄 전체
- 보개 연출
- 거울/되감기

**MVP(첫 열매)**:
- 생태: 포식/번식/에너지
- 규칙 몇 줄로 세상 생성
- 평행 터로 다른 상수 비교
- 결과 리포트

**DoD(마감기준)**:
- 세상 헌법(규칙) 잠금쪽으로 고정
- 되감기/분기 기능
- 관찰 보고서 자동 생성


---

## 지05. AI 윤리 시뮬레이터(수문장 실험실)

**한 줄 요약**: 슬기의 의도(제안)를 수문장 규칙으로 검사하고, 차단/허용 근거를 거울 감사 로그로 남기는 실험실.

**목적**:
- AI 거버넌스/설명
- 교육(윤리)

**또니랑 기둥 연결**: 슬기 협업, 결정적 재현, 우리말 규칙

**차별점**: ‘한국어로 쓰인 규칙’과 ‘마디 단위 감사 로그’로 규제/감사 친화적 AI 실험이 가능.

**구현 난이도(감)**: 중간~높음(LLM 연동 없이도 규칙 엔진으로 MVP 가능)

**의존성(필요 요소)**:
- 틀: 늘지켜보고/훅/거울 감사
- 말: 규칙 서술
- 연장줄: 리포트/감사뷰어
- 가지: 슬기 브리지(선택)

**MVP(첫 열매)**:
- 의도 패킷 10종(이동/구매/공격 등)
- 규칙 10개(금지/허용/승인)
- 차단 사유 자동 리포트
- 재현 버튼

**DoD(마감기준)**:
- 동일 의도 시퀀스 → 동일 차단 결과/로그 해시
- 규칙 변경 시 영향 범위 diff
- 감사 리포트 출력(PDF/MD 선택)


---

## 지06. 우리 역사·문화 What-if 시뮬

**한 줄 요약**: 역사·문화의 변수(정책/기술/전쟁)를 바꿔 평행 터에서 결과를 비교하는 ‘역사 실험실’.

**목적**:
- 교육 혁신
- 문화 콘텐츠

**또니랑 기둥 연결**: 배움·창작, 결정적 재현, 우리말

**차별점**: 암기형 역사 → 인과 실험. 같은 시작점에서 정책만 바꾸면 차이를 정량 비교.

**구현 난이도(감)**: 높음(모델링이 핵심)

**의존성(필요 요소)**:
- 틀: 경제/사회 시뮬 기반
- 연장줄: 시나리오 템플릿
- 보개: 연표/지도(선택)

**MVP(첫 열매)**:
- 조선 시장/세금/인구 미니모델
- 정책 2개 비교
- 연표 리포트
- 교사용 과제 템플릿

**DoD(마감기준)**:
- 시나리오 입력 해시로 재현
- 지표/연표 해시 고정
- 교재 1개 단원 완성


---

## 지07. 실행 가능한 우리말 법전(Executable Law)

**한 줄 요약**: 법/규정을 관계씨·규칙으로 선언하고 질의로 판정하며, 근거를 추론 트레이스로 설명하는 시스템.

**목적**:
- 법/규정 교육
- 행정/컴플라이언스

**또니랑 기둥 연결**: 우리말, 설명 가능성, 결정성

**차별점**: ‘한국어 규정’이 그대로 실행되며, 판정 근거가 되감기/트레이스로 남는 점.

**구현 난이도(감)**: 높음(지식 모델링+해석)

**의존성(필요 요소)**:
- 가지: 관계씨/질의
- 연장줄: 규정 편집/검증
- 틀: 트레이스/리포트

**MVP(첫 열매)**:
- 상속/계약 미니 규정 1개
- 질의 10개
- 근거(규칙 적용) 설명
- 예외/충돌 진단

**DoD(마감기준)**:
- 질의 결과와 근거 트레이스 해시 고정
- 규정 변경 영향 분석
- 교육용 문제집 템플릿


---

## 지08. 기후·환경 정책 시뮬레이터

**한 줄 요약**: 탄소세/에너지 믹스 같은 정책을 코드로 적고, 장기 시뮬로 결과(온도/경제/복지)를 비교하는 교육·연구 도구.

**목적**:
- 미래 교육
- 정책 실험

**또니랑 기둥 연결**: 시뮬, 결정성, 설명 가능

**차별점**: 정책 논쟁을 ‘재현 가능한 실험’으로 바꾸는 장점.

**구현 난이도(감)**: 높음(모델링+데이터)

**의존성(필요 요소)**:
- 틀: 경제/사회 시뮬 기반
- 연장줄: 데이터 관리(선택)
- 보개: 그래프(선택)

**MVP(첫 열매)**:
- 단순 모델(배출-온도-비용)
- 정책 2개 비교
- 10년/50년 리포트
- 교육용 시나리오 3개

**DoD(마감기준)**:
- 시나리오 입력 해시로 재현
- 지표 해시 고정
- 모델/데이터 버전 고정


---

## 지09. 보안/운영 절차 훈련 누리(절차 리플레이)

**한 줄 요약**: 공격기술이 아니라 ‘절차’(보고/격리/복구)를 결정적 시나리오로 훈련하고, 수행을 리플레이로 검증하는 훈련장.

**목적**:
- 교육/훈련
- 조직 운영

**또니랑 기둥 연결**: 결정성, 감사, 교육

**차별점**: 훈련 결과를 재현 가능한 증적(거울)로 남길 수 있음.

**구현 난이도(감)**: 중간

**의존성(필요 요소)**:
- 틀: 사건/역할/로그
- 연장줄: 체크리스트/평가
- 보개: 상황판(선택)

**MVP(첫 열매)**:
- 시나리오 3개(메일 피싱 대응 등)
- 역할 2개(담당/관리자)
- 행동 로그+평가
- 리플레이

**DoD(마감기준)**:
- 같은 행동→같은 평가 해시
- 평가 기준(DoD) 명문화
- 훈련 리포트 출력


---


# 실체·협업

## 실01. 결정적 멀티플레이 보드게임(치팅 불가)

**한 줄 요약**: 입력 스냅샷과 state_hash 동기화로, 서버는 중계만 하고 모든 클라이언트가 같은 판을 공유하는 보드게임 플랫폼.

**목적**:
- 재미
- 신뢰/공정성 교육

**또니랑 기둥 연결**: 결정적 재현, 재미, 플랫폼

**차별점**: 치팅/분쟁을 ‘해시 불일치’로 즉시 판정 가능한 구조.

**구현 난이도(감)**: 중간

**의존성(필요 요소)**:
- 틀: 네트워크 입력 동결/마디
- 연장줄: 동기화 진단
- 보개: UI

**MVP(첫 열매)**:
- 오목/장기 미니 중 1
- 리플레이 공유
- 해시 불일치 감지
- 관전자 모드(선택)

**DoD(마감기준)**:
- 두 클라이언트 해시 항상 일치
- 분쟁 재현(리플레이) 가능
- 최소 1게임 완성


---

## 실02. 다손 마을(협동 창작 누리)

**한 줄 요약**: 여러 사용자가 동시에 같은 누리를 편집/연출하며, 해시로 ‘같은 진실’을 공유하는 협동 창작 공간.

**목적**:
- 협업 창작
- 커뮤니티

**또니랑 기둥 연결**: 결정적 재현, 배움·창작, 생태계

**차별점**: 협업 편집이 ‘재현 가능한 역사’로 저장되는 점이 독보적.

**구현 난이도(감)**: 매우 높음

**의존성(필요 요소)**:
- 틀: 분산 동기/마디
- 연장줄: 충돌 해결(정본화)
- 보개: 협업 UI
- 가지: 권한/역할(선택)

**MVP(첫 열매)**:
- 2인 협업 편집
- 장면 1개 공동 제작
- 버전/되감기
- 공유 링크

**DoD(마감기준)**:
- 동일 히스토리→동일 해시
- 충돌 규칙 문서화
- 협업 로그(거울)


---

## 실03. 다손 솜씨(로봇/행위자) + 로봇팩

**한 줄 요약**: 보개(가상몸)에서 검증한 제어를 로봇팩(HAL/어댑터)으로 실제 기기에 투영하는 ‘가상→실체’ 트랙.

**목적**:
- 메이커/로봇 교육
- 디지털 트윈

**또니랑 기둥 연결**: 실체 연결, 결정적 강조, 배움·창작

**차별점**: 가상에서 100번 되감기 검증 후 현실에 옮기는 안전한 로봇 교육.

**구현 난이도(감)**: 매우 높음(하드웨어 변동성)

**의존성(필요 요소)**:
- 틀: 사건/입력/시간
- 보개: 시각화
- 가지: 로봇팩 어댑터
- 연장줄: 장치 연결/진단

**MVP(첫 열매)**:
- 마이크로비트/간단 모터 1종
- 가상 로봇 모델 1종
- 동일 동작 시퀀스 재현
- 안전 제한(속도/범위)

**DoD(마감기준)**:
- 같은 명령 스트림→가상 동일, 실체는 허용오차 내
- 장치별 보정은 어댑터 층으로 격리
- 안전 규칙 위반 차단(수문장 재사용 가능)

**비고**:
- ※ ‘솜씨’는 ‘로봇 그 자체’라기보다, ‘실체에 붙는 솜씨(능력/행동 모듈)’로 두는 편이 확장성이 좋습니다.


---


# 메타·인프라

## 메01. 다손 슬기 공방(데이터셋→학습→검증)

**한 줄 요약**: 거울 로그를 데이터셋으로 뽑고, 새 슬기를 학습/평가/포장하는 메타 파이프라인(재현 테스트 포함).

**목적**:
- 슬기 생태계
- 연구/산업

**또니랑 기둥 연결**: 결정적 재현, 슬기 협업, 생태계

**차별점**: ‘학습 과정 전체’를 재현 가능한 형태로 봉인/검증하는 공방.

**구현 난이도(감)**: 매우 높음

**의존성(필요 요소)**:
- 틀: 거울/아티팩트
- 연장줄: 파이프라인(수집/정제/학습/평가)
- 가지: 모델 포맷/정책

**MVP(첫 열매)**:
- 로그→데이터셋 추출
- 간단 모델 학습(외부 프레임워크 연동)
- 회귀 재현 테스트(해시)
- 모델 꾸러미 내보내기

**DoD(마감기준)**:
- 모델 버전마다 재현 테스트 통과
- 데이터셋/모델 잠금쪽
- 평가 리포트 자동 생성


---

## 메02. 공유된 꿈의 도서관(리플레이·모델 거래소)

**한 줄 요약**: 성공한 리플레이/모델/규칙을 ‘책(꾸러미)’로 묶어 공유·재사용하는 생태계(UGC).

**목적**:
- 커뮤니티/시장
- 교육 콘텐츠 유통

**또니랑 기둥 연결**: 생태계, 결정적 재현, 창작

**차별점**: 코드가 아니라 ‘경험(리플레이)+지능(모델)’을 공유한다는 점이 강력한 차별점.

**구현 난이도(감)**: 높음(호환/저작권/버전)

**의존성(필요 요소)**:
- 연장줄: 꾸러미/잠금쪽/곳간(레지스트리)
- 틀: 재현/호환성
- 가지: 메타데이터 규격

**MVP(첫 열매)**:
- 로컬 도서관(내 컴퓨터) + 가져오기/내보내기
- 호환성 검사(버전/의존성)
- 간단 검색/태그
- 샘플 10권

**DoD(마감기준)**:
- 가져온 ‘책’이 지정 버전에서 100% 재현
- 호환 불가 시 진단말
- 메타데이터(기여/라이선스) 포함


---

## 메03. 결정적 부름글 실험대(LLM 실험 재현)

**한 줄 요약**: LLM 호출은 비결정적이므로, 입력/모델/파라미터/출력/승인 과정을 ‘실험 기록’으로 봉인해 회귀 테스트처럼 관리.

**목적**:
- AI 개발 품질
- 감사/규제 대응

**또니랑 기둥 연결**: 감사, 정본화, 슬기 협업

**차별점**: ‘부름글 실험이 재현된다’는 산업적 가치.

**구현 난이도(감)**: 중간

**의존성(필요 요소)**:
- 연장줄: 실험 기록/리포트
- 가지: 슬기 브리지
- 틀: 거울(실험 로그)

**MVP(첫 열매)**:
- 부름글 20개
- 결과 비교(diff)
- 승인된 결과만 정본화
- 회귀 테스트 실행

**DoD(마감기준)**:
- 실험 묶음 해시 고정
- 승인/비승인 기록
- 리포트 자동 생성


---

## v18.0.6 추가 수록: ‘말힘 = 누리 API’ 게임 구상(확장판)

### 프로젝트: **말힘누리 — ‘말로 누리를 움직이는’ 게임**
- 한 줄 정의: “또니랑으로 만든 누리에서, 말힘(=주문)을 말하면 누리가 변한다.”
- 핵심 은유:
  - **API 호출** = 말힘(=주문)
  - **권한/에너지** = 마력/징표(토큰)
  - **세계 구성요소와의 인맥** = 레지스트리(자원/관계)
- 플레이 루프(교육+창작):
  1) 관찰: 거울(기록)로 세계 상태 읽기
  2) 설계: 작은 주문(함수/행동) 작성
  3) 실행: 주문을 부르기 → 세계 변화(결정적)
  4) 되감기: 실패하면 되감고 다른 주문 실험
- 또니랑에 요구되는 최소 요소:
  - Gate0: `{...}하고`, `바탕으로/다짐하고`, 운 소비 규칙
  - AGE2: 거울 시간 참조(되감기), 공간 연산(근처/안에)
  - AGE3: 할힘/밖일(마법 안전장치)

### 프로젝트: **누리 짓기(월드 빌더) + 이야기 실행기**
- 목표: “세계(누리)를 설계(데이터)하고, 이야기(행동)를 실행(코드)한다.”
- 산출물:
  - 누리 스키마(임자/자원/관계/규칙)
  - 이야기 시나리오(퀘스트) DSL
  - 리플레이 파일(결정적) + 관전 UI

### 프로젝트: **슬기 협업 ‘수선 제안기’**
- 계약 위반(전제/보장) 시, 슬기가 “수선 후보”를 제안하는 워크플로
- Gate0 목표: 로그/중단 훅
- AGE3 목표: `... 슬기에게: "어떻게 고칠까?"` 연결

---

# GATE0_IMPLEMENTATION_CHECKLIST v18.0.6

> 목적: **관문 0(정본화기 v0 + 파서/의미해석 v0 + 엔진루프 v0)**가 “문서대로 구현 가능”하고, **비트 단위 결정성 DoD**를 통과하는지 체크한다.

---

## 1) Canonicalizer v0 (정본화기) — MUST
- TODO: 표면 문장을 **정본 토큰열**로 정규화: 붙임 조사는 `~조사`로 표기(또는 토큰 메타로 분리)하고, 단위는 `@단위`로 보존
- TODO: 접미 접착자 순서 고정: `〈값〉[@단위|@"자원"][:핀][~조사]` (예: `100@m:거리~에서`) — 순서 위반 시 오류
- TODO: **의미 보존**: 정본화는 “동작의 정규화”일 뿐, 문장의 **어조(Mood)**(명령/청유/평서/의문 등) 메타를 AST에 보존
- TODO: 모호성 정책: 규칙만으로 단일 해석이 불가하면 **추측 금지** → 오류 + `:핀`(우선) 또는 `~조사` 고정 요구
- TODO: 선택적 인자 표기(`?`)와 기본값 표기(`=값`)를 **원문 의미 그대로 보존**(정본화 과정에서 누락/변형 금지)

---

## 2) Parser + Semantics v0 — MUST

### 접미 체인 파싱 (`@`/`:`/`~`) — MUST
- TODO: 인자 접미 체인 순서 고정: `〈값〉 [@단위|@"자원"] [:핀] [~조사]`
- TODO: `@식별자`는 **단위/자원만** 의미. 핀 고정은 반드시 `:핀`.
- TODO: 역순/중복(예: `값~을:m`, `값@cm@mm`)은 오류
- TODO: 모호성 발생 시 QuickFix: `:핀` 제안
- TODO: 예시(골든) — 토큰화/파싱 결과가 **모든 플랫폼에서 동일**해야 함
- TODO: `100@m:거리~에서`  → 값=100, 단위=m, 핀=거리, 조사=에서
- TODO: `사과:대상~를 먹어.` → 인자(사과) 핀 고정(대상) + 목적격
- TODO: `@"그림/주인공.png":그림~을` → 자원 경로 + 핀 + 목적격
- TODO: 오류: `값~을:대상` (역순)
- TODO: 오류: `값@cm@mm` (중복)
- TODO: 오류: `값@대상` (단위/자원 문맥이 아닌데 핀을 기대하는 오해 방지)
- TODO: 최소 문법 셋(Minimum Syntax Set)만 파싱 (관문 0 범위)
- TODO: 조사형 바인딩 우선순위(폴백) 규칙을 구현하고 테스트로 고정
- TODO: **선택적 인자 기본값 규칙** 구현
- TODO: `?` + `=값` : 생략 시 기본값 주입
- TODO: `?`만 : 생략 시 `없음`으로 정규화
- TODO: 기본값 주입/없음 정규화는 **결정적**이어야 하며, 파서/의미해석의 어떤 단계에서든 플랫폼별 분기 금지

---

## 3) Deterministic Math v0 — MUST/SHOULD
### MUST
- TODO: Fixed64(Q32.32)만 사용(부동소수점 금지), 포화 산술 + 0으로 나누기 시 `산술고장` + **대입 무효화**
- TODO: **DetMath 쓸감 파이프라인 뼈대**
- TODO: 골든 LUT 바이너리(예: `.dtm`)를 **데이터 쓸감**으로 취급
- TODO: 로드 시 파일 해시를 검증하여 “정해진 LUT만” 사용
- TODO: **파일이 없으면 엔진은 구동을 거부**(MUST): 런타임 계산/폴백 금지
- TODO: 플랫폼/아키텍처에 따라 재생성·재계산 금지(계산 대신 데이터)

### MUST (자원/단위 곳간 — 결정성 쓸감)
- TODO: **Asset Registry 로더**:
- TODO: `ddn.asset.json` 로드(정렬/규격 검증) + `path -> entry` 맵 구축
- TODO: 프로그램이 `@"..."` 또는 `"..." 쓸감.`을 사용하면, **매니페스트 없이는 구동 거부**(폴백 스캔/즉석 해시 금지)
- TODO: Strict 모드에서 `hash`/`size` 검증 실패 시 즉시 오류
- TODO: 자원핸들 결정: `xxh3_64("〈bundle_id〉::〈normalized_path〉")` (TOOLCHAIN §T7)
- TODO: **Units Registry 로더**:
- TODO: 단위 심볼 집합을 레지스트리로 고정(예: `ddn.units.json`)하고, 미등록 심볼은 컴파일 오류
- TODO: 환산 계수는 **유리수 비율** 또는 Fixed64 상수로만(부동소수점 금지)
- TODO: 표준 단위 포함: `m`, `cm`, `inch`, `s`
- TODO: 파생 단위 합성: `m/s`, `m/s^2` 파싱/정본화/차원검사

### SHOULD (관문 0 이후를 위한 ‘선행 스모크 테스트’)
- TODO: `sin/cos` LUT(또는 최소 1개 함수) 로드 + 보간 결과의 **골든 해시 일치** 테스트


#### DetMath 차림새(성능/정확도 선택) — SHOULD
- TODO: `DetMath`는 최소 **결정-빠름(Fast)** 경로를 제공(또는 GAJI-DetMath로 제공)하고, 기본 호출은 빠름을 사용하도록 설계
- TODO: (선택) **결정-정밀(Precise)** 경로 제공 시, 차림새별 `algo_id`/쓸감 해시/보간 규칙을 manifest에 핀(결정성 봉인)


---

## 4) EngineLoop v0 — MUST
샘(Sam) → 이야기(Iyagi) → 누리(Nuri) → 거울(Geoul) → 보개(Bogae)
- TODO: Sam: 현재 마디 InputSnapshot을 동결 제공
- TODO: Iyagi: Sam+Nuri를 읽고 Patch와 알림(Alrim) 발행을 산출
- TODO: Nuri: Patch 적용(상태 변경)
- TODO: Geoul: 입력+상태해시 기록
- TODO: Bogae: 읽기 전용 관찰(렌더링은 Stub 가능)

### **대입 무효화(Assignment Invalidation)의 원자성(Atomicity) — MUST**
- TODO: `x <- a / b`에서 `b==0`이면 **x를 절대 변경하지 않음**
- TODO: 이를 위해 Nuri의 Patch 적용은 **2걸음 커밋(two-phase commit)** 구조를 권장
  1) **평가 단계**: RHS 연산/검사 수행(산술고장 여부 포함) → 결과/고장 상태 결정
  2) **커밋 단계**: 고장 없음일 때만 LHS 반영
- TODO: “중간에 x를 건드렸다가 되돌리기” 방식 금지(되돌림 경로에서 결정성 위험)

---

## 5) 알림(Alrim) 연쇄 + 16패스 제한 — MUST/SHOULD
### MUST
- TODO: 동일 마디 안에서 알림 연쇄가 **최대 16패스**를 초과하면 “다음 마디로 이월”
- TODO: 이월 규칙이 플랫폼/성능과 무관하게 **비트 동일**하게 동작

### SHOULD (교육·디버깅 UX)
- TODO: **알림 흐름 시각화(Reactive Flow Profiler)**
- TODO: 각 패스 실행 순서, 실행된 알림, 16패스 도달 시점, 이월된 알림을 시각적으로 표시
- TODO: teul-ide(LSP) 또는 개발용 오버레이로 제공

---

## 6) DoD: 결정성 테스트 스위트 — MUST
### 6.1 크로스 플랫폼 raw_i64 결정성
- TODO: 동일 입력/시드에서 Fixed64 연산 결과 raw_i64가 OS/아키텍처 간 동일

### 6.2 0으로 나누기 + 산술고장 전파
- TODO: `div_assign_det`로 `b==0` 유발
- TODO: (1) 산술고장 알림이 Nuri의 SignalSink/AlrimSink로 흘러감
- TODO: (2) **대입 무효화**로 LHS 값이 변경되지 않음

### 6.3 선택적 인자 기본값(=값) 테스트 5개
- TODO: (A) 기본값 있는 선택적 인자를 생략 → 기본값 주입
- TODO: (B) 기본값 있는 선택적 인자에 값을 제공 → 제공값 우선
- TODO: (C) 기본값 없는 선택적 인자 생략 → `없음` 정규화
- TODO: (D) 다중 선택적 인자(기본값 2개 이상) 생략/혼합 제공 시 결과가 결정적
- TODO: (E) 타입 불일치/모호성 발생 시 “추측” 없이 오류 + @ 요구(정본화 정책 준수)

### 6.4 DetMath 쓸감(골든 LUT) 무결성
- TODO: 골든 LUT 파일 로드 → 파일 해시가 SSOT 상수와 일치
- TODO: **파일이 없으면 즉시 실패(엔진 구동 거부; 런타임 계산 폴백 금지)**
- TODO: 불일치 시 즉시 실패(플랫폼별 대체 LUT 금지)

### 6.5 (선택) sin/cos LUT 보간 골든 해시
- TODO: LUT 기반 `sin/cos`(또는 최소 1개 함수) 보간 결과 해시가 골든과 일치

### 6.6 한국어 활용/표면화(활용·축약·표기) 골든 데이터 — MUST
- TODO: 표면화기는 입력을 **(어간/별칭, 형태소열)**로 받고, 최종 **UTF-8 표면형 문자열**을 생성한다.
- TODO: 아래 골든 데이터 케이스는 플랫폼/아키텍처/로케일과 무관하게 **완전 동일**해야 한다.
- TODO: 단계 순서 고정: **(1) 어간 교대 → (2) 어미 결정 → (3) 축약/표기 정리 → (4) 후행 형태소 결합**

| 케이스 | 원형(어간/별칭) | 결합 형태소(입력 단위) | 기대 표면형 | 비고 |
| --- | --- | --- | --- | --- |
| 1 | 먹 | `니/으니` | 먹으니 | 정규 + 모음끼움 짝어미 선택 |
| 2 | 먹 | `어` | 먹어 | 아/어 선택 |
| 3 | 돌리 | `어` | 돌려 | `ㅣ+ㅓ→ㅕ` 축약 |
| 4 | 돕~도우 | `니/으니` | 도우니 | 교대 후 `니` 선택 |
| 5 | 돕~도우 | `아` | 도와 | 교대 후 `ㅜ+ㅏ→ㅘ` 축약 |
| 6 | 듣~들 | `어` | 들어 | 교대(ㄷ→ㄹ) 후 결합 |
| 7 | 가 | `았` + `다` | 갔다 | `가+았→갔` 표기 정리 후 `갔+다` |
| 8 | 가 | `ㄹ/을(어미)` | 갈 | 관형/미래 쌍어미 선택 |
| 9 | 하 | `여` | 해 | `하+여→해` 표기 정리 |



### 6.8 쓸감 곳간(Asset Registry) 골든 테스트 — MUST

> 정본 파일명은 `ddn.asset.json`이다. v17/초기 문서의 `ddn.asset.json`은 **레거시 별칭**으로 입력에서만 허용(경고)하며, 정본화 출력/문서에서는 사용하지 않는다.
> 근거: SSOT_TOOLCHAIN §T7 (폴백 금지, 매니페스트 없으면 구동 거부, 핸들/해시 검증)
- TODO: (A) **매니페스트 없음 → 구동 거부**  
  - Strict(관문0)에서 `ddn.asset.json`이 없으면 엔진은 **즉시 실패**해야 한다. (런타임 스캔/즉석 해시 폴백 금지)
- TODO: (B) **매니페스트 무효(핸들 불일치) → 구동 거부**  
  - `handle != xxh3_64("〈bundle_id〉::〈normalized_path〉", seed=0)` 인 엔트리가 하나라도 있으면 `ASSET_MANIFEST_INVALID`
- TODO: (C) **해시/크기 불일치 → 실패**  
  - Strict에서 로딩 시(또는 최초 참조 시) `hash` 또는 `size`가 매니페스트와 다르면 `RESOURCE_HASH_MISMATCH`
- TODO: (D) **핸들 결정성(크로스 플랫폼)**  
  - 동일한 `bundle_id::path`에 대해 산출되는 `쓸감손잡이(u64)`이 OS/아키텍처 간 **항상 동일**
- TODO: (E) **경로 정규화 규칙 테스트**  
  - `./` 제거, `..` 금지, trailing slash 금지, `/` 고정 규칙을 케이스로 고정(정규화 실패/규칙 위반 시 구동 거부)

#### 6.8.1 골든 픽스처(권장)
- `bundle_id = "local:default"`
- 파일: `assets/hello.txt` (내용: `"hello\n"`)
- `ddn.asset.json`에는:
  - `path: "assets/hello.txt"`
  - `handle: xxh3_64("local:default::assets/hello.txt", seed=0)`
  - `hash: blake3("hello\n")` (또는 SSOT에서 고정한 해시)
  - `size: 6`

---

### 6.9 단위 곳간(Units Registry) 골든 테스트 — MUST
> 근거: SSOT_TOOLCHAIN §T8 (레지스트리 고정, 유리수 환산, 0쪽 절단)
- TODO: (A) **레지스트리 없음 → 구동 거부(Strict)**  
  - `ddn.units.json`이 없거나 파싱 실패/규칙 위반이면 엔진은 구동을 거부해야 한다.
- TODO: (B) **미등록 단위 심볼 → 오류**  
  - 예: `10@furlong` → `UNIT_UNKNOWN`
- TODO: (C) **inch 환산 결정성(Q32.32 골든)**  
  - 기준: `1 inch = 127/5000 m`  
  - Q32.32에서 `1@inch`를 `m`로 정규화한 raw_i64가 **109092169**(= floor(2^32*127/5000)) 이어야 한다.
- TODO: (D) **음수 환산의 0쪽 절단(trunc toward 0)**  
  - `-1@inch`의 `m` 정규화 raw_i64는 **-109092169** 이어야 한다. (반올림 금지)
- TODO: (E) **유도 단위식 파싱/차원 산술**  
  - `m/s`, `m/s^2`가 단위식으로 파싱되고, 차원 벡터가 각각 `L^1 T^-1`, `L^1 T^-2`로 계산된다.

### 6.7 (선택) DetMath 성능 예산(마이크로벤치/회귀 게이트) — SHOULD

> 목적: “결정성만 맞고 너무 느린 구현”을 막기 위한 **가드레일**.  
> 원칙: 절대 시간 기준은 CI 환경에 좌우되므로, **동일 타겟/동일 러너에서의 회귀(regression)** 를 막는 방식으로 측정한다.
- TODO: `det_sin/ det_cos/ det_sqrt`(또는 제공되는 핵심 DetMath 함수) 각각에 대해 마이크로벤치 하니스를 제공
- TODO: 벤치는 **힙 할당 0**, **시스템콜 0**, **부동소수점 0**을 만족(정적 분석/카운터로 확인 권장)
- TODO: “기준 커밋/릴리스” 대비 평균 실행시간이 **X% 이상 악화**되면 실패(권장 X=20%)
- TODO: 차림새가 둘(빠름/정밀)인 경우:
- TODO: 기본 경로(빠름)가 회귀 게이트의 대상
- TODO: 정밀은 별도 리포트(실패까지는 안 해도 됨)로 추적

## (역사/참고) v18.x 레거시 체크/덧댐노트

Gate0부터는 다음을 **지원하지 않습니다**(문서/구현 혼선을 줄이기 위함).

- `-서` 꼬리
- `}것` 표지
- “레거시 자동 교정” 스타일의 암묵적 치환

v18.x 레거시의 **상세 덧댐노트/자동교정 관련 텍스트**는 `SSOT_PATCH_*` 파일로 이동했습니다.

# v19.2.4 추가 DEMOS: AI Self-Correction 

이 절은 v19.2.4에서 정본화된 **재현묶음(Repro)·거울 질의(TOOLCHAIN)·검증 러너(DetTest/TraceTest)**를 실제 DEMOS로 검증하기 위한 추가분이다.
기존 DEMOS는 v18.0.9 기반을 유지하며, 아래 항목만 추가/확장한다.

## 4.4 골든 검증(golden/*.test.json) & 재현(repro) 연동 — v19.2.4 (ADD-ONLY)

### 4.4.1 테스트 파일 형식(요약)

- 위치: `golden/〈name〉.test.json`
- 공통 필드:
  - `name`
  - `sam_input` (샘 입력 시퀀스/스냅샷 핸들)
  - `max_madi`

#### DetTest (무쇠/주사위용)

- `expected_state_hash`(선택) / `expected_bogae_hash`(선택) / `expected_observations[]`를 사용한다.
- `expected_bogae_hash`는 DrawList 기반 `bogae_hash`를 검증한다. (픽셀 해시 금지) *(DR-053)*
- 콘솔 ASCII 스냅샷 골든은 유지보수 비용이 크므로 기본은 hash 기반을 권장한다. (MAY)

#### TraceTest (열림 포함)

- 재연이 아니라 **추적 사건의 기대값**(예: “규칙위반 0회”, “외부호출 1회”)을 사용한다.

---

### 4.4.2 예시 1: 지킴이 위반(경계 이탈) DetTest

```json
{
  "name": "나비_화면_경계_위반_방지",
  "sam_input": "sam/나비_기본.input.bin",
  "max_madi": 300,
  "det_expected": {
    "no_fault": true,
    "expected_observations": [
      { "madi": 200, "query": "나비.위치.x", "assert": { "op": "range", "min": "0@m", "max": "100@m" } },
      { "madi": 200, "query": "나비.위치.y", "assert": { "op": "range", "min": "0@m", "max": "100@m" } }
    ]
  }
}
```

---

### 4.4.3 예시 2: 열림(Open) TraceTest (재연 대신 추적)

```json
{
  "name": "열림_외부호출_추적_검증",
  "sam_input": "sam/기본.input.bin",
  "max_madi": 50,
  "trace_expected": {
    "events": [
      { "kind": "EXTERNAL_CALL", "count": 1 },
      { "kind": "GUARD_VIOLATION", "count": 0 }
    ]
  }
}
```

---

### 4.4.4 repro 자동 생성 규약

- `teul-cli test` 또는 `teul-cli run` 중 실패 발생 시:
  - `build/repro/ddn.repro.last.json` 생성
  - `geoul.diag.jsonl` 포함(또는 참조)
- 재현 명령(예): `teul-cli run --repro build/repro/ddn.repro.last.json`


### 4.4.5 (AI 공명) “개구리 우주 탈출 사건” — Guard 격리 + Repro/Diag + Patch/Verify

> 목표: **실패를 결정적으로 ‘재현(repro)→관찰(geoul)→교정(patch)→검증(test)’** 하는 최소 폐회로를 **정본 데모**로 고정한다.  
> 주의: §P9.4 지킴이 집행에 따라 위반 대입은 **커밋 전에 폐기**되므로, **실제 상태(개구리.위치)는 경계 밖으로 나가지 않는다.**  
> 대신 `geoul.diag.jsonl`(진단말)에 **시도된 값(105@m)** 과 **출처(SourceSpan)** 가 남는다.

#### (A) 사건 코드(의도적 버그) — `src/개구리.ddn` (예시)

```ddn
# 규칙: 화면 경계는 x ∈ [0@m, 100@m]
화면_경계:지킴이 = { 대상: "개구리.위치.x", 조건: 0@m <= 값 <= 100@m }.

개구리를 만든다.
개구리.위치 <- (x: 95@m, y: 0@m).

(마디)마다 {
  개구리~이 뛰기한다.
}.
```

```ddn
뛰기:씨앗 = {
  # BUG: 경계 검사 없이 10@m 더함 → 105@m 시도
  새_x = 개구리.위치.x + 10@m.
  개구리.위치 <- (x: 새_x, y: 개구리.위치.y).
}.
```

#### (B) 사건 발생(Guard 위반) — 기대 동작

- 마디 t=1에서 `개구리.위치.x <- 105@m` **대입이 시도**된다.
- §P9.4 지킴이 집행:
  - 위반을 감지하면 **해당 대입을 커밋 전에 폐기**한다.
  - 개구리를 `격리(quarantine)` 상태로 표시하고, 후속 씨앗 실행을 차단(또는 제한)한다(플랫폼 선택).
  - 산출물:
    - `build/ddn.repro.last.json` (Dev 차림새 MUST)
    - `geoul.diag.jsonl` (진단말, state_hash 불포함)

#### (C) 관찰(Observation) — 거울 질의(TOOLCHAIN 전용)

```bash
# 1) 실제 상태 확인: 경계 밖으로 나가지 않았음을 확인
teul-cli geoul query "개구리.위치"

# 2) 위반 내역 확인: 시도된 값(105@m)과 출처(SourceSpan)를 확인
teul-cli geoul query "rule:화면_경계 위반"
```

- 기대:
  - `개구리.위치.x <= 100@m` (상태는 안전)
  - 위반 로그에는 `attempted_value = 105@m`, `source_span = (src/개구리.ddn: ... )` 가 존재

#### (D) 재현 묶음(Repro Package) — `build/ddn.repro.last.json` (예시)

```json
{
  "toolchain_version": "v20.4.1",
  "schema_hash": "blake3:...ddn.schema.json",
  "realm_initial_hash": "blake3:...initial_realm",
  "failed_madi": 1,
  "sam_sequence_hash": "blake3:...sam.bin"
}
```

#### (E) 교정(Patch) — `build/ddn.patch.json` (선언적 덧댐, DRAFT 예시)

```json
{
  "patch_version": "0.1-draft",
  "fault_ref": { "repro": "build/ddn.repro.last.json" },
  "changes": [
    {
      "kind": "replace_block",
      "target": { "file": "src/개구리.ddn", "anchor": "뛰기:씨앗" },
      "code": [
        "뛰기:씨앗 = {",
        "  새_x = 개구리.위치.x + 10@m.",
        "  보정_x = 최소값(새_x, 100@m).",
        "  개구리.위치 <- (x: 보정_x, y: 개구리.위치.y).",
        "}."
      ],
      "reason": "화면_경계 지킴이 위반을 사전에 방지(클램프)하여 격리 및 repro 생성이 발생하지 않게 한다."
    }
  ]
}
```

#### (F) 재현 및 검증(TraceTest) — `golden/AI_FROG_ESCAPE.test.json` (예시)

```json
{
  "name": "AI_FROG_ESCAPE",
  "sam_input": "sam/empty.input.bin",
  "max_madi": 10,
  "trace": {
    "no_fault": true,
    "rules_passed": ["화면_경계"],
    "observations": [
      { "madi": 1, "path": "개구리.위치.x", "assert": { "op": "range", "min": "0@m", "max": "100@m" } }
    ]
  }
}
```

```bash
# 덧댐 미리보기 → 승인 → 적용 → 검증(권장 UX 흐름)
teul-cli patch preview build/ddn.patch.json
teul-cli patch approve build/ddn.patch.json
teul-cli patch apply build/ddn.patch.json
teul-cli test golden/AI_FROG_ESCAPE.test.json
```

- PASS 기준:
  - TraceTest에서 `no_fault: true`
  - 관측값 `개구리.위치.x <= 100@m`
  - `geoul.diag.jsonl`에 **화면_경계 위반 이벤트가 0회**



### 20.11 글무늬(템플릿) — 기본

```ddn
# 즉시 렌더(정본)
(이름="또니") 글무늬{"안녕, {이름}!"} 보여주기.

# 무늬값 재사용(정본)
인사:글무늬값 = 글무늬{"안녕, {이름}!"}.
문장:글 = (이름="또니")인 인사 채우기.
문장 보여주기.
```


- `{이름}`은 **자리표시자**입니다.
- `채우기`는 템플릿을 실제 `글`로 렌더합니다.
- `보여주기`는 직접 출력이 아니라, **남김글(LogComponent)** 을 생성합니다. (플랫폼이 렌더)

### 20.12 글무늬 — @포맷(폭/소수/단위) + 엄격 태그

```ddn
# 즉시 렌더(정본)
(id=23, h=123.456@cm) (#엄격) 글무늬{"ID={id|@08}, 키={h|@.3m}"} 보여주기.

# 무늬값 재사용(정본)
기록:글무늬값 = (#엄격)글무늬{"ID={id|@08}, 키={h|@.3m}"}.
문장:글 = (id=23, h=123.456@cm)인 기록 채우기.
문장 보여주기.
```


- `@08` : 폭 8, 0 채움
- `@.3m` : 소수 3자리로 고정 + 출력 단위를 m로

### 20.13 수식 — 풀기(값 구하기) + 글무늬로 보여주기

```ddn
직선:수식값 = (#ascii) 수식{ y = 2*x + 3/2 }.
y:수 = (x=6)인 직선 풀기.

# 즉시 렌더(정본)
(x=6, y=y) 글무늬{"x={x|@.0}, y={y|@.1}"} 보여주기.
```


### 20.14 수식 — 변환(미분하기) + 풀기

```ddn
f:수식값 = 수식{ x^3 + 2*x }.
df:수식값 = f 해서 미분하기.

v0:수 = (x=0)인 df 풀기.
v1:수 = (x=2)인 df 풀기.

# 즉시 렌더(정본)
(a=v0, b=v1) 글무늬{"df(0)={a|@.0}, df(2)={b|@.0}"} 보여주기.
```


### 20.15 씨앗/태그/별칭 — 태그는 값에 붙는다

```ddn
a = (#ascii) 수식{ y = 2*x + 3/2 }.
b <- a.  // b도 같은 수식값(태그 포함)을 참조

y = (x=6)인 b 풀기.

# 즉시 렌더(정본)
(y=y) 글무늬{"y={y|@.2}"} 보여주기.
```



### 20.16 글무늬: `{키.경로}` 필드 선택 (Gate0)

```json
{"toolchain_version": "v20.4.1", "code": "
카드:글무늬값 = 글무늬{ \"이름={사람.이름}, 키={사람.키|@.2m}\" }.

# OK
카드 해서 (사람=(이름:\"또니\", 키:123@cm)) 채우기 해서 보여주기.

# FAIL: 필드 누락 (사람.키가 없음)
# 카드 해서 (사람=(이름:\"또니\")) 채우기.

# FAIL: 널/없음 (명시적으로 없음이 들어오면 실패)
# 카드 해서 (사람=(이름:\"또니\", 키:없음)) 채우기.
"}
```

### 20.17 수식: `풀기` 엄격성 & `#latex` (Gate0)

```json
{"toolchain_version": "v20.4.1", "code": "
직선:수식값 = (#ascii) 수식{ y = 2*x + 3/2 }.

# OK
y:수 = (x=6)인 직선 풀기.

y 해서 보여주기.

# FAIL: 여분 주입(타이포를 잡기 위해 Gate0 정본은 엄격)
# 직선 해서 (x=6, z=1) 풀기.

# FAIL: #latex는 Gate0에서 평가 불가(저장/표시만)
latex식:수식값 = (#latex) 수식{ y = \frac{1}{2}x }.
# latex식 해서 (x=6) 풀기.
latex식 해서 보여주기.
"}
```

---

## §E90 3세계(또니랑누리/한국중세/시간문) 샘플 꾸러미 — “다음 단계 입력”

아래 파일들은 **관문0 구현 시작과 동시에** 바로 테스트 입력(골든)으로 쓸 수 있는 초안이다.  
SSOT 문법을 “설명”으로만 두지 않고, 실제로 *움직이게* 만들기 위한 최소 재료들이다.

- `samples/doni_nuri_magicworld_pack_v0.1.ddn`  
  - 또니/누리/슬라임/기본 마법/아이템 + 공격/피해/회복 규칙(아주 단순) + 아이용 질문
- `samples/kmed_transition_pack_v0.1.ddn`  
  - 교체기(1392 전후) 장터/물품/값/세금 + 아이용 세금 문제
- `samples/timetravel_bridge_pack_v0.1.ddn`  
  - 현대↔교체기 “시간문” + 이동 사건 기록 + 퀘스트 단서 씨앗
- `samples/demo_integrated_magicworld_kmed_timetravel_v0.1.ddn`  
  - 위 3개 꾸러미를 함께 불러온다는 가정 하에, “이야기→학습→보상→상태변화” 루프 1회

> 주의: (DR-026) 언어 문법으로 “불러오기(모듈)”는 제거했다.  
> 모듈 의존성/해시 핀은 Toolchain(ProjectMeta + Lockfile)에서 관리한다.  
> 당장은 글터/도구에서 여러 파일을 한 프로젝트로 묶어 빌드/실행하거나, 데모를 하나로 합치는 방식으로 시작하면 된다.



---

## §D-PACK 예제·테스트·팩(묶음) 확장 규칙 — MUST(운영)

> 사용자 피드백과 AI 협업을 제대로 굴리려면, “예제”가 아니라 **팩(pack)** 으로 관리해야 한다.  
> 팩은 *예제 + 테스트 + 거울(diag) + 기대 결과*가 한 덩어리로 묶인 것이다.

### D-PACK.1 팩의 최소 구성(권장)

- `README.md` : 시나리오/목표/입출력/실행 방법
- `input.ddn` : 정본 입력(또는 입력 생성 스크립트)
- `expect/` : 기대 출력(콘솔/렌더/파일)과 해시
- `diag/` : 거울 로그(선택) 또는 캡처
- `tests/` : 최소 1개 골든 테스트(리플레이 포함)

#### D-PACK.1.1 케이스/골든 파일 규약 — MUST(운영)

> 이 절은 “팩을 자동으로 돌리고, 결과가 흔들리면 바로 잡는” 것을 위해  
> **파일 이름/위치/해시 포맷**을 최소한으로 고정한다. *(DR-143)*

##### [DPACK-CASE-01] 입력 케이스 파일명 — MUST

팩은 `cases/` 아래에 “케이스 키(case_key)”로 묶인 입력을 둔다.

- `case_key` 형식: `KNNN_<slug>`
  - `KNNN` : 3자리 케이스 번호(예: `K001`)
  - `<slug>` : 소문자/숫자/밑줄(`_`)만 사용 권장
- 파일명(권장): `cases/<case_key>.<dialect>.ddn`
  - 예: `cases/K001_keywords.ko.ddn`
- `dialect`(말씨) 값(예): `ko|en|sym3|ja|mn|tr`
  - 말씨별 “허용형(accepted)” 변형이 필요하면 suffix를 붙일 수 있다. (MAY)  
    예: `cases/K010_josa.ja.acc1.ddn`

> NOTE: 팩 러너는 `<case_key>`별로 입력들을 모아 같은 AST로 수렴하는지 검사한다.

##### [DPACK-GOLDEN-01] 정본 출력(golden) 파일명 — MUST

각 `case_key`는 `golden/` 아래에 **정본 산출물 3종**을 둔다.

1) **정본화 소스**: `golden/<case_key>.canon.ddn`  
   - “ko 정본 표기”로 수렴된 출력(= `canon` 출력)  
   - 조사 경계 `~`는 정본화 규칙에 따라 필요시 삽입된 상태여야 한다.  
   - `pretty`/`i18n-*` 출력은 golden 저장에 사용하지 않는다. (MUST NOT)

2) **정본 AST 덤프**: `golden/<case_key>.ast.detjson`  
   - 파서 AST를 DetJson으로 직렬화한 결과  
   - 파일 자체가 **결정적(키 정렬/공백/줄끝 포함)** 이어야 한다. (MUST)

3) **정본 AST 해시**: `golden/<case_key>.ast_hash.txt`  
   - 내용은 1줄: `blake3:<lower-hex64>` + 개행(`\n`) (MUST)  
   - 계산: `BLAKE3-256( bytes(golden/<case_key>.ast.detjson) )`  
   - 표기 형식은 `SSOT_PLATFORM`의 [HASH256-01]을 따른다.

##### [DPACK-EQUIV-01] 동치 검사 규칙(말씨/심볼어) — MUST

- `cases/<case_key>.*.ddn` 각각을 파싱했을 때 **AST 해시가 동일**해야 한다.  
  (기준: `golden/<case_key>.ast_hash.txt`)
- 각 입력을 `canon`으로 정본화했을 때 출력이 **`golden/<case_key>.canon.ddn`와 동일**해야 한다.
- `fmt --style=<dialect>` 출력은 **다시 파싱 시 동일 AST로 복원**되어야 한다. (SHOULD)

##### [DPACK-GOLDEN-02] 추가 산출물(선택) — MAY

팩은 필요 시 다음을 추가로 둘 수 있다.

- `golden/<case_key>.canon_hash.txt` : canon.ddn의 HASH256 (검증 가속)
- `diag/<case_key>.lint.detjson` : lint/진단 스냅샷(해시에 영향 없는 참고)
- `notes/<case_key>.md` : 케이스 의도/경계조건 메모

### D-PACK.2 팩 카탈로그(초안)

아래는 “또니랑누리 + 학습/시각화 + 엔진 연동”을 한 줄기에서 계속 키우기 위한 추천 팩들이다.

- `pack/doni_nuri_core` : 또니랑누리 최소 월드(첫 고개 11-xx용)
- `pack/doni_nuri_kmed` : KMED(지식 미로) 퀘스트/대화/학습(4~5고개용)
- `pack/doni_nuri_timetravel` : 시간여행(리플레이/스크럽/상태 해시 강조)
- `pack/nuri_gym_cartpole` : NuriGym 대표 강화학습(관측/행동/보상/리플레이)
- `pack/manim_mathviz_basics` : 수식→장면(수식/수치/텍스트 렌더)
- `pack/bogae_console_showcase` : 보개 콘솔 렌더(결정성/레코딩/재현)
- `pack/bogae_unity_bridge` : Unity 어댑터 최소(AGE3)
- `pack/bogae_godot_bridge` : Godot 어댑터 최소(AGE3)

- `pack/edu_s1_function_graph` : 교과 연계 MVP S1 (움직이는 함수 그래프)
- `pack/edu_s2_projectile` : 교과 연계 MVP S2 (포물선 운동/투사체)
- `pack/edu_s3_supply_demand_tax` : 교과 연계 MVP S3 (수요·공급 균형 + 세금)

### D-PACK.3 운영 원칙

- 팩은 언제든 추가/확장할 수 있다(AGE0 동결과 무관).
- 단, 팩이 커질수록 “정본 + 재현 + 골든”이 더 중요해진다.
- 팩이 SSOT 예제에 인용되면, 그 예제는 **팩의 정본 산출물**을 단일 출처로 삼는다(문서와 코드가 갈라지지 않게).


### D-PACK.4 교육 D-PACK 규격(권장, SSOT 밖 규약)

> 목적: 교과 연계(수학/과학/경제) 데모를 “문법”이 아니라 **pack/docs 규격**으로 통일한다.  
> 지위: 이 절은 SSOT 안에서는 **SHOULD(권장)** 이며, 상세 콘텐츠(단원/지도안/문항)는 SSOT 밖에서 누적한다.

#### D-PACK.4.1 CurriculumMetaV1(필드 이름만 고정)

- `과목`, `학년군`, `단원`, `차시`, `난이도`
- `학습목표[]`, `핵심개념[]`, `선수개념[]`, `오개념[]`
- `허용조작[]`(잠금 정책), `기본값`, `가정목록[]`
- `필수계기판[]`, `필수그래프[]`, `필수표[]`
- `확인문제[]`, `채점규칙`, `피드백규칙`
- `teacher_notes_ref`, `student_sheet_ref`

#### D-PACK.4.2 교육 D-PACK 표준 트리(권장)

- 정본 위치: `pack/edu_<lesson_id>/...`  *(예: `pack/edu_s1_function_graph/...`)*
- 최소 구성:
  - `lesson.ddn`
  - `meta.toml` *(CurriculumMetaV1)*
  - `inputs/*.detjson` *(또는 `*.bin`)* — 정답/오답/심화 입력샘
  - `checks/*` — 구조 검사/불변식/정답 범위
  - `teacher_notes.md`, `student_sheet.md`
  - (선택) `golden/` — `state_hash` / `bogae_hash` 기대값

#### D-PACK.4.3 결정성·리플레이·보개(보여주기) 정합 규칙

- UI 조작은 세계를 직접 바꾸지 않는다. 조작은 **샘(InputSnapshot)** 으로 봉인되고, 반영은 `샘 → 이야기 → 누리` 경로로만 일어난다.
- 되감기(시간 이동)는 “상태 역행”이 아니라 **리플레이 재생**으로 구현한다.
- 보개 골든은 픽셀 해시 금지. **DrawList(DetBin) 해시(bogae_hash)** 로 검증한다.

#### D-PACK.4.4 BDL 메타(tag/id/origin) 처리(이월)

- BDL1(DrawListV1) 커맨드 집합은 최소 프리미티브로 동결되어 있으므로,
  `id/tag/origin` 같은 세맨틱 메타를 **BDL1 포맷에 직접 넣지 않는다.**
- 세맨틱이 필요하면:
  - (권장) `diag/semantic_map.detjson` 같은 **해시에 영향 없는 진단 파일**로 분리하거나,
  - BDL2(차기)로 이월하여 정식 필드로 도입한다.

#### D-PACK.4.5 최소 검증(권장 DoD)

- 동일 입력샘 재생 → 동일 `state_hash`
- 동일 DrawList 생성 → 동일 `bogae_hash`
- 교과판 질문 2개 이상이 “입력샘 프리셋”과 연결되어야 한다(버튼 누르면 로드)


---
===== END SSOT_DEMOS_v20.6.33.md =====
===== BEGIN GATE0_IMPLEMENTATION_CHECKLIST_v20.6.33.md =====
# GATE0_IMPLEMENTATION_CHECKLIST (v20.6.33)
- Generated: 2026-02-11
- Purpose: Gate0 구현체/도구체인이 “정본 SSOT”를 따라가고 있는지 점검하는 체크리스트

> 체크리스트는 **pack 통과**가 최종 판정이며, 이 문서는 “놓치기 쉬운 구현 포인트”를 빠르게 훑기 위한 용도입니다.

---

## A. 파서/토크나이저(문법 바닥)
- [ ] UTF-8(무BOM) / LF 기준 입력 처리
- [ ] 점(`.`)의 2중 역할(접근 vs 종결) 처리
- [ ] `{}` 토막 + `}하고/}한것/}인것/}아닌것/}해서` 평가 표지 처리
- [ ] 조사 경계 `~` 처리
- [ ] (선택) 통합 선언 설탕 `채비:` 블록을 `그릇채비:` + `붙박이마련:`으로 분해하는 전처리/정본화 처리
- [ ] 시스템 예약 단자음 식별자 예약 처리(사용자 정의 금지)

---

## B. 정본화(Formatter/Canon)
- [ ] 정본 출력은 순우리말 정본 용어로 수렴(별칭 입력은 허용)
- [ ] 레거시 `살림.` 입력은 `바탕.`과 동치로 해석 가능
- [ ] 정본 출력은 항상 `바탕.`으로 표기
- [ ] `#바탕숨김` 입력을 지원하는 경우: 정본 출력에서는 접두를 드러내어 저장(권장)

---

## C. 진단/오류/경고(결정적)
- [ ] 오류 코드/메시지 결정성(동일 입력→동일 출력)
- [ ] 레거시 별칭 사용 시 경고 정책(파일당 1회 등) 준수(권장)
- [ ] `#바탕숨김` 사용 시 “새 바탕 칸 생성” 위험에 대한 오류/강경고(권장)

---

## D. pack/golden
- [ ] 최소 1개 언어 pack(PASS/FAIL/경고)로 Gate0 기본 규칙 검증
- [ ] golden 출력이 OS/플랫폼에 따라 달라지지 않음(줄끝/정렬/해시 포함)


---

## E. 브리지/실행 경로(성능 + 결정성)

`cargo run` 기반 실행은 빌드 체크 오버헤드로 인해 “DDN 실행”보다 느릴 수 있으므로,
Gate0에서도 기본값은 **빌드된 `teul-cli` 바이너리 직접 호출**로 둔다.

- [ ] `bridge_server.py` 기본 실행 경로가 `cargo run ... -- run <file.ddn>`가 아니라, **`teul-cli` 바이너리 직접 호출**이다.
- [ ] `TEUL_CLI_BIN`(환경변수)로 바이너리 경로를 지정할 수 있다.
- [ ] 바이너리 탐색/선택 규칙이 `SSOT_TOOLCHAIN §TC0.3.2`의 결정적 알고리즘을 따른다.
- [ ] (Gate0 한정) 바이너리가 없을 때만 `cargo run` 폴백이 가능하며,
  - [ ] 반드시 경고(`WARN[TC0.3 cargo_fallback]`)를 출력하고,
  - [ ] 실행 메타에 `exec_kind="cargo_fallback"`를 기록한다.

(선택, 상주 모드)

- [ ] `teul-cli repl`에 `:reset`이 있고, 요청마다 `:reset` 후 실행한다.
- [ ] stdout 경계(프레이밍)는 Gate0에서는 sentinel을 임시 허용할 수 있으나,
  - [ ] AGE1+ 목표는 `DetJson-RPC v1`로 전환(SSOT_TOOLCHAIN §TC0.3.4).
===== END GATE0_IMPLEMENTATION_CHECKLIST_v20.6.33.md =====
