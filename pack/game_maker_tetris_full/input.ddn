// Tetris Full (DDN): 7-bag + 홀드 + 고스트 + 점수/레벨/콤보/백투백
// - CLI/웹/데스크톱(웹뷰) 공통
// - 결정적 RNG: --seed 사용 권장

#바탕숨김.
그릇채비: {
  보개_그림판_가로:수 <- 368.
  보개_그림판_세로:수 <- 400.
  보개_바탕색:글 <- "#0b0f18ff".
  보드_가로:수 <- 10.
  보드_세로:수 <- 20.
  셀:수 <- 16.
  보드_원점_x:수 <- 32.
  보드_원점_y:수 <- 48.
  패널_시작_x:수 <- 보드_원점_x + (보드_가로 * 셀) + 16.
  패널_텍스트_x:수 <- 패널_시작_x + 4.
  패널_텍스트_y:수 <- 48.
  패널_줄간격:수 <- 16.
  보드:글 <- (보드_가로, 보드_세로) tetris_board_new.
  총_줄:수 <- 0.
  점수:수 <- 0.
  레벨:수 <- 1.
  콤보:수 <- -1.
  백투백:수 <- 0.
  낙하_기본:수 <- 30.
  낙하_가속:수 <- 2.
  낙하_최소:수 <- 1.
  낙하_주기:수 <- 낙하_기본.
  낙하_카운트:수 <- 0.
  락_지연:수 <- 30.
  락_카운트:수 <- 0.
  이동_방향:수 <- 0.
  이동_카운트:수 <- 0.
  이동_딜레이:수 <- 8.
  이동_반복:수 <- 2.
  다음_큐_길이:수 <- 5.
  가방:차림 <- [0, 1, 2, 3, 4, 5, 6].
  다음_큐:차림 <- [].
  홀드_id:수 <- -1.
  홀드_사용됨:수 <- 0.
  조각_id:수 <- 0.
  조각_x:수 <- 4.
  조각_y:수 <- 0.
  조각_회전:수 <- 0.
  마지막_회전:수 <- 0.
  게임오버:수 <- 0.
  게임오버_텍스트:글 <- "".
  라인_연출_카운트:수 <- 0.
  라인_연출_텍스트:글 <- "".
  조각_심볼:글 <- "sym:tetris.I".
  조각_문자:글 <- "I".
  조각_심볼_목록:차림 <- ["sym:tetris.I", "sym:tetris.O", "sym:tetris.T", "sym:tetris.S", "sym:tetris.Z", "sym:tetris.J", "sym:tetris.L"].
  조각_문자_목록:차림 <- ["I", "O", "T", "S", "Z", "J", "L"].
  홀드_문자:글 <- "-".
  다음_문자열:글 <- "".
  도움말_텍스트:글 <- "왼/오 이동 아래 소프트 위 회전 Z 반회전 X 홀드 스페이스 하드".
  게임오버_라벨:글 <- "GAME OVER".
  점수_라벨:글 <- "SCORE".
  줄수_라벨:글 <- "LINES".
  레벨_라벨:글 <- "LEVEL".
  콤보_라벨:글 <- "COMBO".
  백투백_라벨:글 <- "B2B".
  홀드_라벨:글 <- "HOLD".
  다음_라벨:글 <- "NEXT".
  킥_일반:차림 <- [(x=0, y=0), (x=1, y=0), (x=-1, y=0), (x=0, y=-1), (x=1, y=-1), (x=-1, y=-1), (x=2, y=0), (x=-2, y=0)].
  킥_I:차림 <- [(x=0, y=0), (x=2, y=0), (x=-2, y=0), (x=1, y=0), (x=-1, y=0), (x=0, y=-1), (x=0, y=1)].
  보개_그림판_목록:차림 <- (보드, 보드_가로, 보드_세로, 보드_원점_x, 보드_원점_y, 셀) tetris_board_drawlist.
  가능_낙하:참거짓.
  가능_아래:참거짓.
  가능_이동:참거짓.
  가능_회전:참거짓.
  가방_길이:수.
  게임오버표:묶음.
  고스트_y:수.
  기본_점수:수.
  낙하_동작:수.
  다음_x:수.
  다음_y:수.
  다음_문자_목록:차림.
  다음_회전:수.
  다음표:묶음.
  도움말:묶음.
  라인표:묶음.
  락_리셋:수.
  락_실행:수.
  락결과:묶음.
  레벨표:묶음.
  백투백표:묶음.
  블록_목록:차림.
  블록_x_목록:차림.
  블록_y_목록:차림.
  고스트_x_목록:차림.
  고스트_y_목록:차림.
  뽑기_인덱스:수.
  뽑힌_id:값.
  상태:글.
  상태표:묶음.
  스폰_가능:참거짓.
  유령:묶음.
  유령1:묶음.
  유령2:묶음.
  유령3:묶음.
  이동_실행:수.
  이동_요청:수.
  임시_블록:묶음.
  임시_id:값.
  임시_문자:글.
  입력_아래쪽:수.
  입력_오른쪽:수.
  입력_왼쪽:수.
  입력_하드:수.
  입력_홀드:수.
  입력_회전_반시계:수.
  입력_회전_시계:수.
  점수표:묶음.
  줄수표:묶음.
  즉시_락:수.
  지운줄:수.
  코너0:묶음.
  코너0_색:글.
  코너1:묶음.
  코너1_색:글.
  코너2:묶음.
  코너2_색:글.
  코너3:묶음.
  코너3_색:글.
  코너_채움:수.
  콤보_보너스:수.
  콤보표:묶음.
  킥_dx:값.
  킥_dy:값.
  킥_목록:값.
  특수_성공:수.
  티스핀:수.
  픽셀_x:차림.
  픽셀_y:차림.
  하드_y:수.
  하드_거리:수.
  현재:묶음.
  현재1:묶음.
  현재2:묶음.
  현재3:묶음.
  홀드표:묶음.
  회전_델타:수.
  회전_성공:수.
}.

(시작)할때 {
  현재.생김새.결 <- #보개/2D.Sprite.
  현재.생김새.그림 <- (x=보드_원점_x, y=보드_원점_y, w=셀, h=셀, uri="sym:tetris.I").
  현재.생김새.색 <- "#ffffffff".
  현재1.생김새.결 <- #보개/2D.Sprite.
  현재1.생김새.그림 <- (x=보드_원점_x, y=보드_원점_y, w=셀, h=셀, uri="sym:tetris.I").
  현재1.생김새.색 <- "#ffffffff".
  현재2.생김새.결 <- #보개/2D.Sprite.
  현재2.생김새.그림 <- (x=보드_원점_x, y=보드_원점_y, w=셀, h=셀, uri="sym:tetris.I").
  현재2.생김새.색 <- "#ffffffff".
  현재3.생김새.결 <- #보개/2D.Sprite.
  현재3.생김새.그림 <- (x=보드_원점_x, y=보드_원점_y, w=셀, h=셀, uri="sym:tetris.I").
  현재3.생김새.색 <- "#ffffffff".

  유령.생김새.결 <- #보개/2D.Sprite.
  유령.생김새.그림 <- (x=보드_원점_x, y=보드_원점_y, w=셀, h=셀, uri="sym:tetris.I").
  유령.생김새.색 <- "#ffffff44".
  유령1.생김새.결 <- #보개/2D.Sprite.
  유령1.생김새.그림 <- (x=보드_원점_x, y=보드_원점_y, w=셀, h=셀, uri="sym:tetris.I").
  유령1.생김새.색 <- "#ffffff44".
  유령2.생김새.결 <- #보개/2D.Sprite.
  유령2.생김새.그림 <- (x=보드_원점_x, y=보드_원점_y, w=셀, h=셀, uri="sym:tetris.I").
  유령2.생김새.색 <- "#ffffff44".
  유령3.생김새.결 <- #보개/2D.Sprite.
  유령3.생김새.그림 <- (x=보드_원점_x, y=보드_원점_y, w=셀, h=셀, uri="sym:tetris.I").
  유령3.생김새.색 <- "#ffffff44".

  상태표.생김새.결 <- #보개/2D.Text.
  상태표.생김새.글씨 <- (x=4, y=4, size=12, text="").
  상태표.생김새.색 <- "#ffffffff".

  도움말.생김새.결 <- #보개/2D.Text.
  도움말.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 6), size=10, text=도움말_텍스트).
  도움말.생김새.색 <- "#88c0d0ff".

  라인표.생김새.결 <- #보개/2D.Text.
  라인표.생김새.글씨 <- (x=4, y=30, size=10, text="").
  라인표.생김새.색 <- "#ffd166ff".
  게임오버표.생김새.결 <- #보개/2D.Text.
  게임오버표.생김새.글씨 <- (x=52, y=150, size=16, text="").
  게임오버표.생김새.색 <- "#ff6b6bff".

  점수표.생김새.결 <- #보개/2D.Text.
  점수표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y, size=12, text="").
  점수표.생김새.색 <- "#ffffffff".

  줄수표.생김새.결 <- #보개/2D.Text.
  줄수표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + 패널_줄간격, size=12, text="").
  줄수표.생김새.색 <- "#ffd166ff".

  레벨표.생김새.결 <- #보개/2D.Text.
  레벨표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 2), size=12, text="").
  레벨표.생김새.색 <- "#f4f1deff".

  콤보표.생김새.결 <- #보개/2D.Text.
  콤보표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 3), size=10, text="").
  콤보표.생김새.색 <- "#a8dadcff".

  백투백표.생김새.결 <- #보개/2D.Text.
  백투백표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 4), size=10, text="").
  백투백표.생김새.색 <- "#a8dadcff".

  홀드표.생김새.결 <- #보개/2D.Text.
  홀드표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 8), size=12, text="").
  홀드표.생김새.색 <- "#ffd166ff".

  다음표.생김새.결 <- #보개/2D.Text.
  다음표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 10), size=10, text="").
  다음표.생김새.색 <- "#cdb4dbff".

  // 초기 큐 채우기
  { (다음_큐) 길이 < 다음_큐_길이 }인것 동안: {
    가방_길이 <- (가방) 길이.
    { (가방_길이 == 0) }인것 일때 {
      가방 <- [0, 1, 2, 3, 4, 5, 6].
      가방_길이 <- 7.
    }.
    뽑기_인덱스 <- (0, 가방_길이 - 1) 무작위정수.
    뽑힌_id <- 가방[뽑기_인덱스].
    가방 <- (가방, 뽑기_인덱스) 제거.
    다음_큐 <- (다음_큐, 뽑힌_id) 추가.
  }.

  조각_id <- 다음_큐[0].
  다음_큐 <- (다음_큐, 0) 제거.

  { (다음_큐) 길이 < 다음_큐_길이 }인것 동안: {
    가방_길이 <- (가방) 길이.
    { (가방_길이 == 0) }인것 일때 {
      가방 <- [0, 1, 2, 3, 4, 5, 6].
      가방_길이 <- 7.
    }.
    뽑기_인덱스 <- (0, 가방_길이 - 1) 무작위정수.
    뽑힌_id <- 가방[뽑기_인덱스].
    가방 <- (가방, 뽑기_인덱스) 제거.
    다음_큐 <- (다음_큐, 뽑힌_id) 추가.
  }.

  // 스폰 리셋
  조각_x <- 4.
  조각_y <- 0.
  조각_회전 <- 0.
  락_카운트 <- 0.
  낙하_카운트 <- 0.
  마지막_회전 <- 0.
  스폰_가능 <- (보드, 보드_가로, 보드_세로, 조각_id, 조각_회전, 조각_x, 조각_y) tetris_can_place.
  { 스폰_가능 }아닌것 일때 {
    게임오버 <- 1.
    게임오버_텍스트 <- 게임오버_라벨.
  }.

}.

(매마디)마다 {
  입력_왼쪽 <- 샘.키보드.누르고있음.왼쪽화살표.
  입력_오른쪽 <- 샘.키보드.누르고있음.오른쪽화살표.
  입력_아래쪽 <- 샘.키보드.누르고있음.아래쪽화살표.
  입력_회전_시계 <- 샘.키보드.눌림.위쪽화살표.
  입력_회전_반시계 <- 샘.키보드.눌림.Z키.
  입력_홀드 <- 샘.키보드.눌림.X키.
  입력_하드 <- 샘.키보드.눌림.스페이스.

  (게임오버 == 0) 일때 {
    락_리셋 <- 0.
    마지막_회전 <- 0.
    즉시_락 <- 0.

    // 좌우 이동(DAS/ARR)
    이동_요청 <- 0.
    (입력_왼쪽 == 1) 일때 {
      이동_요청 <- -1.
    } 아니면 {
      (입력_오른쪽 == 1) 일때 {
        이동_요청 <- 1.
      } 아니면 {
        이동_요청 <- 0.
      }.
    }.

    이동_실행 <- 0.
    (이동_요청 == 0) 일때 {
      이동_방향 <- 0.
      이동_카운트 <- 0.
    } 아니면 {
      (이동_방향 != 이동_요청) 일때 {
        이동_방향 <- 이동_요청.
        이동_카운트 <- 이동_딜레이.
        이동_실행 <- 1.
      } 아니면 {
        (이동_카운트 > 0) 일때 {
          이동_카운트 <- 이동_카운트 - 1.
          (이동_카운트 == 0) 일때 {
            이동_실행 <- 1.
            이동_카운트 <- 이동_반복.
          }.
        } 아니면 {
          이동_실행 <- 1.
          이동_카운트 <- 이동_반복.
        }.
      }.
    }.

    (이동_실행 == 1) 일때 {
      다음_x <- 조각_x + 이동_방향.
      가능_이동 <- (보드, 보드_가로, 보드_세로, 조각_id, 조각_회전, 다음_x, 조각_y) tetris_can_place.
      (가능_이동) 일때 {
        조각_x <- 다음_x.
        락_리셋 <- 1.
      }.
    }.

    // 하드 드롭
    (입력_하드 == 1) 일때 {
      하드_y <- (보드, 보드_가로, 보드_세로, 조각_id, 조각_회전, 조각_x, 조각_y) tetris_drop_y.
      하드_거리 <- 하드_y - 조각_y.
      (하드_거리 > 0) 일때 {
        점수 <- 점수 + (하드_거리 * 2).
      }.
      조각_y <- 하드_y.
      즉시_락 <- 1.
      낙하_카운트 <- 0.
    } 아니면 {
      // 소프트/중력 낙하
      낙하_카운트 <- 낙하_카운트 + 1.
      낙하_동작 <- 0.
      (입력_아래쪽 == 1) 일때 {
        낙하_동작 <- 1.
      } 아니면 {
        (낙하_카운트 >= 낙하_주기) 일때 {
          낙하_동작 <- 1.
        }.
      }.
      (낙하_동작 == 1) 일때 {
        낙하_카운트 <- 0.
        다음_y <- 조각_y + 1.
        가능_낙하 <- (보드, 보드_가로, 보드_세로, 조각_id, 조각_회전, 조각_x, 다음_y) tetris_can_place.
        (가능_낙하) 일때 {
          조각_y <- 다음_y.
          (입력_아래쪽 == 1) 일때 {
            점수 <- 점수 + 1.
            락_리셋 <- 1.
          }.
        }.
      }.
    }.

    // 회전(간이 킥)
    회전_델타 <- 0.
    (입력_회전_시계 == 1) 일때 {
      회전_델타 <- 1.
    } 아니면 {
      (입력_회전_반시계 == 1) 일때 {
        회전_델타 <- -1.
      }.
    }.
    (회전_델타 != 0) 일때 {
      다음_회전 <- 조각_회전 + 회전_델타.
      (다음_회전 < 0) 일때 {
        다음_회전 <- 3.
      }.
      (다음_회전 > 3) 일때 {
        다음_회전 <- 0.
      }.
      회전_성공 <- 0.
      킥_목록 <- 킥_일반.
      { (조각_id == 0) }인것 일때 {
        킥_목록 <- 킥_I.
      }.
      (오프셋) 킥_목록에 대해: {
        { (회전_성공 == 0) }인것 일때 {
          킥_dx <- 오프셋.x.
          킥_dy <- 오프셋.y.
          가능_회전 <- (보드, 보드_가로, 보드_세로, 조각_id, 다음_회전, 조각_x + 킥_dx, 조각_y + 킥_dy) tetris_can_place.
          (가능_회전) 일때 {
            조각_x <- 조각_x + 킥_dx.
            조각_y <- 조각_y + 킥_dy.
            조각_회전 <- 다음_회전.
            회전_성공 <- 1.
            락_리셋 <- 1.
            마지막_회전 <- 1.
          }.
        }.
      }.
    }.

    // 홀드
    (입력_홀드 == 1) 일때 {
      (홀드_사용됨 == 0) 일때 {
        홀드_사용됨 <- 1.
        (홀드_id == -1) 일때 {
          홀드_id <- 조각_id.
          조각_id <- 다음_큐[0].
          다음_큐 <- (다음_큐, 0) 제거.
          { (다음_큐) 길이 < 다음_큐_길이 }인것 동안: {
            가방_길이 <- (가방) 길이.
            { (가방_길이 == 0) }인것 일때 {
              가방 <- [0, 1, 2, 3, 4, 5, 6].
              가방_길이 <- 7.
            }.
            뽑기_인덱스 <- (0, 가방_길이 - 1) 무작위정수.
            뽑힌_id <- 가방[뽑기_인덱스].
            가방 <- (가방, 뽑기_인덱스) 제거.
            다음_큐 <- (다음_큐, 뽑힌_id) 추가.
          }.
        } 아니면 {
          임시_id <- 조각_id.
          조각_id <- 홀드_id.
          홀드_id <- 임시_id.
        }.
        // 스폰 리셋
        조각_x <- 4.
        조각_y <- 0.
        조각_회전 <- 0.
        락_카운트 <- 0.
        낙하_카운트 <- 0.
        마지막_회전 <- 0.
        스폰_가능 <- (보드, 보드_가로, 보드_세로, 조각_id, 조각_회전, 조각_x, 조각_y) tetris_can_place.
        { 스폰_가능 }아닌것 일때 {
          게임오버 <- 1.
          게임오버_텍스트 <- 게임오버_라벨.
        }.
      }.
    }.

    // 락 딜레이
    가능_아래 <- (보드, 보드_가로, 보드_세로, 조각_id, 조각_회전, 조각_x, 조각_y + 1) tetris_can_place.
    락_실행 <- 0.
    (즉시_락 == 1) 일때 {
      락_실행 <- 1.
    } 아니면 {
      { 가능_아래 }아닌것 일때 {
        (락_리셋 == 1) 일때 {
          락_카운트 <- 0.
        } 아니면 {
          락_카운트 <- 락_카운트 + 1.
        }.
        (락_카운트 >= 락_지연) 일때 {
          락_실행 <- 1.
        }.
      } 아니면 {
        락_카운트 <- 0.
      }.
    }.

    (락_실행 == 1) 일때 {
      // T-Spin 간이 판정
      티스핀 <- 0.
      (조각_id == 2) 일때 {
        (마지막_회전 == 1) 일때 {
          코너_채움 <- 0.
          코너0 <- (보드, 보드_가로, 보드_세로, 조각_x + 0, 조각_y + 0) tetris_board_cell.
          코너0_색 <- (코너0, "color") 묶음값.
          (코너0_색 != "#00000000") 일때 { 코너_채움 <- 코너_채움 + 1. }.
          코너1 <- (보드, 보드_가로, 보드_세로, 조각_x + 2, 조각_y + 0) tetris_board_cell.
          코너1_색 <- (코너1, "color") 묶음값.
          (코너1_색 != "#00000000") 일때 { 코너_채움 <- 코너_채움 + 1. }.
          코너2 <- (보드, 보드_가로, 보드_세로, 조각_x + 0, 조각_y + 2) tetris_board_cell.
          코너2_색 <- (코너2, "color") 묶음값.
          (코너2_색 != "#00000000") 일때 { 코너_채움 <- 코너_채움 + 1. }.
          코너3 <- (보드, 보드_가로, 보드_세로, 조각_x + 2, 조각_y + 2) tetris_board_cell.
          코너3_색 <- (코너3, "color") 묶음값.
          (코너3_색 != "#00000000") 일때 { 코너_채움 <- 코너_채움 + 1. }.
          (코너_채움 >= 3) 일때 {
            티스핀 <- 1.
          }.
        }.
      }.

      락결과 <- (보드, 보드_가로, 보드_세로, 조각_id, 조각_회전, 조각_x, 조각_y) tetris_lock.
      보드 <- (락결과, "보드") 묶음값.
      지운줄 <- (락결과, "지운줄") 묶음값.

      // 점수 계산
      기본_점수 <- 0.
      (티스핀 == 1) 일때 {
        고르기:
          { (지운줄 == 0) }인것: { 기본_점수 <- 100. }
          { (지운줄 == 1) }인것: { 기본_점수 <- 800. }
          { (지운줄 == 2) }인것: { 기본_점수 <- 1200. }
          { (지운줄 >= 3) }인것: { 기본_점수 <- 1600. }
          아니면: { 기본_점수 <- 0. }.
      } 아니면 {
        고르기:
          { (지운줄 == 1) }인것: { 기본_점수 <- 100. }
          { (지운줄 == 2) }인것: { 기본_점수 <- 300. }
          { (지운줄 == 3) }인것: { 기본_점수 <- 500. }
          { (지운줄 == 4) }인것: { 기본_점수 <- 800. }
          아니면: { 기본_점수 <- 0. }.
      }.

      특수_성공 <- 0.
      (티스핀 == 1) 일때 {
        (지운줄 > 0) 일때 { 특수_성공 <- 1. }.
      } 아니면 {
        (지운줄 == 4) 일때 { 특수_성공 <- 1. }.
      }.

      (지운줄 > 0) 일때 {
        콤보 <- 콤보 + 1.
      } 아니면 {
        콤보 <- -1.
      }.

      콤보_보너스 <- 0.
      (콤보 >= 1) 일때 {
        콤보_보너스 <- 콤보 * 50.
      }.

      (특수_성공 == 1) 일때 {
        (백투백 == 1) 일때 {
          기본_점수 <- 기본_점수 + (기본_점수 / 2).
        }.
        백투백 <- 1.
      } 아니면 {
        (지운줄 > 0) 일때 {
          백투백 <- 0.
        }.
      }.

      점수 <- 점수 + 기본_점수 + 콤보_보너스.

      (지운줄 > 0) 일때 {
        총_줄 <- 총_줄 + 지운줄.
        라인_연출_카운트 <- 12.
        라인_연출_텍스트 <- (lines=지운줄, pts=기본_점수, combo=콤보) 글무늬{"CLEAR {lines} +{pts} C{combo}"}.
      }.

      // 레벨/속도 갱신
      레벨 <- ((총_줄 / 10) 바닥) + 1.
      낙하_주기 <- 낙하_기본 - (레벨 - 1) * 낙하_가속.
      (낙하_주기 < 낙하_최소) 일때 {
        낙하_주기 <- 낙하_최소.
      }.

      // 다음 조각 스폰
      조각_id <- 다음_큐[0].
      다음_큐 <- (다음_큐, 0) 제거.
      { (다음_큐) 길이 < 다음_큐_길이 }인것 동안: {
        가방_길이 <- (가방) 길이.
        { (가방_길이 == 0) }인것 일때 {
          가방 <- [0, 1, 2, 3, 4, 5, 6].
          가방_길이 <- 7.
        }.
        뽑기_인덱스 <- (0, 가방_길이 - 1) 무작위정수.
        뽑힌_id <- 가방[뽑기_인덱스].
        가방 <- (가방, 뽑기_인덱스) 제거.
        다음_큐 <- (다음_큐, 뽑힌_id) 추가.
      }.
      홀드_사용됨 <- 0.
      // 스폰 리셋
      조각_x <- 4.
      조각_y <- 0.
      조각_회전 <- 0.
      락_카운트 <- 0.
      낙하_카운트 <- 0.
      마지막_회전 <- 0.
      스폰_가능 <- (보드, 보드_가로, 보드_세로, 조각_id, 조각_회전, 조각_x, 조각_y) tetris_can_place.
      { 스폰_가능 }아닌것 일때 {
        게임오버 <- 1.
        게임오버_텍스트 <- 게임오버_라벨.
      }.
    }.
  }.

  // 심볼/문자 매핑 (compact)
  조각_심볼 <- "sym:tetris.I".
  조각_문자 <- "I".
  (조각_id >= 0) 일때 {
    (조각_id <= 6) 일때 {
      조각_심볼 <- 조각_심볼_목록[조각_id].
      조각_문자 <- 조각_문자_목록[조각_id].
    }.
  }.

  홀드_문자 <- "-".
  (홀드_id >= 0) 일때 {
    (홀드_id <= 6) 일때 {
      홀드_문자 <- 조각_문자_목록[홀드_id].
    }.
  }.

  다음_문자_목록 <- [].
  (항목) 다음_큐에 대해: {
    임시_문자 <- "?".
    (항목 >= 0) 일때 {
      (항목 <= 6) 일때 {
        임시_문자 <- 조각_문자_목록[항목].
      }.
    }.
    다음_문자_목록 <- (다음_문자_목록, 임시_문자) 추가.
  }.
  다음_문자열 <- (다음_문자_목록, " ") 붙이기.

  // 보드 잠금 블록 목록
  보개_그림판_목록 <- (보드, 보드_가로, 보드_세로, 보드_원점_x, 보드_원점_y, 셀) tetris_board_drawlist.

  // 현재 조각 4블록
  블록_목록 <- [].
  (i) [0, 1, 2, 3] 모두 {
    임시_블록 <- (조각_id, 조각_회전, i) tetris_piece_block.
    블록_목록 <- (블록_목록, 임시_블록) 추가.
  }.
  블록_x_목록 <- [0, 0, 0, 0].
  블록_y_목록 <- [0, 0, 0, 0].
  픽셀_x <- [0, 0, 0, 0].
  픽셀_y <- [0, 0, 0, 0].
  (i) [0, 1, 2, 3] 모두 {
    블록_x_목록[i] <- 조각_x + (블록_목록[i], "dx") 묶음값.
    블록_y_목록[i] <- 조각_y + (블록_목록[i], "dy") 묶음값.
    픽셀_x[i] <- 보드_원점_x + (블록_x_목록[i] * 셀).
    픽셀_y[i] <- 보드_원점_y + (블록_y_목록[i] * 셀).
  }.

  현재.생김새.그림 <- (x=픽셀_x[0], y=픽셀_y[0], w=셀, h=셀, uri=조각_심볼).
  현재1.생김새.그림 <- (x=픽셀_x[1], y=픽셀_y[1], w=셀, h=셀, uri=조각_심볼).
  현재2.생김새.그림 <- (x=픽셀_x[2], y=픽셀_y[2], w=셀, h=셀, uri=조각_심볼).
  현재3.생김새.그림 <- (x=픽셀_x[3], y=픽셀_y[3], w=셀, h=셀, uri=조각_심볼).

  // 고스트 조각
  고스트_y <- (보드, 보드_가로, 보드_세로, 조각_id, 조각_회전, 조각_x, 조각_y) tetris_drop_y.
  고스트_x_목록 <- [0, 0, 0, 0].
  고스트_y_목록 <- [0, 0, 0, 0].
  (i) [0, 1, 2, 3] 모두 {
    고스트_x_목록[i] <- 조각_x + (블록_목록[i], "dx") 묶음값.
    고스트_y_목록[i] <- 고스트_y + (블록_목록[i], "dy") 묶음값.
  }.

  유령.생김새.그림 <- (x=보드_원점_x + (고스트_x_목록[0] * 셀), y=보드_원점_y + (고스트_y_목록[0] * 셀), w=셀, h=셀, uri=조각_심볼).
  유령1.생김새.그림 <- (x=보드_원점_x + (고스트_x_목록[1] * 셀), y=보드_원점_y + (고스트_y_목록[1] * 셀), w=셀, h=셀, uri=조각_심볼).
  유령2.생김새.그림 <- (x=보드_원점_x + (고스트_x_목록[2] * 셀), y=보드_원점_y + (고스트_y_목록[2] * 셀), w=셀, h=셀, uri=조각_심볼).
  유령3.생김새.그림 <- (x=보드_원점_x + (고스트_x_목록[3] * 셀), y=보드_원점_y + (고스트_y_목록[3] * 셀), w=셀, h=셀, uri=조각_심볼).

  // 라인 삭제 연출 타이머
  (라인_연출_카운트 > 0) 일때 {
    라인_연출_카운트 <- 라인_연출_카운트 - 1.
    (라인_연출_카운트 == 0) 일때 {
      라인_연출_텍스트 <- "".
    }.
  }.

  // 텍스트 갱신
  상태 <- (p=조각_문자, h=홀드_문자, n=다음_문자열, r=조각_회전) 글무늬{"P={p} H={h} N={n} R={r}"}.
  상태표.생김새.글씨 <- (x=4, y=4, size=12, text=상태).
  라인표.생김새.글씨 <- (x=4, y=30, size=10, text=라인_연출_텍스트).
  게임오버표.생김새.글씨 <- (x=52, y=150, size=16, text=게임오버_텍스트).
  점수표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y, size=12, text=(label=점수_라벨, s=점수) 글무늬{"{label} {s}"}).
  줄수표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + 패널_줄간격, size=12, text=(label=줄수_라벨, l=총_줄) 글무늬{"{label} {l}"}).
  레벨표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 2), size=12, text=(label=레벨_라벨, lv=레벨) 글무늬{"{label} {lv}"}).
  콤보표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 3), size=10, text=(label=콤보_라벨, c=콤보) 글무늬{"{label} {c}"}).
  백투백표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 4), size=10, text=(label=백투백_라벨, b=백투백) 글무늬{"{label} {b}"}).
  홀드표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 8), size=12, text=(label=홀드_라벨, h=홀드_문자) 글무늬{"{label} {h}"}).
  다음표.생김새.글씨 <- (x=패널_텍스트_x, y=패널_텍스트_y + (패널_줄간격 * 10), size=10, text=(label=다음_라벨, n=다음_문자열) 글무늬{"{label} {n}"}).

  보개로 그려.
}.
